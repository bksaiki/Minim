;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Foreign procedures
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Booleans

(define boolean? (#%foreign-procedure "boolean?" (object) object))
(define not (#%foreign-procedure "not" (object) object))

;; Characters

(define char? (#%foreign-procedure "char?" (object) object))
(define char->integer (#%foreign-procedure "char->integer" (object) object))
(define integer->char (#%foreign-procedure "integer->char" (object) object))

;; Symbols

(define symbol? (#%foreign-procedure "symbol?" (object) object))

;; Strings

(define string? (#%foreign-procedure "string?" (object) object))
(define symbol->string (#%foreign-procedure "symbol->string" (object) object))
(define string->symbol (#%foreign-procedure "string->symbol" (object) object))
(define $string-append (#%foreign-procedure "string-append" (object object) object))

;; Numbers

(define fixnum? (#%foreign-procedure "fx?" (object) object))
(define fxneg (#%foreign-procedure "fxneg" (object) object))
(define fx+ (#%foreign-procedure "fx+" (object object) object))
(define fx- (#%foreign-procedure "fx-" (object object) object))
(define fx* (#%foreign-procedure "fx*" (object object) object))
(define fx/ (#%foreign-procedure "fx/" (object object) object))
(define fx= (#%foreign-procedure "fx=" (object object) object))
(define fx< (#%foreign-procedure "fx<" (object object) object))
(define fx> (#%foreign-procedure "fx>" (object object) object))
(define fx<= (#%foreign-procedure "fx<=" (object object) object))
(define fx>= (#%foreign-procedure "fx>=" (object object) object))

;; Pairs / Lists

(define null? (#%foreign-procedure "null?" (object) object))
(define pair? (#%foreign-procedure "pair?" (object) object))
(define list? (#%foreign-procedure "list?" (object) object))

(define cons (#%foreign-procedure "cons" (object object) object))
(define car (#%foreign-procedure "car" (object) object))
(define cdr (#%foreign-procedure "cdr" (object) object))

(define length (#%foreign-procedure "length" (object) object))
(define reverse (#%foreign-procedure "reverse" (object) object))
(define append2 (#%foreign-procedure "append" (object object) object))

;; Vectors

(define vector? (#%foreign-procedure "vector?" (object) object))
(define vector-length (#%foreign-procedure "vector-length" (object) object))
(define vector-ref (#%foreign-procedure "vector-ref" (object object) object))
(define vector-set! (#%foreign-procedure "vector-set!" (object object object) object))
(define list->vector (#%foreign-procedure "list->vector" (object) object))

;; Procedures

(define procedure? (#%foreign-procedure "procedure?" (object) object))

;; Ports

(define write (#%foreign-procedure "write" (object) object))
(define newline (#%foreign-procedure "newline" () object))
(define flush-output (#%foreign-procedure "flush-output" () object))

;; Exceptions

(define error1 (#%foreign-procedure "error1" (object object) object))
(define error2 (#%foreign-procedure "error2" (object object object) object))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Complex primitives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Numbers

(define number? fixnum?)
(define integer? fixnum?)

(define (+ . xs)
  (let loop ([xs xs] [acc 0])
    (cond [(null? xs) acc]
          [else (loop (cdr xs) (fx+ acc (car xs)))])))

(define (- x . xs)
  (if (null? xs)
      (fxneg x)
      (let loop ([xs xs] [acc x])
        (cond [(null? xs) acc]
              [else (loop (cdr xs) (fx- acc (car xs)))]))))

(define (* . xs)
  (let loop ([xs xs] [acc 1])
    (cond [(null? xs) acc]
          [else (loop (cdr xs) (fx* acc (car xs)))])))

(define (/ x . xs)
  (if (null? xs)
      (fx/ 1 x)
      (let loop ([xs xs] [acc x])
        (cond [(null? xs) acc]
              [else (loop (cdr xs) (fx/ acc (car xs)))]))))

(define (= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (< x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx< x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (> x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx> x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (<= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx<= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (>= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx>= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

;; Pair / List

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))

(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (list . xs)
  xs)

(define (append . xs)
  (cond
    [(null? xs) '()]
    [else
     (define xs (reverse xs))
     (let loop ([xs (cdr xs)] [lst (car xs)])
       (cond [(null? xs) lst]
             [else (loop (cdr xs) (append2 (car xs) lst))]))]))

;; Vectors

(define (vector . xs)
  (list->vector xs))

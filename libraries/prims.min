;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Foreign procedures
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Booleans

(define boolean? (#%foreign-procedure "boolean?" (object) object))
(define not (#%foreign-procedure "not" (object) object))

;; Characters

(define char? (#%foreign-procedure "char?" (object) object))
(define char->integer (#%foreign-procedure "char->integer" (object) object))
(define integer->char (#%foreign-procedure "integer->char" (object) object))

;; Symbols

(define symbol? (#%foreign-procedure "symbol?" (object) object))

;; Strings

(define string? (#%foreign-procedure "string?" (object) object))
(define symbol->string (#%foreign-procedure "symbol->string" (object) object))
(define string->symbol (#%foreign-procedure "string->symbol" (object) object))
(define $string-append (#%foreign-procedure "string-append" (object object) object))

;; Numbers

(define fixnum? (#%foreign-procedure "fx?" (object) object))
(define fxneg (#%foreign-procedure "fxneg" (object) object))
(define fx+ (#%foreign-procedure "fx+" (object object) object))
(define fx- (#%foreign-procedure "fx-" (object object) object))
(define fx* (#%foreign-procedure "fx*" (object object) object))
(define fx/ (#%foreign-procedure "fx/" (object object) object))
(define fx= (#%foreign-procedure "fx=" (object object) object))
(define fx< (#%foreign-procedure "fx<" (object object) object))
(define fx> (#%foreign-procedure "fx>" (object object) object))
(define fx<= (#%foreign-procedure "fx<=" (object object) object))
(define fx>= (#%foreign-procedure "fx>=" (object object) object))

;; Pairs / Lists

(define null? (#%foreign-procedure "null?" (object) object))
(define pair? (#%foreign-procedure "pair?" (object) object))
(define list? (#%foreign-procedure "list?" (object) object))

(define cons (#%foreign-procedure "cons" (object object) object))
(define car (#%foreign-procedure "car" (object) object))
(define cdr (#%foreign-procedure "cdr" (object) object))

(define length (#%foreign-procedure "length" (object) object))
(define reverse (#%foreign-procedure "reverse" (object) object))
(define append2 (#%foreign-procedure "append" (object object) object))

;; Vectors

(define vector? (#%foreign-procedure "vector?" (object) object))
(define vector-length (#%foreign-procedure "vector-length" (object) object))
(define vector-ref (#%foreign-procedure "vector-ref" (object object) object))
(define vector-set! (#%foreign-procedure "vector-set!" (object object object) object))
(define list->vector (#%foreign-procedure "list->vector" (object) object))

;; Procedures

(define procedure? (#%foreign-procedure "procedure?" (object) object))

;; Ports
(define input-port? (#%foreign-procedure "input-port?" (object) object))
(define output-port? (#%foreign-procedure "output-port?" (object) object))
(define current-input-port (#%foreign-procedure "current-input-port" () object))
(define current-output-port (#%foreign-procedure "current-output-port" () object))
(define write (#%foreign-procedure "write" (object object) object))
(define newline (#%foreign-procedure "newline" (object) object))
(define flush-output (#%foreign-procedure "flush-output" (object) object))

;; Exceptions

(define $error1 (#%foreign-procedure "error1" (object object) object))
(define $error2 (#%foreign-procedure "error2" (object object object) object))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Complex primitives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Numbers

(define number? fixnum?)
(define integer? fixnum?)

(define (+ . xs)
  (let loop ([xs xs] [acc 0])
    (cond [(null? xs) acc]
          [else (loop (cdr xs) (fx+ acc (car xs)))])))

(define (- x . xs)
  (if (null? xs)
      (fxneg x)
      (let loop ([xs xs] [acc x])
        (cond [(null? xs) acc]
              [else (loop (cdr xs) (fx- acc (car xs)))]))))

(define (* . xs)
  (let loop ([xs xs] [acc 1])
    (cond [(null? xs) acc]
          [else (loop (cdr xs) (fx* acc (car xs)))])))

(define (/ x . xs)
  (if (null? xs)
      (fx/ 1 x)
      (let loop ([xs xs] [acc x])
        (cond [(null? xs) acc]
              [else (loop (cdr xs) (fx/ acc (car xs)))]))))

(define (= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (< x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx< x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (> x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx> x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (<= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx<= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (>= x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) #t]
          [(fx>= x (car xs)) (loop (car xs) (cdr xs))]
          [else #f])))

(define (zero? x)
  (and (number? x) (= x 0)))

(define (positive? x)
  (and (number? x) (> x 0)))

(define (negative? x)
  (and (number? x) (< x 0)))

(define (max x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) x]
          [(> (car xs) x) (loop (car xs) (cdr xs))]
          [else (loop x (cdr xs))])))

(define (min x . xs)
  (let loop ([x x] [xs xs])
    (cond [(null? xs) x]
          [(< (car xs) x) (loop (car xs) (cdr xs))]
          [else (loop x (cdr xs))])))

(define (abs x)
  (if (negative? x) (- x) x))

;; Pair / List

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))

(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (list . xs)
  xs)

(define (list-ref lst k)
  (if (and (integer? k) (not (negative? k)))
      (let loop ([xs lst] [i 0])
        (cond
          [(null? xs) ($error2 'list-ref "index out of bounds" k)]
          [(not (pair? xs)) ($error2 'list-ref "expected a list" lst)]
          [(< i k) (loop (cdr xs) (+ i 1))]
          [else (car xs)]))
      ($error2 'list-ref "expected non-negative integer" k)))

(define (append . xs)
  (cond
    [(null? xs) '()]
    [else
     (define xs (reverse xs))
     (let loop ([xs (cdr xs)] [lst (car xs)])
       (cond [(null? xs) lst]
             [else (loop (cdr xs) (append2 (car xs) lst))]))]))

;; Vectors

(define (vector . xs)
  (list->vector xs))

(define (vector->list v)
  (define n (vector-length v))
  (let loop ([i 0] [lst '()])
    (if (< i n)
        (loop (+ i 1) (cons (vector-ref v i) lst))
        (reverse lst))))


(define x (list 1 2 3 4 5))
(define x2 (list-ref x 9))

;; Tests for <lib>/private/list.min

;; xcons  TODO: srfi/1
; (equal? (xcons 1 2) '(2 . 1))

;; list*
(equal? (list* 1) 1)
(equal? (list* 1 2) '(1 . 2))
(equal? (list* 1 2 3) '(1 2 . 3))
(equal? (list* 1 2 3 4) '(1 2 3 . 4))
(equal? (list* 1 2 (list 3 4)) (list 1 2 3 4))

;; list-copy  TODO: srfi/1
; (equal? (list-copy '()) '())
; (equal? (list-copy '(1 2 3)) '(1 2 3))
; (equal? (list-copy '(1 2 3 4 5)) '(1 2 3 4 5))

;; make-list
(equal? (make-list 3) '(0 0 0))
(equal? (make-list 3 1) '(1 1 1))

;; list-set
(equal? (list-set '(1 2 3) 2 1) '(1 2 1))
(equal? (list-set '(1 2 3) 1 0) '(1 0 3))

;; list-update
(equal? (list-update '(1 2 3) 2 add1) '(1 2 4))
(equal? (list-update '(1 2 3) 1 (lambda (x) (* 2 x))) '(1 4 3))

;; first, second, etc.
(def lst '(1 2 3 4 5 6 7 8 9 10))
(equal? (first lst) 1)
(equal? (second lst) 2)
(equal? (third lst) 3)
(equal? (fourth lst) 4)
(equal? (fifth lst) 5)
(equal? (sixth lst) 6)
(equal? (seventh lst) 7)
(equal? (eighth lst) 8)
(equal? (ninth lst) 9)
(equal? (tenth lst) 10)

;; take
(equal? (take lst 0) '())
(equal? (take lst 4) '(1 2 3 4))

;; drop
(equal? (drop lst 0) '(1 2 3 4 5 6 7 8 9 10))
(equal? (drop lst 4) '(5 6 7 8 9 10))

;; take-right
(equal? (take-right '(a b c d e) 0) '())
(equal? (take-right '(a b c d e) 2) '(d e))

;; drop-right
(equal? (drop-right '(a b c d e) 0) '(a b c d e))
(equal? (drop-right '(a b c d e) 2) '(a b c))

;; split-at
(let ()
  (def-values (t1 d1) (split-at lst 0))
  (def-values (t2 d2) (split-at lst 4))
  (equal? t1 '())
  (equal? t2 '(1 2 3 4))
  (equal? d1 '(1 2 3 4 5 6 7 8 9 10))
  (equal? d2 '(5 6 7 8 9 10)))

;; last
(equal? (last lst) 10)

;; last-pair
(equal? (last-pair lst) '(10))

;; filter
(equal? (filter negative? (list)) '())
(equal? (filter negative? (list 1)) '())
(equal? (filter negative? (list -1)) '(-1))
(equal? (filter negative? (list -1 0 1)) '(-1))
(equal? (filter negative? (list -3 -2 -1 0)) '(-3 -2 -1))

;; filter-not
(equal? (filter-not negative? (list)) '())
(equal? (filter-not negative? (list 1)) '(1))
(equal? (filter-not negative? (list -1)) '())
(equal? (filter-not negative? (list -1 0 1)) '(0 1))
(equal? (filter-not negative? (list -1 0 2 3)) '(0 2 3))

;; partition
(let ()
  (def-values (in out) (partition negative? '(-2 -1 0 1 2)))
  (equal? in '(-2 -1))
  (equal? out '(0 1 2)))

;; count
(equal? (count even? '(-2 -1 0 1 2)) 3)
(equal? (count odd? '(-2 -1 0 1 2)) 2)

;; remove
(equal? (remove 0 (list)) '())
(equal? (remove 1 (list 1)) '())
(equal? (remove 1 (list 1 2 3)) '(2 3))
(equal? (remove 2 (list 1 2 3)) '(1 3))
(equal? (remove 4 (list 1 2 3)) '(1 2 3))
(equal? (remove 2 (list 1 2 3 2 1)) '(1 3 1))
(equal? (remove 1 (list 1 2 3 2 1)) '(2 3 2))

;; find
(equal? (find even? '(1 2 3)) 2)
(equal? (find even? '(1 7 3)) #f)

;; find-tail
(equal? (find-tail even? '(1 2 3)) '(2 3))
(equal? (find-tail even? '(1 7 3)) #f)

;; member
(equal? (member 3 '(1 2 3 2 1)) '(3 2 1))
(equal? (member 4 '(1 2 3 2 1)) #f)

;; assoc
(equal? (assoc 'a '((a 1) (b 2) (c 3))) '(a 1))
(equal? (assoc 'c '((a 1) (b 2) (c 3))) '(c 3))
(equal? (assoc (list 'a) '(((a)) ((b)) ((c)))) '((a)))
(equal? (assoc 'd '((a 1) (b 2) (c 3))) #f)

;; remove*
(equal? (remove* (list 1) (list 1 2 3)) (list 2 3))
(equal? (remove* (list 1 3) (list 1 2 3)) (list 2))
(equal? (remove* (list 1 2 3) (list 1 2 3)) (list))

;; append*
(equal? (append* (list (list 1 2) (list 3 4))) (list 1 2 3 4))
(equal? (append* (list 1 2) (list (list 3 4) (list 5 6))) (list 1 2 3 4 5 6))

;; append-map
(equal? (append-map vector->list (list (vector 1 2)))
        (list 1 2))
(equal? (append-map vector->list (list (vector 1 2) (vector 3 4)))
        (list 1 2 3 4))

;; foldl
(equal? (foldl + 0 '()) 0)
(equal? (foldl + 0 '(1)) 1)
(equal? (foldl + 0 '(1 2 3)) 6)
(equal? (foldl cons '() '(1 2 3)) '(3 2 1))
(equal? (foldl list* '() '(a b c) '(1 2 3)) '(c 3 b 2 a 1))
(equal? (foldl list '() '(a b c) '(1 2 3) '(A B C)) '(c 3 C (b 2 B (a 1 A ()))))

;; foldr
(equal? (foldr + 0 '()) 0)
(equal? (foldr + 0 '(1)) 1)
(equal? (foldr + 0 '(1 2 3)) 6)
(equal? (foldr cons '() '(1 2 3)) '(1 2 3))
(equal? (foldr list* '() '(a b c) '(1 2 3)) '(a 1 b 2 c 3))
(equal? (foldr list '() '(a b c) '(1 2 3) '(A B C)) '(a 1 A (b 2 B (c 3 C ()))))

;; Tests for <lib>/private/list.min

;; make-list
(equal? (make-list 3) '(0 0 0))
(equal? (make-list 3 1) '(1 1 1))

;; first, second, etc.
(def lst '(1 2 3 4 5 6 7 8 9 10))
(equal? (first lst) 1)
(equal? (second lst) 2)
(equal? (third lst) 3)
(equal? (fourth lst) 4)
(equal? (fifth lst) 5)
(equal? (sixth lst) 6)
(equal? (seventh lst) 7)
(equal? (eighth lst) 8)
(equal? (ninth lst) 9)
(equal? (tenth lst) 10)

;; take
(equal? (take lst 0) '())
(equal? (take lst 4) '(1 2 3 4))

;; drop
(equal? (drop lst 0) '(1 2 3 4 5 6 7 8 9 10))
(equal? (drop lst 4) '(5 6 7 8 9 10))

;; split-at
(let ()
  (def-values (t1 d1) (split-at lst 0))
  (def-values (t2 d2) (split-at lst 4))
  (equal? t1 '())
  (equal? t2 '(1 2 3 4))
  (equal? d1 '(1 2 3 4 5 6 7 8 9 10))
  (equal? d2 '(5 6 7 8 9 10)))

;; last
(equal? (last lst) 10)

;; last-pair
(equal? (last-pair lst) '(10))

;; remove*
(equal? (remove* (list 1) (list 1 2 3)) (list 2 3))
(equal? (remove* (list 1 3) (list 1 2 3)) (list 2))
(equal? (remove* (list 1 2 3) (list 1 2 3)) (list))

;; list*
(equal? (list* 1 2 3) '(1 2 . 3))
(equal? (list* 1 2 (list 3 4)) (list 1 2 3 4))

;; andmap
(equal? (andmap positive? (list 1 2 3)) #t)
(equal? (andmap positive? (list 1 -2 3)) #f)
(equal? (andmap positive? (list -1 -2 -3)) #f)

;; ormap
(equal? (ormap positive? (list 1 2 3)) #t)
(equal? (ormap positive? (list 1 -2 3)) #t)
(equal? (ormap positive? (list -1 -2 -3)) #f)

;; append*
(equal? (append* (list (list 1 2) (list 3 4))) (list 1 2 3 4))
(equal? (append* (list 1 2) (list (list 3 4) (list 5 6))) (list 1 2 3 4 5 6))

;; append-map
(equal? (append-map vector->list (list (vector 1 2)))
        (list 1 2))
(equal? (append-map vector->list (list (vector 1 2) (vector 3 4)))
        (list 1 2 3 4))

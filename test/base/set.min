;;;
;;; Tests for 'set'
;;;

(import "../../src/library/base.min")

(define num-failed 0)

(define (check-equal? d0 d1)
  (unless (equal? d0 d1)
    (display "[FAIL] expected ")
    (write d1)
    (display ", received ")
    (write d0)
    (newline)
    (set! num-failed (+ num-failed 1))))

(define (check-true d)
  (unless d
    (display "[FAIL] expected #t")
    (display ", received ")
    (write d)
    (newline)
    (set! num-failed (+ num-failed 1))))

(define (check-false d)
  (when d
    (display "[FAIL] expected #f")
    (display ", received ")
    (write d)
    (newline)
    (set! num-failed (+ num-failed 1))))


;; Test `make-set`, `set?`, and `set-count`
(let ()
  (define s0 (make-set))
  (check-true (set? s0))
  (check-equal? (set-count s0) 0)

  (define s1 (make-set 1))
  (check-true (set? s1))
  (check-equal? (set-count s1) 1)

  (define s2 (make-set 1 2))
  (check-true (set? s2))
  (check-equal? (set-count s2) 2)

  (define s3 (make-set 1 2 3))
  (check-true (set? s3))
  (check-equal? (set-count s3) 3)

  (void))

;; Test `set->list`
(let ()
  (define s0 (make-set))
  (check-equal? (set->list s0) '())

  (define s1 (make-set 1))
  (check-equal? (set->list s1) '(1))

  (define s2 (make-set 1 2))
  (check-equal? (set->list s2) '(2 1))

  (define s3 (make-set 1 2 3))
  (check-equal? (set->list s3) '(2 1 3))

  (void))

;; Test `set-count`
(let ()
  (define s0 (make-set))
  (check-equal? (set->list s0) '())

  (define s1 (make-set 1))
  (check-equal? (set->list s1) '(1))

  (define s2 (make-set 1 2))
  (check-equal? (set->list s2) '(2 1))

  (define s3 (make-set 1 2 3))
  (check-equal? (set->list s3) '(2 1 3))

  (void))

;; Test `set-count`
(let ()
  (define s3 (make-set 1 2 3))
  (check-true (set-member? s3 1))
  (check-true (set-member? s3 2))
  (check-true (set-member? s3 3))
  (check-false (set-member? s3 4))
  (check-false (set-member? s3 5))
  (void))

;; Test `set-add!`
(let ()
  (define s (make-set 1 2 3))

  (set-add! s 4)
  (check-equal? (set-count s) 4)
  (check-true (set-member? s 4))

  (set-remove! s 4)
  (check-equal? (set-count s) 3)
  (check-false (set-member? s 4))

  (void))

;; Test `set-union`
(let ()
  (define s0 (make-set))
  (define s1 (make-set 1 2))
  (define s2 (make-set 2 3))
  (define s3 (make-set 4 5 6))

  ; 0 arguments
  (check-equal? (set->list (set-union)) '())

  ; 1 arguments
  (check-equal? (set->list (set-union s1)) (set->list s1))
  (check-equal? (set->list (set-union s2)) (set->list s2))
  (check-equal? (set->list (set-union s3)) (set->list s3))

  ; 2 arguments
  (check-equal? (set->list (set-union s0 s1)) (set->list s1))
  (check-equal? (set->list (set-union s0 s3)) (set->list s3))
  (check-equal? (set->list (set-union s1 s2)) '(2 1 3))
  (check-equal? (set->list (set-union s1 s3)) '(2 6 1 5 4))

  ; 3 arguments
  (check-equal? (set->list (set-union s1 s1 s1)) (set->list s1))
  (check-equal? (set->list (set-union s1 s2 s3)) '(2 6 1 5 4 3))

  (void))

;; Test `set-intersect`
(let ()
  (define s0 (make-set))
  (define s1 (make-set 1 2))
  (define s2 (make-set 2 3))
  (define s3 (make-set 1 2 3))

  ; 0 arguments
  (check-equal? (set->list (set-intersect)) '())

  ; 1 arguments
  (check-equal? (set->list (set-intersect s1)) (set->list s1))
  (check-equal? (set->list (set-intersect s2)) (set->list s2))
  (check-equal? (set->list (set-intersect s3)) (set->list s3))

  ; 2 arguments
  (check-equal? (set->list (set-intersect s3 s3)) (set->list s3))
  (check-equal? (set->list (set-intersect s0 s1)) '())
  (check-equal? (set->list (set-intersect s0 s3)) '())
  (check-equal? (set->list (set-intersect s1 s2)) '(2))
  (check-equal? (set->list (set-intersect s1 s3)) '(2 1))

  ; 3 arguments
  (check-equal? (set->list (set-intersect s1 s1 s1)) (set->list s1))
  (check-equal? (set->list (set-intersect s1 s2 s3)) '(2))

  (void))

(when (> num-failed 0)
  (error #f "test failed"))

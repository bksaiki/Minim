;;;
;;; Tests for 'record'
;;;

(import "../../src/library/base.min")

(define num-failed 0)

(define (check-equal? d0 d1)
  (unless (equal? d0 d1)
    (display "[FAIL] expected ")
    (write d1)
    (display ", received ")
    (write d0)
    (newline)
    (set! num-failed (+ num-failed 1))))

(define (check-true d)
  (unless d
    (display "[FAIL] expected ")
    (write d1)
    (display ", received ")
    (write d0)
    (newline)
    (set! num-failed (+ num-failed 1))))

(define (check-false d)
  (when d
    (display "[FAIL] expected ")
    (write d1)
    (display ", received ")
    (write d0)
    (newline)
    (set! num-failed (+ num-failed 1))))

;; Low-level record procedures
(define (test-0)
  (define point (make-record-type-descriptor 'point #f #f #f #f '#((mutable x) (mutable y) (mutable z))))
  (define make-point (record-constructor point))
  (define point? (record-predicate point))
  (define point-x (record-accessor point 0))
  (define point-y (record-accessor point 1))
  (define point-z (record-accessor point 2))
  (define point-x-set! (record-mutator point 0))
  (define point-y-set! (record-mutator point 1))
  (define point-z-set! (record-mutator point 2))

  (define p (make-point 1 2 3))

  (check-true (point? p))
  (check-equal? (record-rtd p) point)
  (check-equal? (point-x p) 1)
  (check-equal? (point-y p) 2)
  (check-equal? (point-z p) 3)

  (point-x-set! p 2)
  (point-y-set! p 3)
  (point-z-set! p 4)

  (point? p)
  (point-x p)
  (point-y p)
  (point-z p)
  
  (check-equal? (point-x p) 2)
  (check-equal? (point-y p) 3)
  (check-equal? (point-z p) 4)

  (void))


;; Basic `define-record-type` test
(define (test-1)

  (define-record-type rec
    (fields
      (immutable a rec-get-a)
      (mutable b rec-get-b rec-set-b!)
      (immutable c)
      (mutable d)
      e))

  (check-true (record-type-descriptor? rec))
  (check-equal? (record-type-field-names rec) #(a b c d e))
  (check-equal?
    (map (lambda (i) (record-type-field-mutable? rec i)) '(0 1 2 3 4))
    '(#f #t #f #t #f))

  ; make sure it doesn't crash
  make-rec
  rec?
  (list
    rec-get-a
    rec-get-b
    rec-c
    rec-d
    rec-e)
  (list
    rec-set-b!
    rec-d-set!)


  (define r (make-rec 1 2 3 4 5))
  (check-equal? (record-rtd r) rec)
  (check-true (rec? r))
  (check-false (rec? rec))
  (check-false (rec? 1))

  (check-equal? (rec-get-a r) 1)
  (check-equal? (rec-get-b r) 2)
  (check-equal? (rec-c r) 3)
  (check-equal? (rec-d r) 4)
  (check-equal? (rec-e r) 5)

  (rec-set-b! r #f)
  (rec-d-set! r #f)

  (check-equal? (rec-get-a r) 1)
  (check-equal? (rec-get-b r) #f)
  (check-equal? (rec-c r) 3)
  (check-equal? (rec-d r) #f)
  (check-equal? (rec-e r) 5)

  (void))


;; Test inheritance
(define (test-2)

  (define point
    (make-record-type-descriptor 'point #f
      #f #f #f '#((mutable x) (mutable y))))

  (define cpoint
    (make-record-type-descriptor 'cpoint point
      #f #f #f '#((mutable color))))


  (void))


;; Run the tests

(test-0)
(test-1)
(test-2)

(when (> num-failed 0)
  (error #f "test failed"))

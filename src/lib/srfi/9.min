;
;   SRFI 9 records
;

(%import "../private/pre-base.min")

(%export make-record-type
         record-constructor
         record-predicate
         record-accessor
         record-modifier
         def-record
         vector?) ; re-export

;;;;;;;;;;;;;;;;;;; records / vector ;;;;;;;;;;;;;;;;;;;

(def record-marker (list 'record-marker))
(def real-vector? vector?)

; redefine
(def vector? (x)
  (and (real-vector? x)
       (or (= (vector-length x) 0)
           (not (equal? (vector-ref x 0) record-marker))))) ; TODO: eq?

(def record? (x)
  (and (real-vector? x)
       (< 0 (vector-length x))
       (equal? (vector-ref x 0) record-marker))) ; TODO: eq?

(def make-record (size)
  (let ([new (make-vector (+ size 1))])
    (vector-set! new 0 record-marker)
    new))

(def record-ref (record idx)
  (vector-ref record (+ idx 1)))

(def record-set! (record idx val)
  (vector-set! record (+ idx 1) val))

(def record-type (record)
  (record-ref record 0))

;;;;;;;;;;;;;;;;;;; record types ;;;;;;;;;;;;;;;;;;;

; base record for other types
(def $record-type (make-record 3))
(record-set! $record-type 0 $record-type)
(record-set! $record-type 1 '$record-type)
(record-set! $record-type 2 '(name field-tags))

; type constructor
(def make-record-type (name field-tags)
  (let ([new (make-record 3)])
    (record-set! new 0 $record-type)
    (record-set! new 1 name)
    (record-set! new 2 field-tags)
    new))

(def record-type-name (record-type)
  (record-ref record-type 1))

(def record-type-field-tags (record-type)
  (record-ref record-type 2))

;;;;;;;;;;;;;;;;;;; record procedures ;;;;;;;;;;;;;;;;;;;

(def field-index (type tag)
  (let loop ([i 1] [tags (record-type-field-tags type)])
    (cond
     [(null? tags) (error "record type has no such field")]
     [(equal? tag (car tags)) i] ; eq?
     [else (loop (+ i 1) (cdr tags))])))

; record constructor
(def record-constructor (type tags)
  (let ([size (length (record-type-field-tags type))]
        [arg-count (length tags)]
        [idxs (map (lambda (tag) (field-index type tag) tags))])
    (lambda args
      (if (= (length args) arg-count)
          (let ([new (make-record (+ size 1))])
            (record-set! new 0 type)
            (for ([arg (in-list args)] [i (in-list idxs)])
              (record-set! new i arg))
            new)
          (error 'record-constructor "arity mismatch")))))

; predicate
(def record-predicate (type)
  (lambda (x) (and (record? x) (equal? (record-type x) type))))

; accessor
(def record-accessor (type tag)
  (let ([idx (field-index type tag)])
    (lambda (x)
      (if (and (record? x) (equal? (record-type x) type))
          (record-ref x idx)
          (error 'record-accessor "expected a record of type")))))

(def record-modifier (type tag)
  (let ([idx (field-index type tag)])
    (lambda (x val)
      (if (and (record? x) (equal? (record-type x) type))
          (record-set! x idx val)
          (error 'record-accessor "expected a record of type")))))

;;;;;;;;;;;;;;;;;;; record ;;;;;;;;;;;;;;;;;;;

(def-syntax def-record (lambda (stx) #'(void)))
; (def-syntax def-record
;   (syntax-rules ()
;    [(_ type (constructor tag ...)
;             predicate
;             (field-tag accessor . more) ...)
;     (begin
;       (def type (make-record-type 'type '(field-tag ...)))
;       (def constructor (record-constructor type '(tag ...)))
;       (def predicate (record-predicate type))
;       (def-record-field type field-tag accessor . more)
;       ...)]))

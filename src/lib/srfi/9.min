;
;   SRFI 9 records
;

(%import "../private/and-or.min"
         "../private/cond.min"
         "../private/def.min"
         "../private/let.min"
         "../private/stx.min"
         "../private/stx-macro.min"
         "../private/with-stx.min"
         "../private/when-unless.min")

(%export make-record-type
         record-type?
         record-constructor
         record-predicate
         record-accessor
         record-modifier
         def-record-type)

;;;;;;;;;;;;;;;;;;; record types ;;;;;;;;;;;;;;;;;;;

; type constructor
(def make-record-type (name field-tags)
  (let ([new (make-record 2)])
    (record-set-type! new new)
    (record-set! new 0 name)
    (record-set! new 1 field-tags)
    new))

(def record-type-name (record-type)
  (record-ref record-type 0))

(def record-type-field-tags (record-type)
  (record-ref record-type 1))

(def record-type? (rtype)
  (and (record? rtype) (eq? (record-type rtype) rtype)))

;;;;;;;;;;;;;;;;;;; record procedures ;;;;;;;;;;;;;;;;;;;

(def field-index (type tag)
  (let loop ([i 0] [tags (record-type-field-tags type)])
    (cond
     [(null? tags) (error "record type has no such field")]
     [(eq? tag (car tags)) i]
     [else (loop (+ i 1) (cdr tags))])))

; record constructor
(def record-constructor (type tags)
  (let ([size (length (record-type-field-tags type))]
        [arg-count (length tags)]
        [idxs (map (lambda (tag) (field-index type tag)) tags)])
    (lambda args
      (if (= (length args) arg-count)
          (let ([new (make-record size)])
            (record-set-type! new type)
            (let loop ([args args] [i 0])
              (unless (null? args)
                (record-set! new i (car args))
                (loop (cdr args) (+ i 1))))
            new)
          (error 'record-constructor "arity mismatch")))))

; predicate
(def record-predicate (type)
  (lambda (x) (and (record? x) (equal? (record-type x) type))))

; accessor
(def record-accessor (type tag name pred)
  (let ([idx (field-index type tag)])
    (lambda (x)
      (if (and (record? x) (equal? (record-type x) type))
          (record-ref x idx)
          (argument-error name (symbol->string pred) x)))))

(def record-modifier (type tag name pred)
  (let ([idx (field-index type tag)])
    (lambda (x val)
      (if (and (record? x) (equal? (record-type x) type))
          (record-set! x idx val)
          (argument-error name (symbol->string pred) 0 x val)))))

;;;;;;;;;;;;;;;;;;; record ;;;;;;;;;;;;;;;;;;;

(def-syntax def-record-type
  (syntax-rules ()
   [(_ type (constructor tag ...) predicate (field-tag accessor . more) ...)
    (begin
      (def type (make-record-type 'type '(field-tag ...)))
      (def constructor (record-constructor type '(tag ...)))
      (def predicate (record-predicate type))
      (def-print-method predicate (lambda (x) (format "#<~a>" 'type)))
      (def-record-field type predicate field-tag accessor . more)
      ...)]))

(def-syntax def-record-field
  (syntax-rules ()
   [(_ type pred field-tag accessor)
    (def accessor (record-accessor type 'field-tag))]
   [(_ type pred field-tag accessor modifier)
    (begin
      (def accessor (record-accessor type 'field-tag 'accessor 'pred))
      (def modifier (record-modifier type 'field-tag 'modifier 'pred)))]))

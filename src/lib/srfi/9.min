;
;   SRFI 9 records
;

(%import "../private/pre-base.min")

(%export make-record-type
         record?
         record-constructor
         record-predicate
         record-accessor
         record-modifier
         def-record-type
         vector?) ; re-export

;;;;;;;;;;;;;;;;;;; records / vector ;;;;;;;;;;;;;;;;;;;

(def record-marker (list 'record-marker))
(def real-vector? vector?)

; redefine
(def vector? (x)
  (and (real-vector? x)
       (or (= (vector-length x) 0)
           (not (eq? (vector-ref x 0) record-marker)))))

(def record? (x)
  (and (real-vector? x)
       (< 0 (vector-length x))
       (eq? (vector-ref x 0) record-marker)))

(def make-record (size)
  (let ([new (make-vector (+ size 1))])
    (vector-set! new 0 record-marker)
    new))

(def record-ref (record idx)
  (vector-ref record (+ idx 1)))

(def record-set! (record idx val)
  (vector-set! record (+ idx 1) val))

(def record-type (record)
  (record-ref record 0))

(def-print-method record?
  (lambda (x) "#<record>"))

;;;;;;;;;;;;;;;;;;; record types ;;;;;;;;;;;;;;;;;;;

; base record for user-defined records
(def $record-type (make-record 3))
(record-set! $record-type 0 $record-type)
(record-set! $record-type 1 '$record-type)
(record-set! $record-type 2 '(name field-tags))

; type constructor
(def make-record-type (name field-tags)
  (let ([new (make-record 3)])
    (record-set! new 0 $record-type)
    (record-set! new 1 name)
    (record-set! new 2 field-tags)
    new))

(def record-type-name (record-type)
  (record-ref record-type 1))

(def record-type-field-tags (record-type)
  (record-ref record-type 2))

;;;;;;;;;;;;;;;;;;; record procedures ;;;;;;;;;;;;;;;;;;;

(def field-index (type tag)
  (let loop ([i 1] [tags (record-type-field-tags type)])
    (cond
     [(null? tags) (error "record type has no such field")]
     [(eq? tag (car tags)) i]
     [else (loop (+ i 1) (cdr tags))])))

; record constructor
(def record-constructor (type tags)
  (let ([size (length (record-type-field-tags type))]
        [arg-count (length tags)]
        [idxs (map (lambda (tag) (field-index type tag)) tags)])
    (lambda args
      (if (= (length args) arg-count)
          (let ([new (make-record (+ size 1))])
            (record-set! new 0 type)
            (for ([arg (in-list args)] [i (in-list idxs)])
              (record-set! new i arg))
            new)
          (error 'record-constructor "arity mismatch")))))

; predicate
(def record-predicate (type)
  (lambda (x) (and (record? x) (equal? (record-type x) type))))

; accessor
(def record-accessor (type tag name pred)
  (let ([idx (field-index type tag)])
    (lambda (x)
      (if (and (record? x) (equal? (record-type x) type))
          (record-ref x idx)
          (argument-error name (symbol->string pred) x)))))

(def record-modifier (type tag name pred)
  (let ([idx (field-index type tag)])
    (lambda (x val)
      (if (and (record? x) (equal? (record-type x) type))
          (record-set! x idx val)
          (argument-error name (symbol->string pred) 0 x val)))))

;;;;;;;;;;;;;;;;;;; record ;;;;;;;;;;;;;;;;;;;

(def-syntax def-record-type
  (syntax-rules ()
   [(_ type (constructor tag ...) predicate (field-tag accessor . more) ...)
    (begin
      (def type (make-record-type 'type '(field-tag ...)))
      (def constructor (record-constructor type '(tag ...)))
      (def predicate (record-predicate type))
      (def-print-method predicate (lambda (x) (format "#<~a>" 'type)))
      (def-record-field type predicate field-tag accessor . more)
      ...)]))

(def-syntax def-record-field
  (syntax-rules ()
   [(_ type pred field-tag accessor)
    (def accessor (record-accessor type 'field-tag))]
   [(_ type pred field-tag accessor modifier)
    (begin
      (def accessor (record-accessor type 'field-tag 'accessor 'pred))
      (def modifier (record-modifier type 'field-tag 'modifier 'pred)))]))

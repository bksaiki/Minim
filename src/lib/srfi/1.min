;
;   SRFI 1: list library
;

(%import "../private/pre-base.min"
         "16.min")

(%export first second third fourth fifth sixth seventh eighth ninth tenth
         make-list
         take drop
         split-at
         last last-pair
         filter filter-not
         partition
         find find-tail
         member
         assoc)

; The following procedures are defined as builtins:
;   cons, list
;   car, cdr,
;   caar, cadr, cdar, cddr
;   length, append, reverse, map
;   list-ref

(def natural? (n)
  (and (number? n) (exact? n) (integer? n) (not (negative? n))))

(def assert-lists? (name pos0 before lsts)
  (let loop ([ls lsts] [pos pos0])
    (unless (null? ls)
      (if (list? (car ls))
          (loop (cdr ls) (+ 1 pos))
          (apply argument-error name "list?" pos (append before lsts))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;; constructors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def make-list
  (case-lambda
   [(n) (make-list n 0)]
   [(n fill)
    (unless (natural? n)
      (argument-error 'make-list "natural?" n))
    (let loop ([i n] [acc '()])
      (if (zero? i)
          acc
          (loop (- i 1) (cons fill acc))))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;; accessors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def first (lst)
  (if (list? lst)
      (car lst)
      (argument-error 'first "list?" lst)))

(def-syntax def-list-accessor
  (syntax-rules ()
   [(_ name npos)
    (def name (lst)
      (if (list? lst)
          (let loop ([l lst] [pos npos])
            (if (pair? l)
                (if (= pos 1)
                    (car l)
                    (loop (cdr l) (- pos 1)))
                (argument-error 'name
                                "list contains too few elements"
                                lst)))
          (argument-error 'name "list?" lst)))]))

(def-list-accessor second   2)
(def-list-accessor third    3)
(def-list-accessor fourth   4)
(def-list-accessor fifth    5)
(def-list-accessor sixth    6)
(def-list-accessor seventh  7)
(def-list-accessor eighth   8)
(def-list-accessor ninth    9)
(def-list-accessor tenth    10)

(def take (x n)
  (unless (list? x)
    (argument-error 'take "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'take "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        '()
        (cons (car lst) (loop (cdr lst) (- i 1))))))

(def drop (x n)
  (unless (list? x)
    (argument-error 'drop "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'drop "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        lst
        (loop (cdr lst) (- i 1)))))

(def split-at (x n)
  (unless (list? x)
    (argument-error 'split-at "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'split-at "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        (values '() lst)
        (let-values ([(t d) (loop (cdr lst) (- i 1))])
          (values (cons (car lst) t) d)))))

(def last (x)
  (unless (list? x)
    (argument-error 'last "list?" x))
  (let loop ([lst x])
    (if (pair? (cdr lst))
        (loop (cdr lst))
        (car lst))))

(def last-pair (x)
  (unless (list? x)
    (argument-error 'last-pair "list?" x))
  (let loop ([lst x])
    (if (pair? (cdr lst))
        (loop (cdr lst))
        lst)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;; filter ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def filter (pred lst)
  (unless (procedure? pred)
    (argument-error 'filter "procedure?" 0 pred lst))
  (unless (list? lst)
    (argument-error 'filter "list?" 1 pred lst))
  (let loop ([lst lst])
    (if (null? lst)
        '()
        (if (pred (car lst))
            (cons (car lst) (loop (cdr lst)))
            (loop (cdr lst))))))

(def filter-not (pred lst)
  (unless (procedure? pred)
    (argument-error 'filter-not "procedure?" 0 pred lst))
  (unless (list? lst)
    (argument-error 'filter-not "list?" 1 pred lst))
  (let loop ([lst lst])
    (if (null? lst)
        '()
        (if (pred (car lst))
            (loop (cdr lst))
            (cons (car lst) (loop (cdr lst)))))))

(def partition (pred lst)
  (unless (procedure? pred)
    (argument-error 'partition "procedure?" 0 pred lst))
  (unless (list? lst)
    (argument-error 'partition "list?" 1 pred lst))
  (let loop ([lst lst])
    (if (null? lst)
        (values '() '())
        (let-values ([(in out) (loop (cdr lst))])
          (if (pred (car lst))
              (values (cons (car lst) in) out)
              (values in (cons (car lst) out)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;; reduce ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (def count (pred . lsts)
;   (unless (procedure? pred)
;     (apply argument-error 'count "procedure?" 0 pred lsts))
;   (assert-lists? 'count 1 (list pred) lsts)
;   (let loop ([lsts lsts] [n 0])
;     (if (null? lsts))

;;;;;;;;;;;;;;;;;;;;;;;;;;; searching ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def find (pred lst)
  (unless (procedure? pred)
    (argument-error 'find "procedure?" 0 pred lst))
  (unless (list? lst)
    (argument-error 'find "list?" 1 pred lst))
  (let loop ([lst lst])
    (if (null? lst)
        #f
        (if (pred (car lst))
            (car lst)
            (loop (cdr lst))))))

(def find-tail (pred lst)
  (unless (procedure? pred)
    (argument-error 'find-tail "procedure?" 0 pred lst))
  (unless (list? lst)
    (argument-error 'find-tail "list?" 1 pred lst))
  (let loop ([lst lst])
    (if (null? lst)
        #f
        (if (pred (car lst))
            lst
            (loop (cdr lst))))))

(def member
  (case-lambda
   [(x lst) (member x lst equal?)]
   [(x lst =?)
    (unless (list? lst)
      (argument-error 'member "list?" 1 x lst =?))
    (unless (procedure? =?)
      (argument-error 'member "list?" 2 x lst =?))
    (let loop ([lst lst])
      (if (null? lst)
          #f
          (if (=? (car lst) x)
              lst
              (loop (cdr lst)))))]))

(def assoc
  (case-lambda
   [(key lst) (assoc key lst equal?)]
   [(key lst =?)
    (unless (list? lst)
      (argument-error 'assoc "list?" 1 x lst =?))
    (unless (procedure? =?)
      (argument-error 'assoc "list?" 2 x lst =?))
    (let loop ([lst lst])
      (if (null? lst)
          #f
          (let ([entry (car lst)])
            (if (pair? entry)
                (if (=? (car entry) key)
                    entry
                    (loop (cdr lst)))
                (argument-error 'assoc "list of pairs" lst)))))]))

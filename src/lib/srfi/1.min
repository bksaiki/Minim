;
;   SRFI 1: list library
;

(%import "../private/pre-base.min"
         "16.min")

(%export first second third fourth fifth sixth seventh eighth ninth tenth
         make-list
         take drop split-at
         last last-pair)

; The following procedures are defined as builtins:
;   cons, list
;   car, cdr,
;   caar, cadr, cdar, cddr
;   length, append, map

(def natural? (n)
  (and (number? n) (exact? n) (integer? n) (not (negative? n))))

(def make-list
  (case-lambda
   [(n) (make-list n 0)]
   [(n fill)
    (unless (natural? n)
      (argument-error 'make-list "natural?" n))
    (let loop ([i n] [acc '()])
      (if (zero? i)
          acc
          (loop (- i 1) (cons fill acc))))]))

(def first (lst)
  (if (list? lst)
      (car lst)
      (argument-error 'first "list?" lst)))

(def-syntax def-list-accessor
  (syntax-rules ()
   [(_ name npos)
    (def name (lst)
      (if (list? lst)
          (let loop ([l lst] [pos npos])
            (if (pair? l)
                (if (= pos 1)
                    (car l)
                    (loop (cdr l) (- pos 1)))
                (argument-error 'name
                                "list contains too few elements"
                                lst)))
          (argument-error 'name "list?" lst)))]))

(def-list-accessor second   2)
(def-list-accessor third    3)
(def-list-accessor fourth   4)
(def-list-accessor fifth    5)
(def-list-accessor sixth    6)
(def-list-accessor seventh  7)
(def-list-accessor eighth   8)
(def-list-accessor ninth    9)
(def-list-accessor tenth    10)

(def take (x n)
  (unless (list? x)
    (argument-error 'take "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'take "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        '()
        (cons (car lst) (loop (cdr lst) (- i 1))))))

(def drop (x n)
  (unless (list? x)
    (argument-error 'drop "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'drop "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        lst
        (loop (cdr lst) (- i 1)))))

(def split-at (x n)
  (unless (list? x)
    (argument-error 'split-at "list?" 0 x n))
  (unless (natural? n)
    (argument-error 'split-at "natural?" 1 x n))
  (let loop ([lst x] [i n])
    (if (zero? i)
        (values '() lst)
        (let-values ([(t d) (loop (cdr lst) (- i 1))])
          (values (cons (car lst) t) d)))))

(def last (x)
  (unless (list? x)
    (argument-error 'last "list?" x))
  (let loop ([lst x])
    (if (pair? (cdr lst))
        (loop (cdr lst))
        (car lst))))

(def last-pair (x)
  (unless (list? x)
    (argument-error 'last-pair "list?" x))
  (let loop ([lst x])
    (if (pair? (cdr lst))
        (loop (cdr lst))
        lst)))

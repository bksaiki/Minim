
;;;;;;;;;;;;;;;;;;;;;; Predicates ;;;;;;;;;;;;;;;;;;;;;;;;;;

(def exact-nonnegative-integer? (n)
  (and (exact-integer? n) (not (negative? n))))

(def exact-positive-integer? (n)
  (and (exact-integer? n) (positive? n)))

;;;;;;;;;;;;;;;;;; Special math functions ;;;;;;;;;;;;;;;;;;;

(def factorial (n)
  (unless (exact-nonnegative-integer? n)
    (error 'factorial "expected a non-negative integer"))
  (def loop (n acc)
    (if (zero? n)
        acc
        (loop (- n 1) (* n acc))))
  (loop n 1))

(def fibonacci (n)
  (unless (exact-nonnegative-integer? n)
    (error 'fibonacci "expected a non-negative integer"))
  (def loop (i x y)
    (if (> i n)
        x
        (loop (+ i 1) (+ x y) x)))
  (loop 1 1 0))

(def gcd (a b)
  (unless (and (integer? a) (integer? b))
    (error 'gcd "expected integer arguments"))
  (def loop (a b)
    (if (= b 0)
        a
        (loop b (mod a b))))
  (loop (abs a) (abs b)))

(def lcm (a b)
  (unless (and (integer? a) (integer? b))
    (error 'lcm "expected integer arguments"))
  (/ (* a b) (gcd a b)))

(def remainder (a b)
  (unless (and (integer? a) (integer? b))
    (error 'remainder "expected integer arguments"))
  (when (zero? b)
    (error 'remainder "denominator cannot be 0"))
  (def m (mod a b))
  (cond
   [(and (negative? a) (positive? b)) (- m b)]
   [(and (positive? a) (negative? b)) (- m b)]
   [else m]))

(def sqr (x)
  (* x x))

(def sgn (x)
  (def s
    (cond
     [(negative? x) -1]
     [(positive? x) 1]
     [else          0]))
  (if (exact? x) s (inexact s)))

;; Functional maps

(def add1 (x)
  (+ x 1))

(def sub1 (x)
  (- x 1))
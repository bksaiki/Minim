;
;   'sequences'
;

(%import "and-or.min"
         "cond.min"
         "def.min"
         "let.min"
         "when-unless.min"
         "record.min"
         "../srfi/16.min")

(%export make-sequence
         sequence?
         sequence-first
         sequence-rest
         sequence-empty?
         empty-sequence
         in-list
         in-range
         in-naturals
         in-vector
         in-string
         sequence->list
         sequence-length
         sequence-ref
         sequence-tail
         sequence-append
         sequence-map
         sequence-andmap
         sequence-ormap)

; function helpers
(def incr (lambda (x) (+ x 1)))
(def identity (lambda (x) x))
(def never (lambda x #f))

; the sequence record
;  'state' - maintains the current location in the sequence
;  'accessor' - operates on state to return the first element
;  'update' - produces a new sequence object with an updated state
;  'end?' - checks the state to see if the sequence if finished
(def-record sequence (state accessor update end?))

(def sequence-first (seq)
  (unless (sequence? seq) (argument-error 'sequence-first "sequence?" seq))
  (unless (sequence-end? seq) (argument-error 'sequence-next "empty sequence" seq))
  (let ([first (sequence-accessor seq)])
    (first (sequence-state seq))))

(def sequence-rest (seq)
  (unless (sequence? seq) (argument 'sequence-next "sequence?" seq))
  (unless (sequence-end? seq) (argument-error 'sequence-next "empty sequence" seq))
  (let ([first (sequence-accessor seq)]
        [rest (sequence-update seq)]
        [end? (sequence-end? seq)])
    (make-sequence (rest (sequence-state seq)) first rest end?)))

(def sequence-empty? (seq)
  (unless (sequence? seq) (argument-error 'sequence-empty? "sequence?" seq))
  (let ([end? (sequence-end? seq)])
    (end? (sequence-state seq))))

;;;;;;;;;;;;;;;;;;;;;;; special sequences ;;;;;;;;;;;;;;;;;;;;;;;

(def empty-sequence (make-sequence #f identity identity (lambda (x) #t)))

;;;;;;;;;;;;;;;;;;;;;;; sequence constructors ;;;;;;;;;;;;;;;;;;;;;;;

(def in-list (lst)
  (unless (list? lst)
    (argument-error 'in-list "list?" lst))
  (make-sequence lst car cdr null?))

(def in-range
  (case-lambda
   [(l) (in-range 0 l 1)]
   [(f l) (in-range f l 1)]
   [(f l s)
    (unless (number? f)
      (argument-error 'in-range "number?" f))
    (unless (number? l)
      (argument-error 'in-range "number?" l))
    (unless (number? s)
      (argument-error 'in-range "number?" s))
    (make-sequence f
                   identity
                   (lambda (x) (+ x s))
                   (lambda (x) (>= x l)))]))

(def in-naturals
  (case-lambda
   [() (in-naturals 0)]
   [(n)
    (unless (or (number? n) (exact? n) (not (negative? n)) (integer? n))
      (argument-error 'in-naturals "number?" n))
    (make-sequence n identity incr never)]))

(def in-vector (v)
  (unless (vector? v)
    (argument-error 'in-vector "vector?" v))
  (def len (vector-length v))
  (make-sequence 0
                 (lambda (x) (vector-ref v x))
                 incr
                 (lambda (x) (= x len))))

(def in-string (s)
  (unless (string? s)
    (argument-error 'in-string "string?" s))
  (def len (string-length s))
  (make-sequence 0
                 (lambda (x) (string-ref s x))
                 incr
                 (lambda (x) (>= x len))))

;;;;;;;;;;;;;;;;;;;;;;; sequence conversions ;;;;;;;;;;;;;;;;;;;;;;;

(def sequence->list (seq)
  (unless (sequence? seq) (argument-error 'sequence-empty? "sequence?" seq))
  (let loop ([accum (list)] [seq seq])
    (if (sequence-empty? seq)
        (reverse accum)
        (loop (cons (sequence-first seq) accum)
              (sequence-rest seq)))))

;;;;;;;;;;;;;;;;;;;;;;; sequence manipulation ;;;;;;;;;;;;;;;;;;;;;;;

(def sequence-length (seq)
  (unless (sequence? seq) (argument-error 'sequence-length "sequence?" seq))
  (let loop ([seq seq] [i 0])
    (if (sequence-empty? seq)
        i
        (loop (sequence-rest seq) (+ i 1)))))

(def sequence-ref (seq n)
  (unless (sequence? seq)
    (argument-error 'sequence-ref "sequence?" seq))
  (unless (exact-nonnegative-integer? n)
    (argument-error 'sequence-ref "non-negative integer" n))
  (let loop ([seq seq] [i 0])
    (cond
     [(sequence-empty? seq) (error 'sequence-ref "index too large ~a" n)]
     [(= i n) (sequence-first seq)]
     [else (loop (sequence-rest seq) (+ i 1))])))
  
(def sequence-tail (seq n)
  (unless (sequence? seq)
    (argument-error 'sequence-tail "sequence?" seq))
  (unless (exact-nonnegative-integer? n)
    (argument-error 'sequence-tail "non-negative integer" n))
  (let loop ([seq seq] [i 0])
    (cond
     [(sequence-empty? seq) (error 'sequence-tail "index too large ~a" n)]
     [(= i n) seq]
     [else (loop (sequence-rest seq) (+ i 1))])))

(def sequence-append seqs
  (let loop ([seqs seqs] [i 0])
    (unless (null? seqs)
      (unless (sequence? (car seqs))
        (argument-error 'sequence-append "sequence?" (car seqs)))
      (loop (cdr seqs) (+ i 1))))
  (cond
   [(null? seqs) empty-sequence]
   [(= (length seqs) 1) (car seqs)]
   [else
    (let ([first (lambda (x) (sequence-first (car x)))]
          [rest (lambda (x)
                  (let ([next0 (sequence-rest (car x))])
                    (if (sequence-empty? next0)
                        (cdr x)
                        (cons next0 (cdr x)))))])
      (make-sequence seqs first rest null?))]))

(def sequence-map (proc seq)
  (unless (procedure? proc)
    (argument-error 'sequence-map "procedure?" proc))
  (unless (sequence? seq)
    (argument-error 'sequence-map "sequence?" seq))
  (make-sequence (cons proc seq)
                 (lambda (s) ((car s) (sequence-first (cdr s))))
                 (lambda (s) (cons (car s) (sequence-rest (cdr s))))
                 (lambda (s) (sequence-empty? (cdr s)))))

(def sequence-andmap (proc seq)
  (unless (procedure? proc)
    (argument-error 'sequence-andmap "procedure?" proc))
  (unless (sequence? seq)
    (argument-error 'sequence-andmap "sequence?" seq))
  (let loop ([seq seq])
    (cond
     [(sequence-empty? seq) #t]
     [(not (proc (sequence-first seq))) #f]
     [else (loop (sequence-rest seq))])))

(def sequence-ormap (proc seq)
  (unless (procedure? proc)
    (argument-error 'sequence-ormap "procedure?" proc))
  (unless (sequence? seq)
    (argument-error 'sequence-ormap "sequence?" seq))
  (let loop ([seq seq])
    (cond
     [(sequence-empty? seq) #f]
     [(proc (sequence-first seq)) #t]
     [else (loop (sequence-rest seq))])))

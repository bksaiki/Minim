;
;   Additional math definitions
;

(%import "pre-base.min")

(%export exact-integer? exact-nonnegative-integer? exact-positive-integer?
         factorial fibonacci sqr sgn
         add1 sub1
         pi phi)

;;;;;;;;;;;;;;;;;;;;;; Constants ;;;;;;;;;;;;;;;;;;;;;;;;;;

(def pi 3.141592653589793238465)
(def phi 1.618033988749894848204)

;;;;;;;;;;;;;;;;;;;;;; Predicates ;;;;;;;;;;;;;;;;;;;;;;;;;;

(def exact-integer? (n)
  (and (number? n) (exact? n) (integer? n)))

(def exact-nonnegative-integer? (n)
  (and (exact-integer? n) (not (negative? n))))

(def exact-positive-integer? (n)
  (and (exact-integer? n) (positive? n)))

;;;;;;;;;;;;;;;;;; Special math functions ;;;;;;;;;;;;;;;;;;;

(def factorial (n)
  (unless (exact-nonnegative-integer? n)
    (argument error 'factorial "non-negative integer" n))
  (let loop ([n n] [acc 1])
    (if (zero? n)
        acc
        (loop (- n 1) (* n acc)))))

(def fibonacci (n)
  (unless (exact-nonnegative-integer? n)
    (argument-error 'fibonacci "non-negative integer" n))
  (let loop ([i 1] [x 1] [y 0])
    (if (> i n)
        x
        (loop (+ i 1) (+ x y) x))))

(def sqr (x)
  (unless (number? x)
    (argument-error 'sqr "number?" x))
  (* x x))

(def sgn (x)
  (unless (number? x)
    (argument-error 'sgn "number?" x))
  (def s
    (cond
     [(negative? x) -1]
     [(positive? x) 1]
     [else          0]))
  (if (exact? x) s (inexact s)))

;;;;;;;;;;;;;;;;;; Functional maps ;;;;;;;;;;;;;;;;;;;

(def add1 (x)
  (if (number? x)
      (+ x 1)
      (argument-error 'add1 "number?" x))
  (+ x 1))

(def sub1 (x)
  (if (number? x)
      (- x 1)
      (argument-error 'sub1 "number?" x)))

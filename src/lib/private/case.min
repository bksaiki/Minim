;
;   'case' syntax
;

(%import "def.min" "let.min" "stx.min" "stx-macro.min" "when-unless.min"
         "../srfi/16.min") ; => case-lambda

(%export (all "../srfi/16.min") case)

(def-syntax case
  (lambda (stx)
    (syntax-case stx (else)
     [(_ v)   ; empty case
      #'(begin v (void))]
     [(_ v [else e es ...])   ; else case
      #'(begin v (begin e es ...))]
     [(_ v [(k ...) e es ...] ...)  ; missing else
      #'(case v [(k ...) e es ...] ... [else (void)])]
     [(_ v [(k ...) e es ...] ... [else x xs ...])  ; general case
      #'(let ([tmp v])
        (case/else tmp [(k ...) e es ...] ... [else x xs ...]))]

     [(_ v cls ...) ; error cases
      (let loop ([clauses (unwrap #'(cls ...))])
        (unless (null? clauses)
          (let ([clause (car clauses)])
            (syntax-case clause ()
             [((_ ...) _ _ ...)
              (loop (cdr clauses))]
             [((_ ...) . _)
              (syntax-case clause ()
               [(_) (syntax-error 'case "missing expression after datum sequence" stx clause)]
               [_ (syntax-error 'case "ill-formed clause" stx clause)])]
             [(_ . _) (syntax-error 'case "not a datum sequence" stx clause)]
             [_ (syntax-error 'case "ill-formed clause" stx clause)]))))]
     [_ (syntax-error 'case "bad syntax" stx)])))


(def-syntax case/else
  (lambda (stx)
    (syntax-case stx (else)
     [(_ v [(k ...) es ...] [else xs ...])
      #'(if (case/test v (k ...))
            (begin es ...)
            (begin xs ...))]
     [(_ v [(k ...) es ...] rest ... [else xs ...])
      #'(if (case/test v (k ...))
            (begin es ...)
            (case/else v rest ... [else xs ...]))]
     [(_ v [else xs ...])
      #'(begin xs ...)])))

(def-syntax case/test
  (lambda (stx)
    (syntax-case stx ()
     [(_ v ())         #'#f]
     [(_ v (k))        #'(equal? v 'k)]
     [(_ v (k ks ...)) #'(if (equal? v 'k) #t (case/test v (ks ...)))])))

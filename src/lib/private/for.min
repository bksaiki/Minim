;
;   'for'
;

(%import "pre-base.min")

(%export for for/list
         in-list in-range in-naturals
         in-vector in-string
         sequence->list)

;;;;;;;;;;;;;;;;;;;;;;; for loop ;;;;;;;;;;;;;;;;;;;;;;;

(def-syntax for
  (lambda (stx)
    (syntax-case stx ()
     [(_ () body ...) #'(void)]
     [(_ ([id seq]))
      (syntax-error 'for "missing body" stx)]
     [(_ ([id seq] ...) body ...)
      #'(let loop ([id seq] ...)
          (if (or (sequence-empty? id) ...)
              (void)
              (begin
                (let ([id (sequence-first id)] ...)
                  body ...)
                (loop (sequence-rest id) ...))))])))

(def-syntax for/list
  (lambda (stx)
    (syntax-case stx ()
     [(_ () body ...) #'(void)]
     [(_ ([id seq]))
      (syntax-error 'for/list "missing body" stx)]
     [(_ ([id seq] ...) body ...)
      #'(let loop ([accum (list)] [id seq] ...)
          (if (or (sequence-empty? id) ...)
              (reverse accum)
              (loop
                (cons
                  (let ([id (sequence-first id)] ...)
                    body ...)
                  accum)
                (sequence-rest id) ...)))])))

;;;;;;;;;;;;;;;;;;;;;;; sequence constructors ;;;;;;;;;;;;;;;;;;;;;;;

(def in-list (lst)
  (unless (list? lst)
    (argument-error 'in-list "list?" lst))
  (sequence lst car cdr null?))

(def in-range
  (case-lambda
   [(l) (in-range 0 l 1)]
   [(f l) (in-range f l 1)]
   [(f l s)
    (unless (number? f)
      (argument-error 'in-range "number?" f))
    (unless (number? l)
      (argument-error 'in-range "number?" l))
    (unless (number? s)
      (argument-error 'in-range "number?" s))
    (sequence f
              (lambda (x) x)
              (lambda (x) (+ x s))
              (lambda (x) (>= x l)))]))

(def in-naturals
  (case-lambda
   [() (in-naturals 0)]
   [(n)
    (unless (or (number? n) (exact? n) (not (negative? n)) (integer? n))
      (argument-error 'in-naturals "number?" n))
    (sequence n
              (lambda (x) x)
              (lambda (x) (+ x 1))
              (lambda (x) #f))]))

(def in-vector (v)
  (unless (vector? v)
    (argument-error 'in-vector "vector?" v))
  (def len (vector-length v))
  (sequence 0
            (lambda (x) (vector-ref v x))
            (lambda (x) (+ x 1))
            (lambda (x) (= x len))))

(def in-string (s)
  (unless (string? s)
    (argument-error 'in-string "string?" s))
  (def len (string-length s))
  (sequence 0
            (lambda (x) (string-ref s x))
            (lambda (x) (+ x 1))
            (lambda (x) (>= x len))))

;;;;;;;;;;;;;;;;;;;;;;; sequence conversions ;;;;;;;;;;;;;;;;;;;;;;;

(def sequence->list (seq)
  (let loop ([accum (list)] [seq seq])
    (if (sequence-empty? seq)
        (reverse accum)
        (loop (cons (sequence-first seq) accum)
              (sequence-rest seq)))))

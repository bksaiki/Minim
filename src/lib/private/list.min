;
;   Additional list constructs
;

(%import "pre-base.min"
         "../srfi/1.min")

;; from ../srfi/1.min
(%export first second third fourth fifth sixth seventh eighth ninth tenth
         make-list
         take drop
         take-right drop-right
         split-at
         last last-pair
         filter filter-not
         partition
         append-map
         count
         find find-tail
         member
         assoc)

;; from here
(%export list*
         list-set list-update
         foldl foldr
         remove*
         remove*
         append*)

(def natural? (n)
  (and (number? n) (exact? n) (integer? n) (not (negative? n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; renamed from srfi/i ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def list* cons*)
(def foldl fold)
(def foldr fold-right)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; not defined in srfi/1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def list-set (lst n v)
  (unless (list? lst)
    (argument-error 'list-set "list?" 0 lst n v))
  (unless (natural? n)
    (argument-error 'list-set "natural?" 1 lst n v))
  (let loop ([lst lst] [i n])
    (if (null? lst)
        (argument-error 'list-set "list of adequate length" 0 lst n v)
        (if (zero? i)
            (cons v (cdr lst))
            (cons (car lst) (loop (cdr lst) (- i 1)))))))

(def list-update (lst n up)
  (unless (list? lst)
    (argument-error 'list-set "list?" 0 lst n v))
  (unless (natural? n)
    (argument-error 'list-set "natural?" 1 lst n v))
  (unless (procedure? up)
    (argument-error 'list-set "procedure?" 2 lst n v))
  (let loop ([lst lst] [i n])
    (if (null? lst)
        (argument-error 'list-set "list of adequate length" 0 lst n v)
        (if (zero? i)
            (cons (up (car lst)) (cdr lst))
            (cons (car lst) (loop (cdr lst) (- i 1)))))))

(def remove (v lst)
  (unless (list? lst)
    (argument-error 'remove "list?" 1 v lst))
  (let loop ([lst lst])
    (if (null? lst)
        '()
        (if (equal? v (car lst))
            (loop (cdr lst))
            (cons (car lst) (loop (cdr lst)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compound operations ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def remove* (vs lst)
  (unless (list? vs)
    (argument-error 'remove* "list?" vs))
  (unless (list? lst)
    (argument-error 'remove* "list?" lst))
  (let loop ([vs vs] [lst lst])
    (if (or (null? vs) (null? lst))
        lst
        (loop (cdr vs) (remove (car vs) lst)))))

;; TODO: check lists
(def append* args
  (for ([arg (in-list args)])
    (unless (list? arg) (argument-error 'append* "lists" arg)))
  (def rev (reverse args))
  (foldl append (apply append (car rev)) (cdr rev)))

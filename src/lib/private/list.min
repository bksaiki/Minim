;
;   Additional list constructs
;

(%import "pre-base.min" "for.min")

(%export remove* list* ormap andmap append* append-map)

(def remove* (vs lst)
  (unless (list? vs)
    (argument-error 'remove* "list?" vs))
  (unless (list? lst)
    (argument-error 'remove* "list?" lst))
  (let loop ([vs vs] [lst lst])
    (if (or (null? vs) (null? lst))
        lst
        (loop (cdr vs) (remove (car vs) lst)))))

(def list* args
  (let ([rev (reverse args)])
    (foldl cons (car rev) (cdr rev))))

(def andmap (proc lst)
  (unless (procedure? proc)
    (argument-error 'andmap "procedure?" proc))
  (unless (list? lst)
    (argument-error 'andmap "list?" lst))
  (let loop ([lst lst])
    (cond
     [(null? lst) #t]
     [(proc (car lst)) (loop (cdr lst))]
     [else #f])))

(def ormap (proc lst)
  (unless (procedure? proc)
    (argument-error 'andmap "procedure?" proc))
  (unless (list? lst)
    (argument-error 'andmap "list?" lst))
  (let loop ([lst lst])
    (cond
     [(null? lst) #f]
     [(proc (car lst)) #t]
     [else (loop (cdr lst))])))

;; TODO: check lists
(def append* args
  (for ([arg (in-list args)])
    (unless (list? arg) (argument-error 'append* "lists" arg)))
  (def rev (reverse args))
  (foldl append (apply append (car rev)) (cdr rev)))

(def append-map (proc . things)
  (unless (procedure? proc)
    (error 'append-map "Expected a procedure"))
  (apply append (apply map proc things)))

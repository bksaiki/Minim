; Wrapped primitives

;; --------------------------------------------------------
;; Low-level exceptions

(define-values (error)
  (lambda (who msg . args)
    ($boot-error who msg args)))

(define-values (errorf)
  (lambda (who fmt . args)
    (apply error who "formatted error" msg args)))

(define-values (raise-argument-error)
  (lambda (who expected v)
    (error who "contract violation" expected v)))

(define-values (raise-arity-error)
  (lambda (who arity cnt)
    (error who "arity mismatch" arity cnt)))

(define-values (raise-range-error)
  (lambda (who v descr lower upper index)
    (error who "index out of bounds" v descr lower upper index)))

(define-values (raise-missing-error)
  (lambda (who descr x k)
    (error who "not found" who descr x k)))

($c-error-handler
  (lambda (who msg args)
    (apply error who msg args)))

;; --------------------------------------------------------
;; Pairs

(define-values (car)
  (lambda (x) 
    (if (pair? x)
        ($car x)
        (raise-argument-error 'car "pair?" x))))

(define-values (cdr)
  (lambda (x) 
    (if (pair? x)
        ($cdr x)
        (raise-argument-error 'cdr "pair?" x))))

(define-values (caar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caar "(pairof pair? any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                ($car t)
                (oops! x)))
          (oops! x)))))

(define-values (cadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cadr "(pairof any pair?)" x))])
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                ($car t)
                (oops! x)))
          (oops! x)))))

(define-values (cdar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdar "(pairof pair? any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                ($cdr t)
                (oops! x)))
          (oops! x)))))

(define-values (cddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cddr "(pairof any pair?)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                ($cdr t)
                (oops! x)))
          (oops! x)))))

(define-values (caaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caaar "(pairof (pairof pair? any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caadr "(pairof any (pairof pair? any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cadar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cadar "(pairof (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caddr "(pairof (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdaar "(pairof (pairof pair? any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdadr "(pairof any (pairof pair? any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cddar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cddar "(pairof (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdddr "(pairof (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caaaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caaaar "(pairof (pairof (pairof pair? any) any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caaadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caaadr "(pairof any (pairof (pairof pair? any) any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caadar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caadar "(pairof (pairof any (pairof pair? any)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caaddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caaddr "(pairof (pairof any (pairof pair? any)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cadaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cadaar "(pairof (pairof (pairof any pair?) any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cadadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cadadr "(pairof any (pairof (pairof any pair?) any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (caddar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'caddar "(pairof (pairof any (pairof any pair?)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cadddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cadddr "(pairof (pairof any (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdaaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdaaar "(pairof (pairof (pairof pair? any) any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdaadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdaadr "(pairof any (pairof (pairof pair? any) any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdadar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdadar "(pairof (pairof any (pairof pair? any)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdaddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdaddr "(pairof (pairof any (pairof pair? any)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cddaar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cddaar "(pairof (pairof (pairof any pair?) any) any)" x))])               
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cddadr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cddadr "(pairof any (pairof (pairof any pair?) any))" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($car t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cdddar)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cdddar "(pairof (pairof any (pairof any pair?)) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($car x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (cddddr)
  (let-values ([(oops!)
                (lambda (x)
                  (raise-argument-error 'cddddr "(pairof (pairof any (pairof any pair?) any)" x))]) 
    (lambda (x)
      (if (pair? x)
          (let-values ([(t) ($cdr x)])
            (if (pair? t)
                (let-values ([(t) ($cdr t)])
                  (if (pair? t)
                      (let-values ([(t) ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define-values (set-car!)
  (lambda (p x)
    (if (pair? p)
        ($set-car! p x)
        (raise-argument-error 'set-car! "pair?" p))))

(define-values (set-cdr!)
  (lambda (p x)
    (if (pair? p)
        ($set-cdr! p x)
        (raise-argument-error 'set-cdr! "pair?" p))))

;; --------------------------------------------------------
;; Numbers

; TODO: update once we have more number types
(define-values (integer?) fixnum?)
(define-values (number?) fixnum?)

(define-values (= > < >= <=)
  (letrec-values ([(non-number-error)
                   (lambda (who v)
                     (raise-argument-error who "number?" v))]
                  [(go)
                   (lambda (cmp who)
                     (case-lambda
                       [(x)
                        (if (number? x)
                            x
                            (non-number-error who x))]
                       [(x y)
                        (if (number? x)
                            (if (number? y)
                                (cmp x y)
                                (non-number-error who y))
                            (non-number-error who x))]
                       [(x . rest)
                        (if (number? x)
                            (letrec-values ([(loop)
                                             (lambda (x xs)
                                               (if (null? xs)
                                                   #t
                                                   (if (number? ($car xs))
                                                       (if (cmp x ($car xs))
                                                           (loop ($car xs) ($cdr xs))
                                                           #f)
                                                       (non-number-error who ($car xs)))))])
                              (loop x rest))
                            (non-number-error who x))]))])
    (values (go $fx2= '=)
            (go $fx2> '>)
            (go $fx2< '<)
            (go $fx2>= '>=)
            (go $fx2<= '<=))))

(define-values (negative-integer?)
  (lambda (x) (if (integer? x) (< x 0) #f)))

(define-values (non-negative-integer?)
  (lambda (x) (if (integer? x) (>= x 0) #f)))

(define-values (positive-integer?)
  (lambda (x) (if (integer? x) (> x 0) #f)))

(define-values (zero?)
  (lambda (x) (= x 0)))

; TODO: change once numbers expanded
(define-values (negative?) negative-integer?)
(define-values (non-negative?) non-negative-integer?)
(define-values (positive?) positive-integer?)

(define-values (+ - * /)
  (let-values ([(non-number-error)
                (lambda (who v)
                  (raise-argument-error who "number?" v))]
               [(divide-0-error)
                (lambda (who v)
                  (error who "division by zero" v))])
    (values
      ; +
      (case-lambda
        [() 0]
        [(x)
         (if (number? x)
             x
             (non-number-error '+ x))]
        [(x y)
         (if (number? x)
             (if (number? y)
                 ($fx2+ x y)
                 (non-number-error '+ y))
             (non-number-error '+ x))]
        [(x y . rest)
         (if (number? x)
             (if (number? y)
                 (letrec-values ([(loop)
                                  (lambda (x xs)
                                     (if (null? xs)
                                         x
                                         (if (number? ($car xs))
                                             (loop ($fx2+ x ($car xs)) ($cdr xs))
                                             (non-number-error '+ ($car xs)))))])
                   (loop ($fx2+ x y) rest))
                 (non-number-error '+ y))
             (non-number-error '+ x))])
      ; -
      (case-lambda
        [(x)
         (if (number? x)
             ($fx2- 0 x)
             (non-number-error '- x))]
        [(x y)
         (if (number? x)
             (if (number? y)
                 ($fx2- x y)
                 (non-number-error '- y))
             (non-number-error '- x))]
        [(x y . rest)
         (if (number? x)
             (if (number? y)
                 (letrec-values ([(loop)
                                  (lambda (x xs)
                                     (if (null? xs)
                                         x
                                         (if (number? ($car xs))
                                             (loop ($fx2- x ($car xs)) ($cdr xs))
                                             (non-number-error '- ($car xs)))))])
                   (loop ($fx2- x y) rest))
                 (non-number-error '- y))
             (non-number-error '- x))])
      ; *
      (case-lambda
        [() 1]
        [(x)
         (if (number? x)
             x
             (non-number-error '* x))]
        [(x y)
         (if (number? x)
             (if (number? y)
                 ($fx2* x y)
                 (non-number-error '* y))
             (non-number-error '* x))]
        [(x y . rest)
         (if (number? x)
             (if (number? y)
                 (letrec-values ([(loop)
                                  (lambda (x xs)
                                     (if (null? xs)
                                         x
                                         (if (number? ($car xs))
                                             (loop ($fx2* x ($car xs)) ($cdr xs))
                                             (non-number-error '* ($car xs)))))])
                   (loop ($fx2* x y) rest))
                 (non-number-error '* x))
             (non-number-error '* y))])
      ; /
      (case-lambda
        [(x)
         (if (number? x)
             (if (zero? x)
                 (division-0-error '/ x)
                 ($fx2/ 1 x))
             (non-number-error '/ x))]
        [(x y)
         (if (number? x)
             (if (number? y)
                 (if (zero? y)
                     (division-0-error '/ y)
                     ($fx2/ x y))
                 (non-number-error '- y))
             (non-number-error '- x))]
        [(x y . rest)
         (if (number? x)
             (if (number? y)
                 (if (zero? y)
                     (division-0-error '/ y)
                     (letrec-values ([(loop)
                                      (lambda (x xs)
                                         (if (null? xs)
                                             x
                                             (if (number? ($car xs))
                                                 (if (zero? ($car xs))
                                                     (division-0-error '/ ($car xs))
                                                     (loop ($fx2- x ($car xs)) ($cdr xs)))
                                                 (non-number-error '- ($car xs)))))])
                       (loop ($fx2- x y) rest)))
                 (non-number-error '- y))
             (non-number-error '- x))]))))

(define-values (add1)
  (lambda (x)
    (if (number? x)
        ($fx2+ x 1)
        (raise-argument-error 'add1 "number?" x))))

(define-values (sub1)
  (lambda (x)
    (if (number? x)
        ($fx2- x 1)
        (raise-argument-error 'sub1 "number?" x))))

(define-values (remainder)
  (lambda (x y)
    (if (number? x)
        (if (number? y)
            ($fxremainder x y)
            (raise-argument-error 'remainder "number?" y))
        (raise-argument-error 'remainder "number?" x))))

(define-values (modulo)
  (lambda (x y)
    (if (number? x)
        (if (number? y)
            ($fxmodulo x y)
            (raise-argument-error 'modulo "number?" y))
        (raise-argument-error 'modulo "number?" x))))

;; --------------------------------------------------------
;; Procedure

(define-values (call-with-values)
  (lambda (producer consumer)
    (call-with-values producer consumer)))

(define-values (procedure-arity?)
  (lambda (x)
    (if (non-negative-integer? x)
        #t
        (if (pair? x)
            (if (non-negative-integer? (car x))
                (letrec-values ([(loop)
                                  (lambda (x p)
                                    (if (null? x)
                                        #t
                                        (if x
                                            (if (pair? x)
                                                (if (non-negative-integer? (car x))
                                                    (if (> (car x) p)
                                                        (loop (cdr x) (car x))
                                                        #f)
                                                    #f)
                                                #f)
                                            #t)))])
                  (loop (cdr x) (car x)))
                #f)
            #f))))

(define-values (procedure-arity)
  (lambda (p)
    (if (procedure? p)
        ($procedure-arity p)
        (raise-argument-error 'procedure-arity "procedure?" p))))

(define-values (procedure-name)
  (lambda (p)
    (if (procedure? p)
        ($procedure-name p)
        (raise-argument-error 'procedure-name "procedure?" p))))

(define-values (procedure-rename)
  (lambda (p id)
    (if (procedure? p)
        (if (symbol? id)
            ($procedure-rename p id)
            (raise-argument-error 'procedure-rename "symbol?" id))
        (raise-argument-error 'procedure-rename "procedure?" p))))

;; --------------------------------------------------------
;; Characters

(define-values (char->integer)
  (lambda (x)
    (if (char? x)
        ($char->integer x)
        (raise-argument-error 'char->integer "char?" x))))

(define-values (integer->char)
  (lambda (x)
    (if (integer? x) ; TODO: bounds on characters
        ($integer->char x)
        (raise-argument-error 'integer->char "integer?" x))))

;; --------------------------------------------------------
;; String

(define-values (string list->string)
  (let-values ([(check-arg!)
                (lambda (who xs)
                  (for-each (lambda (x)
                              (if (char? x)
                                  (void)
                                  (raise-argument-error who "char?" x)))
                            xs))])
    (values
      (lambda args ; string
        (check-arg! 'string args)
        ($list->string args))
      (lambda (xs) ; list->string
        (check-arg! 'list->string xs)
        ($list->string xs)))))

(define-values (make-string)
  (let-values ([(check-args!)
                (lambda (n c)
                  (if (non-negative-integer? n)
                      (if (char? c)
                          (void)
                          (raise-argument-error 'make-string "char?" init))
                      (raise-argument-error 'make-string "non-negative-integer?" len)))])
    (case-lambda
      [(n)
       (check-args! n #\a)
       ($make-string n #\a)]
      [(n fill)
       (check-args! n fill)
       ($make-string n fill)])))

(define-values (string-length)
  (lambda (s)
    (if (string? s)
        ($string-length s)
        (raise-argument-error 'string-length "string?" s))))

(define-values (string-ref)
  (lambda (s idx)
    (if (string? s)
        (if (non-negative-integer? idx)
            (if (>= idx ($string-length s))
                (raise-range-error 'string-ref s "" 0 ($string-length s) idx)
                ($string-ref s idx))
            (raise-argument-error 'string-ref "non-negative-integer?" idx))
        (raise-argument-error 'string-ref "string?" s))))

(define-values (string-set!)
  (lambda (s idx c)
    (if (string? s)
        (if (if (integer? idx) (>= idx 0) #f)
            (if (>= idx ($string-length s))
                (raise-range-error 'string-set! s "" 0 ($string-length s) idx)
                (if (char? c)
                    ($string-set! s idx c)
                    (raise-argument-error 'string-set! "char?" c)))
            (raise-argument-error 'string-set! "non-negative-integer?" idx))
        (raise-argument-error 'string-set! "string?" s))))

(define-values (string-append)
  (let-values ([(check-args!)
                (lambda (xs)
                  (for-each (lambda (x)
                              (if (string? x)
                                  (void)
                                  (raise-argument-error 'string-append "string?" s)))
                            xs))]
               [(sum-lengths)
                (lambda (xs)
                  (letrec-values ([(loop)
                                   (lambda (xs len)
                                     (if (null? xs)
                                         len
                                         (loop ($cdr xs) (+ len ($string-length ($car xs))))))])
                    (loop xs 0)))])
    (case-lambda
      [() ""]
      [(x)
       (check-args! (list x))
       x]
      [(x . xs)
       (let-values ([(xs) (cons x xs)])
         (check-args! xs)
         (letrec-values ([(s) ($make-string (sum-lengths xs) #\0)]
                         [(loop)
                          (lambda (xs i j)
                            (if (null? xs)
                                s
                                (if (>= j ($string-length ($car xs)))
                                    (loop ($cdr xs) i 0)
                                    (begin
                                      (string-set! s i (string-ref ($car xs) j))
                                      (loop xs (add1 i) (add1 j))))))])
           (loop xs 0 0)))])))

(define-values (number->string)
  (lambda (n)
    (if (number? n)
        ($number->string n)
        (raise-argument-error 'number->string "number?" n))))

(define-values (string->number)
  (lambda (s)
    (if (string? s)
        ($string->number s)
        (raise-argument-error 'string->number "string?" s))))

(define-values (symbol->string)
  (lambda (s)
    (if (symbol? s)
        ($symbol->string s)
        (raise-argument-error 'symbol->string "symbol?" s))))

(define-values (string->symbol)
  (lambda (s)
    (if (string? s)
        ($string->symbol s)
        (raise-argument-error 'string->symbol "string?" s))))

(define-values (string->list)
  (lambda (s)
    (if (string? s)
        ($string->list s)
        (raise-argument-error 'string->list "string?" s))))

;; --------------------------------------------------------
;; Lists

(define-values (list) (lambda args args))

(define-values (make-list)
  (lambda (len init)
    (if (if (integer? len) (>= len 0) #f)
        ($make-list len init)
        (raise-argument-error 'length "non-negative-integer?" len))))

(define-values (length)
  (lambda (xs)
    (if (list? xs)
        ($length xs)
        (raise-argument-error 'length "list?" xs))))

(define-values (reverse)
  (lambda (xs)
    (if (list? xs)
        ($reverse xs)
        (raise-argument-error 'reverse "list?" xs))))

(define-values (append)
  (let-values ([(non-list-error)
                (lambda (v)
                  (raise-argument-error 'append "list?" v))])
    (case-lambda
      [() '()]
      [(xs)
       (if (list? xs)
           xs
           (non-list-error xs))]
      [(xs ys)
       (if (list? xs)
           (if (list? ys)
               ($append2 xs ys)
               (non-list-error ys))
           (non-list-error xs))]
      [xss
       (letrec-values ([(loop)
                        (lambda (acc xss)
                          (if (null? xss)
                              acc
                              (if (list? ($car xss))
                                  (loop ($append2 ($car xss) acc) ($cdr xss))
                                  (non-list-error ($car xss)))))])
         (loop '() ($reverse xss)))])))

(define-values (for-each map andmap ormap)
  (letrec-values ([(for-each1) ; optimized `for-each` for one argument
                   (lambda (f xs)
                     (if (null? xs)
                         (void)
                         (begin
                           (f ($car xs))
                           (for-each1 f ($cdr xs)))))]
                  [(map1) ; optimized `map` for one argument
                   (lambda (f xs)
                     (letrec-values ([(loop)
                                      (lambda (xs acc)
                                        (if (null? xs)
                                            (reverse acc)
                                            (loop ($cdr xs) (cons (f ($car xs)) acc))))])
                       (loop xs '())))]
                  [(andmap1) ; optimized `andmap` for one argument
                   (lambda (pred? xs)
                     (if (null? xs)
                         #t
                         (if (pred? ($car xs))
                             (andmap1 pred? ($cdr xs))
                             #f)))]
                  [(ormap1) ; optimized `ormap` for one argument
                   (lambda (pred? xs)
                     (if (null? xs)
                         #f
                         (if (pred? ($car xs))
                             #t
                             (ormap1 pred? ($cdr xs)))))]
                  [(check-args!)
                   (lambda (who f xss)
                     (if (procedure? f)
                         (letrec-values ([(loop)
                                          (lambda (prev-len xss)
                                            (if (null? xss)
                                                (void)
                                                (if (list? ($car xss))
                                                    (let-values ([(len) ($length ($car xss))])
                                                      (if (if prev-len
                                                              (= prev-len len)
                                                              #t)
                                                          (loop len ($cdr xss))
                                                          (errorf who "lists do not have same size; expected ~a, given ~a" prev-len ($car xss))))
                                                    (raise-argument-error who "list?" ($car xss)))))])
                           (loop #f xss))
                         (raise-argument-error who "procedure?" f)))])
    (values
      ;; for-each
      (case-lambda
        [(f xs)
         (check-args! 'for-each f (list xs))
         (for-each1 f xs)]
        [(f xs . xss)
         (check-args! 'for-each f (cons xs xss))
         (letrec-values ([(loop)
                             (lambda (xss)
                                (if (ormap1 null? xss)
                                    (void)
                                    (begin
                                      (apply f (map1 $car xss))
                                      (loop (map1 $cdr xss)))))])
           (loop (cons xs xss)))])
      ;; map
      (case-lambda
        [(f xs)
         (check-args! 'map f (list xs))
         (map1 f xs)]
        [(f xs . xss)
         (check-args! 'map f (cons xs xss))
         (letrec-values ([(loop)
                          (lambda (xss acc)
                             (if (ormap1 null? xss)
                                 (reverse acc)
                                 (loop (map1 $cdr xss)
                                       (cons (apply f (map1 $car xss)) acc))))])
           (loop (cons xs xss) '()))])
      ;; andmap
      (case-lambda
        [(f xs)
         (check-args! 'andmap f (list xs))
         (andmap1 f xs)]
        [(f xs . xss)
         (check-args! 'andmap f (cons xs xss))
         (letrec-values ([(loop)
                          (lambda (xss)
                             (if (ormap1 null? xss)
                                 #t
                                 (if (apply f (map1 $car xss))
                                     (loop (map1 $cdr xss))
                                     #f)))])
           (loop (cons xs xss)))])
      ;; ormap
      (case-lambda
        [(f xs)
         (check-args! 'ormap f (list xs))
         (ormap1 f xs)]
        [(f xs . xss)
         (check-args! 'ormap f (cons xs xss))
         (letrec-values ([(loop)
                          (lambda (xss)
                             (if (ormap1 null? xss)
                                 #f
                                 (if (apply f (map1 $car xss))
                                     #t
                                     (loop (map1 $cdr xss)))))])
           (loop (cons xs xss)))]))))

(define-values (iota)
  (lambda (n)
    (if (non-negative-integer? n)
        (letrec-values ([(loop)
                         (lambda (n xs)
                           (if (> n 0)
                               (loop (- n 2) (cons (- n 1) (cons n xs)))
                               (if (= n 0)
                                   (cons 0 xs)
                                   xs)))])
          (loop (sub1 n) '()))
        (raise-argument-error 'iota "non-negative-fixnum?" n))))

(define-values (enumerate)
  (lambda (xs)
    (if (list? xs)
        (letrec-values ([(loop)
                         (lambda (xs i acc)
                           (if (null? xs)
                               ($reverse acc)
                               (loop ($cdr xs)
                                     (+ i 1)
                                     (cons (cons ($car xs) i) acc))))])
          (loop xs 0 '()))
        (raise-argument-error 'enumerate "list?" xs))))

;; --------------------------------------------------------
;; Vector

(define-values (vector)
  (lambda args ($list->vector args)))

(define-values (make-vector)
  (let-values ([(check-length!)
                (lambda (n)
                  (if (non-negative-integer? n)
                      (void)
                      (raise-argument-error 'make-vector "non-negative-integer?" n)))])
    (case-lambda
      [(n)
       (check-length! n)
       ($make-vector n 0)]
      [(n fill)
       (check-length! n)
       ($make-vector n fill)])))

(define-values (vector-length)
  (lambda (v)
    (if (vector? v)
        ($vector-length v)
        (raise-argument-error 'vector-length "vector?" v))))

(define-values (vector-ref)
  (lambda (v idx)
    (if (vector? v)
        (if (non-negative-integer? idx)
            (if (>= idx ($vector-length v))
                (raise-range-error 'vector-ref "" v 0 ($vector-length v) idx)
                ($vector-ref v idx))
            (raise-argument-error 'vector-ref "non-negative-integer?" idx))
        (raise-argument-error 'vector-ref "vector?" v))))

(define-values (vector-set!)
  (lambda (v idx x)
    (if (vector? v)
        (if (non-negative-integer? idx)
            (if (>= idx ($vector-length v))
                (raise-range-error 'vector-set! "" v 0 ($vector-length v) idx)
                ($vector-set! v idx x))
            (raise-argument-error 'vector-set! "non-negative-integer?" idx))
        (raise-argument-error 'vector-set! "vector?" v))))

(define-values (vector-fill!)
  (lambda (v x)
    (if (vector? v)
        ($vector-fill! v x)
        (raise-argument-error 'vector->list "vector?" v))))

(define-values (list->vector)
  (lambda (xs)
    (if (list? xs)
        ($list->vector xs)
        (raise-argument-error 'list->vector "list?" xs))))

(define-values (vector->list)
  (lambda (v)
    (if (vector? v)
        ($vector->list v)
        (raise-argument-error 'vector->list "vector?" v))))

;; --------------------------------------------------------
;; Boxes

(define-values (unbox)
  (lambda (x)
    (if (box? x)
        ($unbox x)
        (raise-argument-error 'unbox "box?" x))))

(define-values (set-box!)
  (lambda (x v)
    (if (box? x)
        ($set-box! x v)
        (raise-argument-error 'set-box! "box?" x))))

;; --------------------------------------------------------
;; Ports

(define-values (open-input-file)
  (lambda (name)
    (if (string? name)
        ($open-input-file name)
        (raise-argument-error 'open-input-file "string?" name))))

(define-values (open-output-file)
  (lambda (name)
    (if (string? name)
        ($open-output-file name)
        (raise-argument-error 'open-output-file "string?" name))))

(define-values (open-input-string)
  (lambda (str)
    (if (string? str)
        ($open-input-string str)
        (raise-argument-error 'open-input-string "string?" name))))

(define-values (close-input-port)
  (lambda (port)
    (if (input-port? port)
        ($close-input-port port)
        (raise-argument-error 'close-input-file "input-port?" port))))

(define-values (close-output-port)
  (lambda (port)
    (if (output-port? port)
        ($close-output-port port)
        (raise-argument-error 'close-output-file "output-port?" port))))

(define-values (get-output-string)
  (lambda (port)
    (if (if (output-port? port) (string-port? port) #f)
        ($get-output-string port)
        (raise-argument-error 'get-output-string "(and output-port? string-port?)" port))))

;; --------------------------------------------------------
;; Records

(define-values (make-record-type-descriptor)
  (letrec-values ([(field-id)
                   (lambda (field)
                     (if (pair? field)
                         (let-values ([(type) ($car field)]
                                      [(rib) ($cdr field)])
                            (if (if (eq? type 'immutable) #t (eq? type 'mutable))
                                (let-values ([(name) ($car rib)]
                                             [(rib) ($cdr rib)])
                                   (if (symbol? name)
                                       (if (null? rib)
                                           name
                                           #f)
                                       #f))
                                #f))
                         #f))]
                  [(check-args!)
                   (lambda (name parent uid sealed? opaque?)
                     (if (symbol? name)
                         (if (if (record-type-descriptor? parent)
                                 (begin
                                   (if ($record-type-sealed? parent)
                                       (raise-argument-error
                                         'make-record-type-descriptor
                                         "non-sealed record type"
                                         parent)
                                       #t))
                                 (not parent))
                             (if (if (symbol? uid) #t (not uid))
                                 (if (boolean? sealed?)
                                     (if (boolean? opaque?)
                                         (if (vector? fields)
                                            (begin
                                              (check-fields! fields)
                                              ($make-record-type-descriptor
                                                 name
                                                 parent
                                                 uid
                                                 sealed?
                                                 opaque?
                                                 fields))
                                            (raise-argument-error
                                              'make-record-type-descriptor
                                              "vector?"
                                              fields))
                                         (raise-argument-error
                                           'make-record-type-descriptor
                                           "boolean?"
                                           opaque?))
                                     (raise-argument-error
                                       'make-record-type-descriptor
                                       "boolean?"
                                       sealed?))
                                 (raise-argument-error
                                   'make-record-type-descriptor
                                   "symbol? or #f"
                                   uid))
                             (raise-argument-error
                               'make-record-type-descriptor
                               "record-type-descriptor? or #f"
                               parent))
                         (raise-argument-error
                           'make-record-type-descriptor
                           "symbol?"
                           name)))]
                  [(check-fields!)
                   (lambda (fields)
                     (letrec-values ([(ids) '()])
                       (for-each
                         (lambda (i)
                           (let-values ([(maybe-id) (field-id ($vector-ref fields i))])
                             (if maybe-id
                                 (if (ormap (lambda (id) (eq? maybe-id id)) ids)
                                     (raise-argument-error
                                       'make-record-type-descriptor
                                       "duplicate field"
                                       maybe-id)
                                     (set! ids (cons maybe-id ids)))
                                 (raise-argument-error
                                   'make-record-type-descriptor
                                   "invalid field; '(immutable <name>) or '(mutable <name>)"
                                   field))))
                         (iota ($vector-length fields)))))])
    (lambda (name parent uid sealed? opaque? fields)
      (let-values ([(rtd) ($make-record-type-descriptor name parent uid sealed? opaque? fields)])
        (if parent
            (let-values ([(rec-equal?) (record-type-equal-procedure parent)]
                         [(rec-hash) (record-type-hash-procedure parent)]
                         [(rec-writer) (record-writer parent)])
              (if rec-equal?
                  (record-type-equal-procedure rtd rec-equal?)
                  (void))
              (if rec-hash
                  (record-type-hash-procedure rtd rec-hash)
                  (void))
              (if rec-writer
                  (record-writer rec-writer)
                  (void)))
            (void))
        rtd))))
      
(define-values (record-type-name
                record-type-parent
                record-type-uid
                record-type-sealed?
                record-type-opaque?
                record-type-field-names)
  (let-values ([(make-accessor)
                (lambda (name accessor)
                  (lambda (rtd)
                    (if (record-type-descriptor? rtd)
                        (accessor rtd)
                        (raise-argument-error name "record-type-name?" rtd))))])
    (values
      (make-accessor 'record-type-name $record-type-name)
      (make-accessor 'record-type-parent $record-type-parent)
      (make-accessor 'record-type-uid $record-type-uid)
      (make-accessor 'record-type-sealed? $record-type-sealed?)
      (make-accessor 'record-type-opaque? $record-type-opaque?)
      (make-accessor 'record-type-field-names $record-type-field-names))))

(define-values (record-type-field-mutable?)
  (lambda (rtd idx)
    (if (record-type-descriptor? rtd)
        (if (if (integer? idx) (>= idx 0) #f)
            (let-values ([(fields) ($record-type-field-names rtd)])
              (if (< idx ($vector-length fields))
                  ($record-type-field-mutable? rtd idx)
                  (raise-range-error 'record-type-field-mutable rtd "" 0 ($vector-length fields) idx)))
            (raise-argument-error 'record-type-field-mutable? "non-negative integer?" idx))
        (raise-argument-error 'record-type-field-mutable? "record-type-name?" rtd))))

(define-values (record?
                record-rtd
                record-constructor
                record-predicate
                record-accessor
                record-mutator)
  (let-values ([(record-size)
                (lambda (rtd)
                   (letrec-values ([(loop)
                                    (lambda (rtd size)
                                      (let-values ([(size) (+ size ($record-type-length rtd))]
                                                   [(parent) ($record-type-parent rtd)])
                                         (if parent
                                             (loop parent size)
                                             size)))])
                     (loop rtd 0)))]
               [(record-value?)
                (lambda (rtd rec)
                  (letrec-values ([(loop)
                                   (lambda (rec-rtd)
                                     (if (eq? rtd rec-rtd)
                                         #t
                                         (let-values ([(parent) ($record-type-parent rec-rtd)])
                                           (if parent (loop parent) #f))))])
                    (loop ($record-rtd rec))))])
    (values
      (lambda (rec) ; record?
        (if ($record-value? rec)
            (not ($record-type-opaque? ($record-rtd rec)))
            #f))
      (lambda (rec) ; record-rtd
        (if (record? rec)
            ($record-rtd rec)
            (raise-argument-error 'record-rtd "record?" rec)))
      (lambda (rtd) ; record-constructor
        (if (record-type-descriptor? rtd)
            (letrec-values ([(size) (record-size rtd)]
                            [(make)
                             (lambda args
                               (if (= (length args) size)
                                   ($make-record rtd args)
                                   (raise-arity-error make size (length args))))])
              make)
            (raise-argument-error
              'record-constructor
              "record-type-descriptor?"
              rtd)))
      (lambda (rtd) ; record-predicate
        (if (record-type-descriptor? rtd)
            (lambda (rec)
              (if ($record-value? rec)
                  (record-value? rtd rec)
                  #f))
            (raise-argument-error 'record-predicate "record-type-descriptor?" rtd)))
      (lambda (rtd idx) ; record-accessor
        (if (record-type-descriptor? rtd)
            (if (if (integer? idx) (>= idx 0) #f)
                (if (< idx ($record-type-length rtd))
                    (letrec-values ([(rtd?) (record-predicate rtd)]
                                    [(actual-idx)
                                     (if ($record-type-parent rtd)
                                         (+ idx (record-size ($record-type-parent rtd)))
                                         idx)]
                                    [(acc)
                                     (lambda (rec)
                                       (if (rtd? rec)
                                           ($record-ref rec actual-idx)
                                           (raise-argument-error
                                             (procedure-name acc)
                                             (format "~a" (record-type-name rtd))
                                             rec)))])
                      acc)
                    (raise-range-error 'record-accessor rtd "" 0 ($record-type-length rtd) idx))
                (raise-argument-error 'record-accessor "non-negative-integer?" idx))
            (raise-argument-error 'record-accessor "record-type-descriptor?" rtd)))
      (lambda (rtd idx) ; record-mutator
        (if (record-type-descriptor? rtd)
            (if (if (integer? idx) (>= idx 0) #f)
                (if (< idx ($record-type-length rtd))
                    (letrec-values ([(rtd?) (record-predicate rtd)]
                                    [(actual-idx)
                                     (if ($record-type-parent rtd)
                                         (+ idx (record-size ($record-type-parent rtd)))
                                         idx)]
                                    [(mut)
                                     (lambda (rec v)
                                       (if (rtd? rec)
                                           ($record-set! rec actual-idx v)
                                           (raise-argument-error
                                             (procedure-name mut)
                                             (format "~a" (record-type-name rtd))
                                             rec)))])
                      mut)
                    (raise-range-error 'record-mutator rtd "" 0 ($record-type-length rtd) idx))
                (raise-argument-error 'record-mutator "non-negative-integer?" idx))
            (raise-argument-error 'record-mutator "record-type-descriptor?" rtd))))))  

;; --------------------------------------------------------
;; Hashtables

(define-values (make-custom-hashtable
                hashtable?
                $hashtable-store
                $hashtable-store-set!
                hashtable-hash-proc
                hashtable-equiv-proc
                hashtable-copy)

  (letrec-values ([($ht) (make-record-type-descriptor
                           'hashtable #f #f #t #t
                           #((mutable store) (immutable hash) (immutable equiv)))]
                  [($make-ht) (record-constructor $ht)])
    (values
      (lambda (hash equiv?)
        ($make-ht ($make-hashtable 0) hash equiv?))
      (record-predicate $ht)
      (record-accessor $ht 0)
      (record-mutator $ht 0)
      (record-accessor $ht 1)
      (record-accessor $ht 2)
      (lambda (ht)
        (if (hashtable? ht)
            ($make-ht ($hashtable-copy ($hashtable-store ht))
                      (hashtable-hash-proc ht)
                      (hashtable-equiv-proc ht))
            (raise-argument-error 'hashtable-copy "hashtable?" ht))))))

(define-values (make-eq-hashtable make-hashtable)
  (values (lambda () (make-custom-hashtable eq-hash eq?))
          (lambda () (make-custom-hashtable equal-hash equal?))))

(define-values (hashtable-size)
  (lambda (ht)
    (if (hashtable? ht)
        ($hashtable-size ($hashtable-store ht))
        (raise-argument-error 'hashtable-set! "hashtable?" ht))))

(define-values (hashtable-entries hashtable-keys hashtable-vals)
  (let-values ([(check-arg!)
                (lambda (name ht)
                  (if (hashtable? ht)
                      (void)
                      (raise-argument-error name "hashtable?" ht)))])
    (values
      ; hashtable-entries
      (lambda (ht)
        (check-arg! 'hashtable-entries ht)
        (letrec-values ([(store) ($hashtable-store ht)]
                        [(size) ($hashtable-size store)]
                        [(keys) ($make-vector size #f)]
                        [(vals) ($make-vector size #f)]
                        [(loop) (lambda (cells i)
                                  (if (null? cells)
                                      (values keys vals)
                                      (begin
                                        (vector-set! keys i ($caar cells))
                                        (vector-set! vals i ($cdar cells))
                                        (loop ($cdr cells) (add1 i)))))])
          (loop ($hashtable-cells store) 0)))
      ; hashtable-keys
      (lambda (ht)
        (check-arg! 'hashtable-entries ht)
        (letrec-values ([(store) ($hashtable-store ht)]
                        [(size) ($hashtable-size store)]
                        [(keys) ($make-vector size #f)]
                        [(loop) (lambda (cells i)
                                  (if (null? cells)
                                      keys
                                      (begin
                                        (vector-set! keys i ($caar cells))
                                        (loop ($cdr cells) (add1 i)))))])
          (loop ($hashtable-cells store) 0)))
      ; hashtable-vals
      (lambda (ht)
        (check-arg! 'hashtable-entries ht)
        (letrec-values ([(store) ($hashtable-store ht)]
                        [(size) ($hashtable-size store)]
                        [(vals) ($make-vector size #f)]
                        [(loop) (lambda (cells i)
                                  (if (null? cells)
                                      vals
                                      (begin
                                        (vector-set! vals i ($cdar cells))
                                        (loop ($cdr cells) (add1 i)))))])
          (loop ($hashtable-cells store) 0))))))


(define-values (hashtable-contains?
                hashtable-ref
                hashtable-set!
                hashtable-update!
                hashtable-delete!)

  (letrec-values
    ([(min-size) 13]
     [(do-hash)
      (lambda (hash x)
        (let-values ([(h) (hash x)])
          (if (fixnum? h)
              h
              (raise-argument-error 'do-hash "invalid hash function" hash h))))]
     [(incr-size!)
      (lambda (ht store)
        (let-values ([(size) (add1 ($hashtable-size store))]
                     [(n) ($hashtable-length store)])
          ($hashtable-size-set! store size)
          (if (> size n)
              (adjust! ht store size)
              (void))))]
     [(decr-size!)
      (lambda (ht store)
        (let-values ([(size) (sub1 ($hashtable-size store))]
                     [(n) ($hashtable-length store)])
          ($hashtable-size-set! store size)
          (if (if (< size (/ n 4)) (> size min-size) #f)
              (adjust! ht store size)
              (void))))]
     [(adjust!)
      (lambda (ht store n2)
        (letrec-values ([(n1) ($hashtable-size store)]
                        [(store2) ($make-hashtable n2)])
          (for-each
            (lambda (a)
              (let-values ([(h) (do-hash (hashtable-hash-proc ht) (car a))])
                ($hashtable-set! store2 h (cons a ($hashtable-ref store2 h)))))
            ($hashtable-cells store))
         ($hashtable-size-set! store2 n1)
         ($hashtable-store-set! ht store2)))]
    
    [(1/hashtable-cell-ref)
     (lambda (ht h k)
       (letrec-values ([(equiv?) (hashtable-equiv-proc ht)]
                       [(store) ($hashtable-store ht)]
                       [(loop) (lambda (b)
                                 (if (null? b)
                                     #f
                                     (let-values ([(a) (car b)])
                                       (if (equiv? (car a) k)
                                           a
                                           (loop (cdr b))))))])
         (loop ($hashtable-ref store h))))]

    [(1/hashtable-cell-delete!)
     (lambda (ht k)
       (letrec-values ([(equiv?) (hashtable-equiv-proc ht)]
                       [(store) ($hashtable-store ht)]
                       [(h) (do-hash (hashtable-hash-proc ht) k)]
                       [(bucket) ($hashtable-ref store h)]
                       [(loop)
                        (lambda (b p)
                          (if (null? b)
                              (void)
                              (let-values ([(a) (car b)])
                                (if (equiv? (car a) k)
                                    (begin
                                      (if p
                                          (set-cdr! p (cdr b))
                                          ($hashtable-set! store h (cdr b)))
                                      (decr-size! ht store))
                                    (loop (cdr b) b)))))])
         (loop bucket #f)))]

    [(1/hashtable-contains?)
     (lambda (ht k)
       (letrec-values ([(h) (do-hash (hashtable-hash-proc ht) k)]
                       [(cell) (1/hashtable-cell-ref ht h k)])
         (if cell #t #f)))]
                  
    [(1/hashtable-ref)
     (lambda (ht k default)
       (letrec-values ([(h) (do-hash (hashtable-hash-proc ht) k)]
                       [(cell) (1/hashtable-cell-ref ht h k)])
         (if cell
             ($cdr cell)
             (if (procedure? default)
                 (default)
                 default))))]

    [(1/hashtable-cell)
     (lambda (ht k default)
       (letrec-values ([(h) (do-hash (hashtable-hash-proc ht) k)]
                       [(cell) (1/hashtable-cell-ref ht h k)])
         (if cell
             cell
             (let-values ([(store) ($hashtable-store ht)]
                          [(cell) (cons k default)])
               ($hashtable-set! store h (cons cell ($hashtable-ref store h)))
               (incr-size! ht store)
               cell))))]

    [(1/hashtable-set!)
     (lambda (ht k v)
       (let-values ([(cell) (1/hashtable-cell ht k v)])
         (set-cdr! cell v)))]
    
    [(1/hashtable-update!)
     (lambda (ht k updater default)
       (letrec-values ([(h) (do-hash (hashtable-hash-proc ht) k)]
                       [(cell) (1/hashtable-cell-ref ht h k)])
         (if cell
             (set-cdr! cell (updater ($cdr cell)))
             (let-values ([(store) ($hashtable-store ht)]
                          [(cell) (cons k (if (procedure? default)
                                              (updater (default))
                                              (updater default)))])
               ($hashtable-set! store h (cons cell ($hashtable-ref store h)))
               (incr-size! ht store)))))]

    [(no-key!)
     (lambda (who ht k)
        (raise-missing-error who "key" ht k))]
    
    [(non-hashtable-error)
     (lambda (who v)
       (raise-argument-error who "hashtable?" v))])
               
    (values
      ; hashtable-contains?
      (lambda (ht k)
        (if (hashtable? ht)
            (1/hashtable-contains? ht k)
            (non-hashtable-error 'hashtable-set! ht)))
      ; hashtable-ref
      (case-lambda
        [(ht k)
         (if (hashtable? ht)
             (1/hashtable-ref ht k (lambda () (no-key! 'hashtable-ref ht k)))
             (non-hashtable-error 'hashtable-ref ht))]
        [(ht k default)
         (if (hashtable? ht)
             (1/hashtable-ref ht k default)
             (non-hashtable-error 'hashtable-ref ht))])
      ; hashtable-set!
      (lambda (ht k v)
        (if (hashtable? ht)
            (1/hashtable-set! ht k v)
            (non-hashtable-error 'hashtable-set! ht)))
      ; hashtable-update!
      (case-lambda
        [(ht k updater)
         (if (hashtable? ht)
             (if (procedure? updater)
                 (1/hashtable-update! ht k updater
                                      (lambda () (no-key! 'hashtable-update ht k)))
                 (raise-argument-error 'hashtable-update! "procedure?" updater))
             (non-hashtable-error 'hashtable-update! ht))]
        [(ht k updater default)
         (if (hashtable? ht)
             (if (procedure? updater)
                 (1/hashtable-update! ht k updater default)
                 (raise-argument-error 'hashtable-update! "procedure?" updater))
             (non-hashtable-error 'hashtable-update! ht))])
      ; hashtable-delete!
      (lambda (ht k)
        (if (hashtable? ht)
            (1/hashtable-cell-delete! ht k)
            (non-hashtable-error 'hashtable-set! ht))))))

(define-values (hashtable-clear!)
  (lambda (ht)
    (if (hashtable? ht)
        ($hashtable-clear! ($hashtable-store ht))
        (raise-argument-error 'hashtable-clear! "hashtable?" ht))))

;; --------------------------------------------------------
;; Record: equality + hashing + writing

; TODO: thread parameter
(define-values (default-record-equal-procedure)
  (case-lambda
    [() ($default-record-equal-procedure)]
    [(proc)
     (if (procedure? proc)
         ($default-record-equal-procedure proc)
         (raise-argument-error 'default-record-equal-procedure
                               "procedure?"
                               proc))]))

; TODO: thread parameter
(define-values (default-record-hash-procedure)
  (case-lambda
    [() ($default-record-equal-procedure)]
    [(proc)
     (if (procedure? proc)
         ($default-record-hash-procedure proc)
         (raise-argument-error 'default-record-hash-procedure
                               "procedure?"
                               proc))]))

(define-values (record-type-equal-procedure record-type-hash-procedure)
  (letrec-values ([($equal-table) (make-eq-hashtable)]
                  [($hash-table) (make-eq-hashtable)]
                  [(do-table-ref)
                   (lambda (rtd mode)
                     (if (eq? mode 'equal)
                         (hashtable-ref $equal-table rtd #f)
                         (if (eq? mode 'hash)
                             (hashtable-ref $hash-table rtd #f)
                             (errorf 'do-table-ref "unknown mode: ~a" mode))))]
                  [(do-table-set!)
                   (lambda (rtd mode proc)
                     (if (eq? mode 'equal)
                         (hashtable-set! $equal-table rtd proc)
                         (if (eq? mode 'hash)
                             (hashtable-set! $hash-table rtd proc)
                             (errorf 'do-table-ref "unknown mode: ~a" mode))))]
                  [(non-rtd-error)
                   (lambda (who v)
                     (raise-argument-error who "record-type-desriptor?" v_))]
                  [(non-proc-error)
                   (lambda (who v)
                     (raise-argument-error who "procedure?" v))])
    (values
      ; record-type-equal-procedure
      (case-lambda
        [(rtd)
         (if (record-type-descriptor? rtd)
             (do-table-ref rtd 'equal)
             (non-rtd-error 'record-type-equal-procedure rtd))]
        [(rtd proc)
         (if (record-type-descriptor? rtd)
             (if (procedure? proc)
                 (do-table-set! rtd 'equal proc)
                 (non-proc-error 'record-type-equal-procedure proc))
             (non-rtd-error 'record-type-equal-procedure rtd))])
      ; record-hash-equal-procedure
      (case-lambda
        [(rtd)
         (if (record-type-descriptor? rtd)
             (do-table-ref rtd 'hash)
             (non-rtd-error 'record-type-hash-procedure rtd))]
        [(rtd proc)
         (if (record-type-descriptor? rtd)
             (if (procedure? proc)
                 (do-table-set! rtd 'hash proc)
                 (non-proc-error 'record-type-hash-procedure proc))
             (non-rtd-error 'record-type-hash-procedure rtd))]))))

(define-values (record-equal-procedure)
  (lambda (a b)
    (if ($record-value? a)
        (if ($record-value? b)
            (let-values ([(a-rtd) ($record-rtd a)]
                         [(b-rtd) ($record-rtd b)])
              (let-values ([(proc) (record-type-equal-procedure a-rtd)])
                (if proc
                    (if (eq? proc (record-type-equal-procedure b-rtd))
                        proc
                        #f)
                    #f)))
            (raise-argument-error 'record-equal-procedure "record?" b))
        (raise-argument-error 'record-equal-procedure "record?" a))))

(define-values (record-hash-procedure)
  (lambda (a)
    (if ($record-value? a)
        (let-values ([(rtd) ($record-rtd a)])
          (record-type-hash-procedure rtd))
        (raise-argument-error 'record-equal-procedure "record?" a))))

(define-values (record-writer)
  (letrec-values ([($writer-table) (make-eq-hashtable)]
                  [(non-rtd-error)
                   (lambda (who v)
                     (raise-argument-error who "record-type-desriptor?" v_))]
                  [(non-proc-error)
                   (lambda (who v)
                     (raise-argument-error who "procedure?" v))])
    (case-lambda
        [(rtd)
         (if (record-type-descriptor? rtd)
             (hashtable-ref $writer-table rtd #f)
             (non-rtd-error 'record-writer rtd))]
        [(rtd proc)
         (if (record-type-descriptor? rtd)
             (if (procedure? proc)
                 (hashtable-set! $writer-table rtd proc)
                 (non-proc-error 'record-writer proc))
             (non-rtd-error 'record-writer rtd))])))

;; --------------------------------------------------------
;; Equality + Hashing

(define-values (equal?)
  (letrec-values ([(equal-pair?)
                   (lambda (a b)
                     (if (equal? ($car a) ($car b))
                         (equal? ($cdr a) ($cdr b))
                         #f))]
                  [(equal-vector?)
                   (lambda (a b)
                     (if (= ($vector-length a) ($vector-length b))
                         (andmap
                           (lambda (i)
                             (equal? ($vector-ref a i) ($vector-ref b i)))
                           (iota ($vector-length a)))
                         #f))]
                  [(equal-hashtable?)
                   (lambda (a b)
                     (if (eq? (hashtable-hash-proc a) (hashtable-hash-proc b))
                         (if (eq? (hashtable-equiv-proc a) (hashtable-equiv-proc b))
                             (let-values ([(kas vas) (hashtable-entries a)])
                               (andmap
                                 (lambda (i)
                                   (let-values ([(ka) ($vector-ref kas i)]
                                                [(va) ($vector-ref vas i)])
                                     (if (hashtable-contains? b ka)
                                         (equal? va (hashtable-ref b ka))
                                         #f)))
                                 (iota ($vector-length kas))))
                             #f)
                         #f))])
    (lambda (a b)
      (if (eq? a b)
          #t
          (if (if (symbol? a) #f (string? a))
              ($equal? a b)
              (if (pair? a)
                  (if (pair? b)
                      (equal-pair? a b)
                      #f)
                  (if (vector? a)
                      (if (vector? b)
                          (equal-vector? a b)
                          #f)
                      (if (box? a)
                          (if (box? b)
                              (equal? (unbox a) (unbox b))
                              #f)
                          (if (hashtable? a)
                              (if (hashtable? b)
                                  (equal-hashtable? a b)
                                  #f)
                              (if ($record-value? a)
                                  (if ($record-value? b)
                                      (let-values ([(proc) (record-equal-procedure a b)])
                                        (if proc
                                           (proc a b equal?)
                                           (let-values ([(proc) (default-record-equal-procedure)])
                                             (if proc
                                                 (proc a b equal?)
                                                 ($equal? a b)))))
                                      #f)
                                  ($equal? a b)))))))))))

(define-values (equal-hash)
  (letrec-values ([(hash-pair)
                   (lambda (p hc rec)
                     (rec ($cdr p) (rec ($car p) hc)))]
                  [(hash-vector)
                   (lambda (v hc rec)
                     (letrec-values ([(loop)
                                      (lambda (i hc)
                                        (if (>= i ($vector-length v))
                                            hc
                                            (loop (add1 i) (rec ($vector-ref v i) hc))))])
                       (loop 0 hc)))])
    (lambda (x)
      (letrec-values 
        ([(loop)
          (lambda (x hc)
            (if (if (symbol? x) #t (string? x))
                ($equal-hash x)
                (if (pair? x)
                    (hash-pair x hc loop)
                    (if (vector? x)
                        (hash-vector x hc loop)
                        (if (box? x)
                            (loop (unbox x) (+ hc 410225874))
                            (if (hashtable? x)
                                (loop (hashtable->list x) hc)
                                (if ($record-value? x)
                                    (let-values ([(proc) (record-hash-procedure x)])
                                      (if proc
                                          (proc x equal-hash)
                                          (let-values ([(proc) (default-record-hash-procedure)])
                                            (if proc
                                                (proc x equal-hash)
                                                (eq-hash x)))))
                                    (eq-hash x))))))))])
        (loop x 523658599)))))

;; --------------------------------------------------------
;; Reader

(define-values (read read-char peek-char char-ready?)
  (let-values ([(go) 
                (lambda (name proc)
                  (case-lambda
                    [()
                     (proc (current-input-port))]
                    [(p)
                     (if (input-port? p)
                         (proc p)
                         (raise-argument-error name "input-port?" p))]))])
    (values (go 'read $read)
            (go 'read-char $read-char)
            (go 'peek-char $peek-char)
            (go 'char-ready? $char-ready?))))

;; --------------------------------------------------------
;; Writing

(define-values (put-char)
  (lambda (p ch)
    (if (output-port? p)
        (if (char? ch)
            ($put-char p ch)
            (raise-argument-error 'put-char "char?" ch))
        (raise-argument-error 'put-char "output-port?" ch))))

(define-values (put-string)
  (let-values ([(non-output-port-error)
                (lambda (v)
                  (raise-argument-error 'put-string "output-port?" v))]
               [(non-string-error)
                (lambda (v)
                  (raise-argument-error 'put-string "string?" v))]
               [(non-integer-error)
                (lambda (v)
                  (raise-argument-error 'put-string "integer?" v))]
               [(1/put-string)
                (lambda (p s start n)
                  (let-values ([(len) ($string-length s)])
                    (if (<= start len)
                        (if (<= (+ start n) len)
                            ($put-string p s start n)
                            (raise-range-error 'put-string str "end" 0 (+ len 1) (+ start n)))
                        (raise-range-error 'put-string str "start" 0 (+ len 1) start))))])
    (case-lambda
      [(p s)
       (if (output-port? p)
           (if (string? s)
               ($put-string p s 0 ($string-length s))
               (non-string-error s))
           (non-output-port-error p))]
      [(p s start)
       (if (output-port? p)
           (if (string? s)
               (if (non-negative-integer? start)
                   (1/put-string p s start (- ($string-length s) start))
                   (non-integer-error start))
               (non-string-error s))
           (non-output-port-error p))]
      [(p s start n)
       (if (output-port? p)
           (if (string? s)
               (if (non-negative-integer? start)
                   (if (non-negative-integer? n)
                       (1/put-string p s start n)
                       (non-integer-error start))
                   (non-integer-error start))
               (non-string-error s))
           (non-output-port-error p))])))

(define-values (flush-output-port)
  (lambda (port)
    (if (output-port? port)
        ($flush-output-port port)
        (raise-argument-error 'flush-output-port "output-port?" port))))

(define-values (write-char)
  (case-lambda
    [(c)
     (if (char? c)
         ($write-char c (current-output-port))
         (raise-argument-error 'write-char "char?" c))]
    [(c p)
     (if (char? c)
         (if (output-port? p)
             ($write-char c p)
             (raise-argument-error 'write-char "output-port?" p))
         (raise-argument-error 'write-char "char?" c))]))

(define-values (put-datum write display)
  (letrec-values ([(lparen rparen) (values #\( #\))]
                  ; main writer
                  [(wr)
                   (lambda (x d? p)
                     (if (symbol? x) (put-string p (symbol->string x))
                     (if (pair? x) (wrpair x d? p)
                     (if (number? x) (put-string p (number->string x))
                     (if (null? x) (put-string p "()")
                     (if (boolean? x) (put-string p (if x "#t" "#f"))
                     (if (char? x) (if d? (put-char p x) (wrchar x p))
                     (if (string? x) (if d? (put-string p x) (wrstring x p))
                     (if (vector? x) (wrvector x d? p)
                     (if (eof-object? x) (put-string p "#<eof>")
                     (if (void? x) (put-string p "#<void>")
                     (if (input-port? x) (put-string p "#<input port>")
                     (if (output-port? x) (put-string p "#<output port>")
                     (if (procedure? x) (put-string p "#<procedure>")
                     (if (syntax? x) (wrsyntax x d? p)
                     (if (environment? x) (put-string p "#<environment>")
                     (if (record-type-descriptor? x) (wrrtd x d? p)
                     (if ($record-value? x) (wrrecord x d? p)
                     (put-string p "#<garbage>")))))))))))))))))))]
                  ; character writer
                  [(wrchar)
                   (lambda (x p)
                     (put-string p "#\\")
                     (if (eq? x #\alarm) (put-string p "alarm")
                     (if (eq? x #\backspace) (put-string p "backspace")
                     (if (eq? x #\delete) (put-string p "delete")
                     (if (eq? x #\esc) (put-string p "esc")
                     (if (eq? x #\newline) (put-string p "newline")
                     (if (eq? x #\nul) (put-string p "nul")
                     (if (eq? x #\page) (put-string p "page")
                     (if (eq? x #\return) (put-string p "return")
                     (if (eq? x #\space) (put-string p "space")
                     (if (eq? x #\tab) (put-string p "tab")
                     (if (eq? x #\vtab) (put-string p "vtab")
                     (put-char p x)))))))))))))]
                  ; string writer
                  [(wrstring)
                   (lambda (x p)
                     (put-char p #\")
                     (for-each
                       (lambda (i)
                         (let-values ([(c) (string-ref x i)])
                           (if (eq? c #\alarm) (put-string p "\\a")
                           (if (eq? c #\backspace) (put-string p "\\b")
                           (if (eq? c #\newline) (put-string p "\\n")
                           (if (eq? c #\page) (put-string p "\\f")
                           (if (eq? c #\return) (put-string p "\\r")
                           (if (eq? c #\tab) (put-string p "\\t")
                           (if (eq? c #\vtab) (put-string p "\\v")
                           (if (eq? c #\") (put-string p "\\\"")
                           (if (eq? c #\\) (put-string p "\\\\")
                           (put-char p c))))))))))))
                       (iota (string-length x)))
                     (put-char p #\"))]
                  ; pair writer
                  [(wrpair)
                   (lambda (x d? p)
                     (put-char p lparen)
                     (letrec-values ([(loop)
                                      (lambda (x)
                                         (wr (car x) d? p)
                                         (if (pair? (cdr x))
                                             (begin
                                               (put-char p #\space)
                                               (loop (cdr x)))
                                             (if (null? (cdr x))
                                                 (void)
                                                 (begin
                                                   (put-string p " . ")
                                                   (wr (cdr x) d? p)))))])
                       (loop x))
                     (put-char p rparen))]
                  ; vector writer
                  [(wrvector)
                   (lambda (x d? p)
                     (put-char p #\#)
                     (letrec-values ([(n) (vector-length x)]
                                     [(loop)
                                      (lambda (i sep)
                                        (if (>= i n)
                                            (void)
                                            (begin
                                              (put-char p sep)
                                              (wr (vector-ref x i) d? p)
                                              (loop (+ i 1) #\space))))])
                       (loop 0 lparen))
                     (put-char p rparen))]
                  ; record type writer
                  [(wrrtd)
                   (lambda (x d? p)
                     (put-string p "#<record-type:")
                     (wr (record-type-name x) d? p)
                     (put-char p #\>))]
                  ; record value writer
                  [(wrrecord)
                   (lambda (x d? p)
                     (let-values ([(proc) (record-writer ($record-rtd x))])
                       (if proc
                           (proc x p d?) 
                           (begin
                             (put-string p "#<")
                             (wr (record-type-name ($record-rtd x)) d? p)
                             (put-char p #\>)))))]
                  ; syntax writer
                  [(wrsyntax)
                   (lambda (x d? p)
                     (put-string p "#<syntax ")
                     (wr (syntax->datum x) d? p)
                     (put-char p #\>))]
                  ; check and call
                  [(go)
                   (lambda (who x d? p)
                     (if (output-port? p)
                         (wr x d? p)
                         (raise-argument-error who "output-port?" p)))])
    (values
      ; put-datum
      (lambda (p x)
        (go 'put-datum x #f p))
      ; write
      (case-lambda
        [(o) (go 'write o #f (current-output-port))]
        [(o p) (go 'write o #f p)])
      ; display
      (case-lambda
        [(o) (go 'display o #t (current-output-port))]
        [(o p) (go 'display o #t p)]))))

(define-values (newline)
  (case-lambda
    [()
     ($newline (current-output-port))]
    [(p)
     (if (output-port? p)
         ($newline p)
         (raise-argument-error 'newline "output port?" p))]))

;; --------------------------------------------------------
;; Formatter

(define-values (fprintf printf eprintf format)
  (letrec-values ([(fmt-args)
                   (lambda (who fmt)
                     (letrec-values ([(len) (string-length fmt)]
                                     [(loop)
                                      (lambda (n args)
                                        (if (>= n len)
                                            (reverse args)
                                            (let-values ([(c) (string-ref fmt n)])
                                              (if (eq? c #\~)
                                                  (if (>= (+ n 1) len)
                                                      (errorf who "ill-formed format string `~a`" fmt)
                                                      (let-values ([(nc) (string-ref fmt (+ n 1))])
                                                        (if (if (eq? nc #\a) #t (eq? nc #\A))
                                                            (loop (+ n 2) (cons #f args))
                                                            (if (if (eq? nc #\s) #t (eq? nc #\S))
                                                                (loop (+ n 2) (cons #f args))
                                                                (if (eq? nc #\%)
                                                                    (loop (+ n 2) args)
                                                                    (if (eq? nc #\~)
                                                                        (loop (+ n 2) xs)
                                                                        (errorf who "unknown format directive `~a`" nc)))))))
                                                  (loop (+ n 1) args)))))])
                       (loop 0 '())))]                                                
      
                  [(check-format!)
                   (lambda (who fmt args)
                     (let-values ([(fmt-preds) (fmt-args who fmt)])
                       (if (= (length fmt-preds) (length args))
                           (for-each
                             (lambda (fmt-pred arg)
                               (if (if fmt-pred (fmt-pred arg) #t)
                                   (void)
                                   (errorf who "format argument ~a, given unexpected value ~a" fmt-pred arg)))
                             fmt-preds args)
                           (errorf who "format string requires ~a argument, given ~a" (length fmt-preds) (length args)))))]
                                        
                  [(do-format)
                   (lambda (p fmt args)
                     (letrec-values ([(len) (string-length fmt)]
                                     [(loop)
                                      (lambda (n xs)
                                        (if (>= n len)
                                            (void)
                                            (let-values ([(c) (string-ref fmt n)])
                                              (if (eq? c #\~)
                                                  (let-values ([(nc) (string-ref fmt (+ n 1))])
                                                    (if (if (eq? nc #\a) #t (eq? nc #\A))
                                                        (begin
                                                          (display (car xs) p)
                                                          (loop (+ n 2) (cdr xs)))
                                                        (if (if (eq? nc #\s) #t (eq? nc #\S))
                                                            (begin
                                                              (write (car xs) p)
                                                              (loop (+ n 2) (cdr xs)))
                                                            (if (eq? nc #\%)
                                                                (begin
                                                                  (newline p)
                                                                  (loop (+ n 2) xs))
                                                                (begin ; ~~
                                                                  (put-char p #\~)
                                                                  (loop (+ n 2) xs))))))
                                                  (begin
                                                    (put-char p c)
                                                    (loop (+ n 1) xs))))))])
                       (loop 0 args)))])
    (values
      ; fprintf
      (lambda (p fmt . args)
        (if (output-port? p)
            (begin
              (check-format! 'fprintf fmt args)
              (do-format p fmt args))
            (raise-argument-error 'fprintf "output port?" fmt)))
      ; printf
      (lambda (fmt . args)
        (check-format! 'printf fmt args)
        (do-format (current-output-port) fmt args))
      ; eprintf
      (lambda (fmt . args)
        (check-format! 'eprintf fmt args)
        (do-format (current-error-port) fmt args))
      ; format
      (lambda (fmt . args)
        (check-format! 'format fmt args)
        (let-values ([(p) (open-output-string)])
          (do-format p fmt args)
          (get-output-string p))))))
                                        

;; --------------------------------------------------------
;; FASL I/O

(define-values (fasl-read)
  (lambda (port)
    (if (input-port? port)
        ($fasl-read port)
        (raise-argument-error 'fasl-read "input-port?" port))))

(define-values (fasl-write)
  (lambda (x port)
    (if (output-port? port)
        ($fasl-write x port)
        (raise-argument-error 'fasl-write "output-port?" port))))

;; --------------------------------------------------------
;; Syntax

(define-values (syntax-e)
  (lambda (stx)
    (if (syntax? stx)
        ($syntax-e stx)
        (raise-argument-error 'syntax-e "syntax?" stx))))

(define-values (syntax-loc)
  (lambda (stx)
    (if (syntax? stx)
        ($syntax-loc stx)
        (raise-argument-error 'syntax-loc "syntax?" stx))))

(define-values (syntax->datum)
  (lambda (stx)
    (if (syntax? stx)
        ($syntax->datum stx)
        (raise-argument-error 'syntax->datum "syntax?" stx))))

(define-values (syntax->list)
  (lambda (stx)
    (if (syntax? stx)
        ($syntax->list stx)
        (raise-argument-error 'syntax->list "syntax?" stx))))

;; --------------------------------------------------------
;; Pattern variables

(define-values (make-pattern-variable
                pattern-variable?
                pattern-variable-value
                pattern-variable-depth)
  (let-values ([($pvar) (make-record-type-descriptor 'pattern-variable
                                                     #f
                                                     #f
                                                     #t
                                                     #t
                                                     #((immutable value) (immutable depth)))])
    (values
      (let-values ([($make-pvar) (record-constructor $pvar)])
        (lambda (x depth)
          (if (if (integer? depth) (>= depth 0) #f)
              ($make-pvar x depth)
              (raise-argument-error 'make-pattern-variable "non-negative-integer?" depth))))
      (record-predicate $pvar)
      (record-accessor $pvar 0)
      (record-accessor $pvar 1))))

;; --------------------------------------------------------
;; Environment

(define-values (environment)
  (lambda () (make-base-environment)))

(define-values (copy-environment)
  (letrec-values ([(1/copy-environment)
                   (lambda (env mutable? syms)
                     (if (environment? env)
                         (if (boolean? mutable?)
                             (if (andmap symbol? syms)
                                 ($copy-environment env mutable? syms)
                                 (raise-argument-error 'copy-environment "list of symbols" syms))
                             (raise-argument-error 'copy-environment "boolean?" mutable?))
                         (raise-argument-error 'copy-environment "environment?" env)))])
    (case-lambda
      [(env) (1/copy-environment env #t (environment-names env))]
      [(env mutable?) (1/copy-environment env mutable? (environment-names env))]
      [(env mutable? syms) (1/copy-environment env mutable? syms)])))

(define-values (environment-extend)
  (lambda (env)
    (copy-environment env #f)))

(define-values (environment-names)
  (lambda (env)
    (if (environment? env)
        ($environment-names env)
        (raise-argument-error 'environment-names "environment?" env))))

(define-values (environment-ref)
  (letrec-values ([(default-fail)
                   (lambda (env k)
                     (raise-missing-error 'environment-ref "key" env k))]
                  [(1/environment-ref)
                   (lambda (env k fail)
                     (if (environment? env)
                         (if (symbol? k)
                             (let-values ([(v) ($environment-ref env k fail)])
                               (if (eq? v fail)
                                   (if (procedure? fail)
                                       (fail)
                                       fail)
                                   v))
                             (raise-arugment-error 'environment-ref "symbol?" k))
                         (raise-arugment-error 'environment-ref "environment?" env)))])        
    (case-lambda
      [(env k)
       (1/environment-ref env k default-fail)]
      [(env k fail)
       (1/environment-ref env k fail)])))

(define-values (environment-set!)
  (lambda (env k v)
    (if (environment? env)
        (if (symbol? k)
            ($environment-set! env k v)
            (raise-argument-error 'environment-set! "symbol?" k))
        (raise-argument-error 'environment-set! "environment?" env))))

;; --------------------------------------------------------
;; System

(define-values (load)
  (lambda (fname)
    (if (string? fname)
        ($load fname)
        (raise-argument-error 'load "string?" fname))))

(define-values (exit)
  (case-lambda
    [() ($exit 0)]
    [(v)
     (if (if (integer? v) (<= 0 v 255) #f)
         ($exit v)
         (raise-argument-error 'exit "an integer between 0 and 255" v))]))

; TODO: thread parameter
(define-values (current-directory)
  (case-lambda
    [()
     ($current-directory)]
    [(path)
     (if (string? path)
         ($current-directory-set! path)
         (raise-argument-error 'current-directory "string?" path))]))

;; --------------------------------------------------------
;; Exceptions

; TODO: thread parameter
(define-values (current-error-handler)
  (case-lambda
    [()
     ($current-error-handler)]
    [(proc)
     (if (procedure? proc)
         ($current-error-handler-set! proc)
         (raise-argument-error 'current-error-handler "procedure?" proc))]))

; base exception
(define-values (&exn make-exn exn? exn-who exn-message)
  (let-values ([(&exn) (make-record-type-descriptor '&exn #f #f #t #t #(who message))])
    (values &exn
            (record-constructor &exn)
            (record-predicate &exn)
            (record-accessor &exn 0)
            (record-accessor &exn 1))))

; argument exception
(define-values (&argument make-argument-exn argument-exn? argument-exn-expect argument-exn-actual)
  (let-values ([(&argument) (make-record-type-descriptor '&argument-exn &exn #f #t #t #(expect actual))])
    (values &argument
            (record-constructor &argument)
            (record-predicate &argument)
            (record-accessor &argument 0)
            (record-accessor &argument 1))))

; arity exception
(define-values (&arity make-arity-exn arity-exn? arity-exn-expect arity-exn-actual)
  (let-values ([(&arity) (make-record-type-descriptor '&arity-exn &exn #f #t #t #(expect actual))])
    (values &arity
            (record-constructor &arity)
            (record-predicate &arity)
            (record-accessor &arity 0)
            (record-accessor &arity 1))))

; range exception
(define-values (&range make-range-exn range-exn? range-exn-value range-exn-description range-exn-lower range-exn-upper range-exn-index)
  (let-values ([(&range) (make-record-type-descriptor '&range-exn &exn #f #t #t #(value description lower upper index))])
    (values &range
            (record-constructor &range)
            (record-predicate &range)
            (record-accessor &range 0)
            (record-accessor &range 1)
            (record-accessor &range 2)
            (record-accessor &range 3)
            (record-accessor &range 4))))

; missing exception
(define-values (&missing make-missing-exn missing-exn? missing-exn-description missing-exn-value missing-exn-key)
  (let-values ([(&missing) (make-record-type-descriptor '&missing-exn &exn #f #t #t #(description value key))])
    (values &missing
            (record-constructor &missing)
            (record-predicate &missing)
            (record-accessor &missing 0)
            (record-accessor &missing 1)
            (record-accessor &missing 2))))

; syntax exception
(define-values (&syntax make-syntax-exn syntax-exn? syntax-exn-form syntax-exn-subform)
  (let-values ([(&syntax) (make-record-type-descriptor '&syntax-exn &exn #f #t #t #(form subform))])
    (values &syntax
            (record-constructor &syntax)
            (record-predicate &syntax)
            (record-accessor &syntax 0)
            (record-accessor &syntax 1))))

; default error handler
(define-values (default-error-handler)
  (let-values ([(display-exn)
                (lambda (exn)
                  (if (exn-who exn)
                      (eprintf "~a: ~a\n" (exn-who exn) (exn-message exn))
                      (eprintf "error: ~a\n" (exn-message exn))))]
               [(display-arity)
                (lambda (x)
                  (if (number? x)
                      (eprintf "~a\n" x)
                      (letrec-values ([(loop)
                                       (lambda (x)
                                         (if (null? x)
                                             (eprintf "\n")
                                             (if (cdr x)
                                                 (begin
                                                   (eprintf ", ~a" (car x))
                                                   (loop (cdr x)))
                                                 (eprintf ", at least ~a\n" (car x)))))])
                        (if (cdr x)
                            (begin
                              (eprintf "~a" (car x))
                              (loop (cdr x)))
                            (eprintf "at least ~a\n" (car x))))))])
    (lambda (exn)
      (if (argument-exn? exn)
          (begin ; argument exception
            (display-exn exn)
            (eprintf "  expected: ~a\n" (argument-exn-expect exn))
            (eprintf "  given: ~a\n" (argument-exn-actual exn)))
          (if (arity-exn? exn)
              (begin ; arity exception
                (display-exn exn)
                (eprintf "  expected: ")
                (display-arity (arity-exn-expect exn))
                (eprintf "  given: ~a\n" (arity-exn-actual exn)))
              (if (range-exn? exn)
                  (begin ; range exception
                    (display-exn exn)
                    (eprintf "  range: [~a, ~a)\n"
                             (range-exn-lower exn)
                             (range-exn-upper exn))
                    (if (= (string-length (range-exn-description exn)) 0)
                        (eprintf "  index: ~a\n" (range-exn-index exn))
                        (eprintf "  ~a index: ~a\n"
                                 (range-exn-description exn)
                                 (range-exn-index exn)))
                    (eprintf "  in: ~a\n" (range-exn-value exn)))
                  (if (missing-exn? exn)
                      (begin ; missing exception
                        (display-exn exn)
                        (eprintf "  ~a: ~a\n" (missing-exn-description exn) (missing-exn-key exn))
                        (eprintf "  in: ~a\n" (missing-exn-value exn)))
                      (if (syntax-exn? exn)
                          (begin ; syntax exception
                            (display-exn exn)
                            (if (syntax-exn-form exn)
                                (eprintf "  in: ~a\n" (syntax-exn-form exn))
                                (void))
                            (if (syntax-exn-subform exn)
                                (eprintf "  at: ~a\n" (syntax-exn-subform exn))
                                (void)))
                          (if (exn? exn) ; base exception
                              (display-exn exn)
                              (eprintf "uncaught exception: ~a\n" exn)))))))
      (exit 1))))

(current-error-handler default-error-handler)

(set! error
  (lambda (who msg . args)
    (if (if who (if (symbol? who) #t (string? who)) #t)
        (if (string? msg)
            (raise
              (if (null? args)
                  (make-exn who msg)
                  (let-values ([(p) (open-output-string)])
                    (fprintf p "~a\n" msg)
                    (if (null? (cdr args))
                        (fprintf p "  argument: ~s" (car args))
                        (begin
                          (fprintf p "  arguments...:")
                          (for-each (lambda (x) (fprintf p "\n   ~s" x)) args)))
                    (make-exn who (get-output-string p)))))
            (raise-argument-error 'error "string?" msg))
        (raise-argument-error 'error "symbol? or string? or #f" who))))

(set! errorf
  (lambda (who fmt . args)
    (if (if who (symbol? who) #t)
        (if (string? fmt)
            (error who (apply format fmt args))
            (raise-argument-error 'errorf "string?" fmt))
        (raise-argument-error 'errorf "symbol? or #f" who))))

(set! raise-arity-error
  (lambda (who arity cnt)
    (if (if who (symbol? who) #t)
        (if (procedure-arity? arity)
            (raise (make-arity-exn who "arity mismatch" arity cnt))
            (raise-argument-error 'raise-arity-error "procedure-arity?" arity))
        (raise-argument-error 'raise-arity-error "symbol? or #f" who))))

(set! raise-argument-error
  (lambda (who expected v)
    (if (if who (symbol? who) #t)
        (if (string? expected)
            (raise (make-argument-exn who "contract violation" expected v))
            (raise-argument-error 'raise-argument-error "string?" expected))
        (raise-argument-error 'raise-argument-error "symbol? or #f" who))))

(set! raise-range-error
  (lambda (who v descr lower upper index)
    (if (if who (symbol? who) #t)
        (if (string? descr)
            (if (integer? lower)
                (if (integer? upper)
                    (if (integer? index)
                        (let-values ([(msg) (if (= (string-length descr) 0)
                                                "index out of bounds"
                                                (format "~a index out of bounds" descr))])
                          (raise (make-range-exn who msg v descr lower upper index)))
                        (raise-argument-error 'raise-range-error "integer?" index))
                    (raise-argument-error 'raise-range-error "integer?" upper))
                (raise-argument-error 'raise-range-error "integer?" lower))
            (raise-argument-error 'raise-range-error "string?" descr))
    (raise-argument-error 'raise-range-error "symbol? or #f" who))))

(set! raise-missing-error
  (lambda (who descr x k)
    (if (if who (symbol? who) #t)
        (if (string? descr)
            (raise (make-missing-exn who (format "~a not found" descr) descr x k))
            (raise-argument-error 'raise-argument-error "string?" descr))
        (raise-argument-error 'raise-argument-error "symbol? or #f" who))))

(define-values (raise-syntax-error)
  (let-values ([($raise-syntax-error)
                (lambda (who msg stx sub-stx)
                  (if (if who (symbol? who) #t)
                      (if (string? msg)
                          (if (if stx (syntax? stx) #t)
                              (if (if sub-stx (syntax? sub-stx) #t)
                                  (raise
                                    (make-syntax-exn
                                      who
                                      msg
                                      (if (syntax? stx) ($syntax->datum stx) #f)
                                      (if (syntax? sub-stx) ($syntax->datum sub-stx) #f)))
                                  (raise-argument-error 'syntax-error "syntax or #f" sub-stx))
                              (raise-argument-error 'syntax-error "syntax or #f" stx))
                          (raise-argument-error 'syntax-error "string" msg))
                      (raise-argument-error 'syntax-error "symbol? or #f" who)))])
    (case-lambda
      [(who msg) ($raise-syntax-error who msg #f #f)]
      [(who msg stx) ($raise-syntax-error who msg stx #f)]
      [(who msg stx sub-stx) ($raise-syntax-error who msg stx sub-stx)])))

;;;
;;;  Compiler entry point
;;;   

(import "base.min"
        "module.min"
        "compiler/assemble.min"
        "compiler/common.min"
        "compiler/flatten.min"
        "compiler/report.min"
        "compiler/x86-64.min")

(define (make-module-body-closure instrs)
  (list 'fun  
        (list 'args (list))
        (list 'instrs instrs)))

;
; Compiler
;

(define (compile/file path)
  (define top-levels '())
  (define procedures '())
  (define literals '())
  (define label-counter 0)

  (define (register-top-level! name)
    (define count (length top-levels))
    (set! top-levels (cons name top-levels))
    count)

  (define (register-procedure! pcode)
    ;; offset for the module body
    (define count (+ (length procedures) 1))
    (set! procedures (cons pcode procedures))
    count)

  (define (register-literals! lit)
    (let loop ([lits (reverse literals)] [i 0])
      (cond
        [(eq? lits '())
         (define count (length literals))
         (set! literals (cons lit literals))
         count]
        [(equal? (car lits) lit)
         i]
        [else
         (loop (cdr lits) (+ i 1 ))])))

  (define (register-label!)
    (define count label-counter)
    (set! label-counter (+ count 1))
    (string-append "L" (number->string count)))

  (define-values (exprs xforms imports exports _ _) (read/module path))
  (define module-body
    (let loop ([exprs exprs])
      (cond
        [(null? exprs) '()]
        [else
         (append
           (flatten/top-level (car exprs)
                              register-top-level!
                              register-procedure!
                              register-literals!
                              register-label!)
           (loop (cdr exprs)))])))
  
  ; module body is a nullary function
  ; lead with a `make-void` in case the body is empty
  (define module-body-fn
    (make-module-body-closure
      (cons (list 'make-void) module-body)))

  ; lists are in reverse order
  (set! top-levels (reverse top-levels))
  (set! procedures (cons module-body-fn (reverse procedures)))
  (set! literals (reverse literals))

  ; debug print report
  ; (printf " top-levels: ~a\n" top-levels)
  ; (printf " procedures: ~a\n" procedures)
  ; (printf " literals: ~a\n" literals)
  ; (printf " body: ~a\n" module-body)

  ; assemble procedures
  (define assembly-info
    (map
      (lambda (p)
        (define-values (as link) (assemble/procedure p register-label!))
        ; (printf "~a\n" as)
        (cons as link))
      procedures))

  (define procedures (map car assembly-info))
  (define links (map cdr assembly-info))

  ; report
  (make-compiled-report path (version)
                        'x86-64 'linux-unknown
                        literals procedures links))


(define (run-compiled-module! report)
  ; unpack report
  (define literals (compiled-report-literals report))
  (define procedures (compiled-report-procedures report))
  (define links (compiled-report-links report))

  ; install literals
  (define literal-address (install-literal-bundle! literals))

  ; install template to get initial address
  (define unlinked-code (map (lambda (ss) (apply append ss)) procedures))
  (define template-address (install-procedure-bundle! unlinked-code))

  ; link
  (define link-info
    (cons
      (cons 'literal literal-address)
      (let loop ([code unlinked-code] [i 0] [offset 0])
        (cond [(null? code) '()]
              [else (cons (cons (list 'procedure i) (+ template-address offset))
                          (loop (cdr code) (+ i 1) (+ offset (length (car code)))))]))))

  (define linked (map (lambda (p l) (link/x86-64 p l link-info)) procedures links))
  (define code (map (lambda (ss) (apply append ss)) linked))

  ; reinstall
  (reinstall-procedure-bundle! template-address code)

  ; enter
  (call-with-values
    (lambda () (enter-compiled! template-address))
    (lambda result
      (let loop ([result result])
        (unless (null? result)
          (write (car result)) (newline)
          (loop (cdr result))))))

  (void))

; report writer
(define (write-report report where fasl?)
  (define save-file (open-output-file where))
  (cond
    [fasl?
     (write-fasl (compiled-report->list report) save-file)]
    [else
     (write (compiled-report->list report) save-file)])
  (close-output-port save-file))

; entry point
(define (main args)
  ; flags
  (define enter? #f)
  (define save #f)
  (define fasl? #f)
  ; flag handling
  (define fnames
    (let loop ([args (cdr args)])
      (cond
        [(null? args) '()]
        [(equal? (car args) "-e")
         (set! enter? #t)
         (loop (cdr args))]
        [(equal? (car args) "-f")
         (set! fasl? #t)
         (loop (cdr args))]
        [(equal? (car args) "-s")
         (when (null? (cdr args))
           (error 'main "missing argument after flag '-s'"))
         (set! save (cadr args))
         (loop (cddr args))]
        [(equal? (car args) "--") (cdr args)]
        [else args])))

  (define (->absolute-path path)
    (if (is-absolute-path? path)
        path
        (build-path (current-directory) path)))

  (let loop ([fnames fnames])
    (unless (null? fnames)
      (define name (car fnames))
      (define path (->absolute-path name))
      (printf "<compiling ~a>\n" name)
      (define report (compile/file path))
      (when enter? (run-compiled-module! report))
      (when save (write-report report (->absolute-path save) fasl?))
      (loop (cdr fnames)))))

(main (command-line))

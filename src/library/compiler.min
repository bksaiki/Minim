;;;
;;;  Compiler entry point
;;;   

(import "base.min" "module.min")

; syntax
(define (stx-pair? stx)
  (if (pair? stx)
      #t
      (if (syntax? stx)
          (pair? (syntax-e stx))
          #f)))

(define (stx-null? stx)
  (if (null? stx)
      #t
      (if (syntax? stx)
          (null? (syntax-e stx))
          #f)))

(define (stx-car stx)
  (if (syntax? stx)
      (car (syntax-e stx))
      (car stx)))

(define (stx-cdr stx)
  (if (syntax? stx)
      (cdr (syntax-e stx))
      (cdr stx)))

(define (identifier? stx)
  (and (syntax? stx) (symbol? (syntax-e stx))))

(define ((_-form? form-name) expr)
    (and (stx-pair? expr)
         (let ([head (stx-car expr)])
           (and (identifier? head)
                (eq? (syntax-e head) form-name)))))

(define define-values-form? (_-form? 'define-values))
(define define-syntaxes-form? (_-form? 'define-syntaxes))
(define let-values-form? (_-form? 'let-values))
(define letrec-values-form? (_-form? 'letrec-values))
(define let-syntaxes-form? (_-form? 'let-syntaxes))
(define quote-form? (_-form? 'quote))
(define quote-syntax-form? (_-form? 'quote-syntax))
(define lambda-form? (_-form? 'lambda))
(define begin-form? (_-form? 'begin))
(define if-form? (_-form? 'if))

; syntax would parse into a self-evaluating expression
(define (stx-self-evaluating? stx)
  (let ([datum (syntax-e stx)])
    (or (boolean? datum)
        (number? datum)
        (string? datum)
        (vector? datum)
        (char? datum))))

; Stack segment:
;  - pointer to previous stack segment (0 if base)
;  - size of segment
;  - continuation frames
;  (way to detect overflow)
;  (way to detect underflow)
;  

; Continuation frame:
; (stored in a stack segment) 
; - pointer to previous frame (0 if base)
; - previous instruction register
; - arguments
;

; Registers
(define cc-reg      'RCC)
(define env-reg     'RENV)
(define i-reg       'RIP)
(define data-reg    'RDATA)
(define sp-reg      'RSP)
(define ss-reg      'RSS)
(define res-reg     'RRET)
(define t0-reg      'R0)
(define t1-reg      'R1)

; offsets
(define word-size                 8)
(define stack-segment-size        1024)
(define cont-frame-args-offset    word-size)

(define closure-arity-offset      word-size)
(define closure-env-offset        (* 2 word-size))
(define closure-code-offset       (* 3 word-size))

;
; Assembler
;

(define (assemble/procedure proc make-label!)
  (display " <assembling: ") (write proc) (display ">") (newline)
  (define args (second (second proc)))
  (define arg-instrs
    (if (null? args)
        '()
        (error 'assemble/procedure "unimplemented" args)))

  (define instrs (second (third proc)))
  (define instrs*
    (let loop ([instrs instrs])
      (cond
        [(null? instrs) (list (list 'return))]
        [(not (list? (car instrs))) (error 'assemble/procedure "expected a list: " (car instrs))]
        [else
         (define instr (first instrs))
         (define seq
           (cond
            [(eq? (first instr) 'literal)
             ; `(literal <n>)` =>
             ; Load <n>th literal into `RRES`
             (list (list 'load res-reg data-reg (second instr)))]
            [(eq? (first instr) 'save-continuation)
             ; `(save-continuation <label>)` =>
             ; TODO
             '()]
            [(eq? (first instr) 'push)
             ; `(push)` =>
             ; load `RRES` at `RSP`
             ; decrement `RSP` by word
             (list
               (list 'sub sp-reg sp-reg word-size)
               (list 'store res-reg sp-reg (- word-size)))]
            [(eq? (first instr) 'apply)
             (define jmp-label (make-label!))
             (define exit-label (make-label!))
             ; `(apply)` =>
             ; if PRIMITIVE:
             ;   Set arg array pointer to `arg1`
             ;   Set arg count to `arg0`
             ;   Extract pointer to `RRES`
             ;   Call using `RRES`
             ; elif CLOSURE:
             ;   (Save the continuation??)
             ;   Save the environment register
             ;   Load the closure environment
             ;   Jump to the start of the code
             (list
               (list 'branch 'closure res-reg jmp-label)
               ;; PRIMITIVE
               (list 'sub t0-reg cc-reg cont-frame-args-offset)
               (list 'sub t1-reg t0-reg sp-reg)
               (list 'c-call res-reg t0-reg t1-reg)
               (list 'branch 'always exit-label)
               ;; CLOSURE
               (list 'label jmp-label)
               (list 'sub sp-reg sp-reg word-size)
               (list 'store env-reg sp-reg (- word-size))
               (list 'load env-reg res-reg closure-env-offset)
               (list 'load res-reg res-reg closure-code-offset)
               (list 'call)
               (list 'load env-reg sp-reg (- word-size))
               (list 'add sp-reg sp-reg word-size)
               (list 'label exit-label))]
            [(eq? (first instr) 'lookup)
             ; `(lookup <name>)`
             ; Load <n>th literal into `ARG1` and perform a lookup
             (list
               (list 'load t0-reg data-reg (second instr))
               (list 'c-call "env_lookup_var" env-reg t0-reg))]
            [(eq? (first instr) 'label)
             ; `(label <label>)` =>
             ; nothing to do
             (list instr)]))
         (append seq (loop (cdr instrs)))])))
  
  (append arg-instrs instrs*))

;
; Flatten
;

(define (make-flat-closure formals instrs)
  (cond
    [(null? formals)
     (list 'fun
       (list 'args '())
       (list 'instrs instrs))]
    [else
     (error 'make-flat-closure "unimplemented" formals instrs)]))

(define (flatten/expr expr procedure! literal! label!)
  (let rec ([expr expr])
    (cond
      [(lambda-form? expr)
       (define formals (stx-car (stx-cdr expr)))
       (define body (stx-cdr (stx-cdr expr)))
       (define instrs
         (let loop ([body body])
           (cond
             [(null? body) '()]
             [else (append (rec (car body)) (loop (cdr body)))])))
       (define pcode (make-flat-closure (syntax->datum formals) instrs))
       (define idx (procedure! pcode))
       (list (list 'closure idx))]
      [(stx-list? expr)
       (define op (stx-car expr))
       (define args (stx-cdr expr))
       (define label (label!))
       (cons
         (list 'save-continuation label)
         (let loop ([args args])
           (cond
             [(null? args)
              ; apply operation
              (append
                (rec op)
                (list
                  (list 'apply)
                  (list 'label label)))]
              [else
               ; process next argument
               (append
                 (rec (car args))
                 (cons
                   (list 'push)
                   (loop (cdr args))))])))]
      [(stx-self-evaluating? expr)
       (define idx (literal! (syntax-e expr)))
       (list (list 'literal idx))]
      [(identifier? expr)
       (define idx (literal! (syntax-e expr)))
       (list (list 'lookup idx))]
      [else
       (error 'flatten/expr "unimplemented" expr)])))

(define (flatten/top-level expr top-level! procedure! literal! label!)
  (display " <top-level: ") (write expr) (display ">") (newline)
  (cond
    [(define-values-form? expr)
     ; decompose
     (define names (stx-car (stx-cdr expr)))
     (define e (stx-car (stx-cdr (stx-cdr expr))))
     ; process identifiers
     (define ids (map syntax-e (syntax-e names)))
     (define idxs (map top-level! ids))
     ; process expression
     (flatten/expr e procedure! literal! label!)
     (cons
       (list 'bind-check (length ids))
       (map (lambda (i) (list 'bind i)) ids))]
    [else (flatten/expr expr)]))

(define (compile/file path)
  (define top-levels '())
  (define procedures '())
  (define literals '())
  (define label-counter 0)

  (define (register-top-level! name)
    (define count (length top-levels))
    (set! top-levels (cons name top-levels))
    count)

  (define (register-procedure! pcode)
    (define count (length procedures))
    (set! procedures (cons pcode procedures))
    count)

  (define (register-literals! lit)
    (define count (length literals))
    (let loop ([lits literals] [i count])
      (cond
        [(= i 0)
         (set! literals (cons lit literals))
         count]
        [(equal? (car lits) lit)
         (- count 1)]
        [else
         (loop (cdr lits) (- i 1))])))

  (define (register-label!)
    (define count label-counter)
    (set! label-counter (+ count 1))
    (string-append "L" (number->string count)))

  (define-values (exprs xforms imports exports _) (read/module path))
  (define module-body
    (let loop ([exprs exprs])
      (cond
        [(null? exprs) '()]
        [else
         (append
           (flatten/top-level (car exprs)
                              register-top-level!
                              register-procedure!
                              register-literals!
                              register-label!)
           (loop (cdr exprs)))])))
  
  ; lists are in reverse order
  (set! top-levels (reverse top-levels))
  (set! procedures (reverse procedures))
  (set! literals (reverse literals))

  ; debug print report
  (display "<intermediate-report") (newline)
  (display " top-levels: ") (write top-levels) (newline)
  (display " procedures: ") (write procedures) (newline)
  (display " literals  : ") (write literals) (newline)
  (display " body      : ") (write module-body) (newline)
  (display ">") (newline)

  ; assemble procedures
  (define assembled (map (lambda (p) (assemble/procedure p register-label!)) procedures))
  (for-each (lambda (is) (write is) (newline)) assembled)


  (void))

; entry point
(define (main args)
  ; currently no flag handling
  (define fnames (cdr args))
  (let loop ([fnames fnames])
    (unless (null? fnames)
      (define name (car fnames))
      (define path
        (if (is-absolute-path? name)
            name
            (build-path (current-directory) name)))
      (display "<compiling ") (write name) (display ">") (newline)
      (compile/file path)
      (loop (cdr fnames)))))

(main (command-line))

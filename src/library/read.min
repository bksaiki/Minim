;;;
;;;   Redefines read functions
;;;   Overwrites primitive functions
;;;

(import "base.min")

(export read)

;; Reader
(define (read . args)
  ;; argument selection
  (define p
    (cond
      [(null? args)       (current-input-port)]
      [(null? (cdr args)) (car args)]
      [else
       (error 'read "arity mismatch\n expected 0 or 1 arguments,"
              "received" (length args))]))

    (if (not (input-port? p))
        (error 'read "expected an input port, received " p)
        (void))

    ;; Character

    (define oparen (integer->char 40))
    (define cparen (integer->char 41))
    (define obrack (integer->char 91))
    (define cbrack (integer->char 93))
    (define obrace (integer->char 123))
    (define cbrace (integer->char 125))

    (define (space? c)
      (or (eq? c #\space)
          (eq? c #\newline)))

    (define (delimeter? c)
      (or (eof-object? c) (space? c)
          (eq? c oparen) (eq? c obrack) (eq? c obrace)
          (eq? c cparen) (eq? c cbrack) (eq? c cbrace)
          (eq? c #\") (eq? c #\;)))

    (define (symbol-char? c)
      (not (delimeter? c)))

    (define (digit? c)
      (define 0-char (char->integer #\0))
      (define 9-char (char->integer #\9))
      (define i (char->integer c))
      (<= 0-char i 9-char))

    (define (hex-digit? c)
      (define i (char->integer c))
      (or (<= (char->integer #\0) i (char->integer #\9))
          (<= (char->integer #\a) i (char->integer #\f))
          (<= (char->integer #\A) i (char->integer #\F))))

    (define (digit-prefix? c)
      (or (digit? c)
          (and (or (eq? c #\-) (eq? c #\+))
               (digit? (peek-char p)))))

    ;; Errors

    (define (assert-not-eof! c)
      (if (eof-object? c)
          (error 'read "unexpected end of input")
          (void)))

    (define (assert-matching-parens! open close)
      (if (or (and (eq? open oparen) (eq? close cparen))
              (and (eq? open obrack) (eq? close cbrack))
              (and (eq? open obrace) (eq? close cbrace)))
          (void)
          (error 'read "parenthesis mismatch " open " " close)))

    (define (assert-delimeter! c)
      (if (not (delimeter? c))
          (error 'read "expected a delimeter")
          (void)))

    ;; Whitespace reading

    (define (skip-comment!)
      (define c (peek-char p))
      (cond
        [(eof-object? c)   (void)]
        [(eq? c #\newline) (void)]
        [else
         (read-char p)
         (skip-comment!)]))

    (define (skip-block-comment!)
      (let loop ([block-level 1])
        (cond
          [(= block-level 0) (void)]
          [else
           (define c (read-char p))
           (cond
             [(eq? c #\#)
              (define c (peek-char p))
              (assert-not-eof! c)
              (cond
                [(eq? c #\|)
                 (read-char p)
                 (loop (+ block-level 1))]
                [else
                 (loop block-level)])]
                [(eq? c #\|)
                 (define c (peek-char p))
                 (assert-not-eof! c)
                 (cond
                   [(eq? c #\#)
                    (read-char p)
                    (loop (- block-level 1))]
                   [else
                    (loop block-level)])]
                [else
                  (loop block-level)])])))

    (define (skip-until-token!)
      (define c (peek-char p))
      (cond
        [(space? c)
         (read-char p)
         (skip-until-token!)]
        [(eq? c #\;)
         (read-char p)
         (skip-comment!)
         (skip-until-token!)]
        [else
         (void)]))

    (define (check-expected-string! s)
      (define len (string-length s))
      (let loop ([i 0])
        (cond
          [(< i len)
           (define c (read-char p))
           (cond
             [(eof-object? c)
              (error 'read "unexpected end of input")]
             [(eq? c (string-ref s i))
              (loop (+ i 1))]
             [else
              (error 'read "unexpected character" c)])]
          [else
           (void)])))

    ; pair reader
    (define (read-pair open)
      (skip-until-token!)
      (define c (peek-char p))
      (assert-not-eof! c)

      (cond
        [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
         (assert-matching-parens! open c)
         (read-char p)
         '()]
        [else
         (define car (read-loop))
         ;; possibly a dot
         (let loop ([car car])
           (skip-until-token!)
           (define c (peek-char p))
           (assert-not-eof! c)
           (cond
             [(eq? c #\.)
              ; maybe a pair
              (define maybe-dot (read-loop))
              (cond
                [(eq? (syntax-e maybe-dot) '.)
                 ; pair
                 (define cdr (read-loop))

                 (skip-until-token!)
                 (define c (peek-char p))
                 (assert-not-eof! c)

                 (cond
                   [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
                    (assert-matching-parens! open c)
                    (read-char p)
                    (cons car cdr)]
                   [else
                    (error 'read "missing closing parenthesis")])]
                [else
                 ; oops, just kidding
                 (cons car (loop maybe-dot))])]
             [else
              (define cdr (read-pair open))
              (cons car cdr)]))]))

    ; vector reader
    (define (read-vector)
      (let loop ([elems '()])
        (skip-until-token!)
        (define c (peek-char p))
        (cond
          [(eq? c cparen)
           (read-char p)
           (list->vector (reverse elems))]
          [else
           (loop (cons (read-loop) elems))])))

    ; character reader
    (define (read-character)
      (define c (read-char p))  
      (if (eof-object? c)
          (error 'read "incomplete character literal")
          (void))
  
      ; check for special values
      (cond
        [(eq? c #\s)
         (define cn (peek-char p))
         (cond
           [(eq? cn #\p)
            (check-expected-string! "pace")
            #\space]
           [else
            (assert-delimeter! (peek-char p))
            c])]
        [(eq? c #\n)
         (define cn (peek-char p))
         (cond
           [(eq? cn #\e)
            (check-expected-string! "ewline")
            #\newline]
           [else
            (assert-delimeter! (peek-char p))
            c])]
        [else
         (assert-delimeter! (peek-char p))
         c]))

    ; decimal number reader
    (define (read-number)
      ; if we encounter a non-digit, the token is a symbol
      ; so we need to track characters that we read
      (define 0-char (char->integer #\0))
      (define chars '())
      (define num 0)

      ; magnitude
      (let read-digit! ()
        (define c (peek-char p))
        (set! chars (cons c chars))
        (cond
          [(digit? c)
           (read-char p)
           (set! num (+ (* 10 num) (- (char->integer c) 0-char)))
           (read-digit!)]
          [(symbol-char? c)
           (read-char p)
           (read-symbol chars)]
          [else
           (assert-delimeter! (peek-char p))
           num])))

    ; hexidecimal number reader
    (define (read-hex-number c)
      ; if we encounter a non-digit, the token is a symbol
      ; so we need to track characters that we read
      (define chars '())

      ; optional sign
      (define sign
        (cond
          [(eq? c #\-)
           (read-char p)
           (set! chars (cons c chars))
           -1]
          [(eq? c #\+)
           (read-char p)
           (set! chars (cons c chars))
           1]
          [else
           1]))

      (define 0-char (char->integer #\0))
      (define a-char (char->integer #\a))
      (define A-char (char->integer #\A))

      ; magnitude
      (define num 0)
      (let read-digit! ()
        (define c (peek-char p))
        (set! chars (cons c chars))
        (cond
          [(hex-digit? c)
           (read-char p)
           (define i (char->integer c))
           (cond
             [(digit? c)
              (set! num (+ (* 16 num) (- i 0-char)))]
             [(>= i a-char)
              (set! num (+ (* 16 num) (+ 10 (- i a-char))))]
             [else
              (set! num (+ (* 16 num) (+ 10 (- i A-char))))])
           (read-digit!)]
          [(symbol-char? c)
           (read-char p)
           (read-symbol chars)]
          [else
           (assert-delimeter! (peek-char p))
           (* num sign)])))

    ; string reader
    (define (read-string)
      (let loop ([acc '()])
        (define c (peek-char p))
        (cond
          [(eof-object? c)
           (error 'read "non-terminated string literal")
           (void)]
          [(eq? c #\\)
           ; escape character
           (read-char p)
           (define c (peek-char p))
           (cond
             [(eq? c #\n)
              (read-char p)
              (loop (cons #\newline acc))]
             [(eq? c #\\)
              (read-char p)
              (loop (cons #\\ acc))]
             [(eq? c #\")
              (read-char p)
              (loop (cons #\" acc))]
             [else
              (error 'read "unknown escape character" c)])]
          [(eq? c #\")
           (read-char p)
           (reverse acc)]
          [else
           (read-char p)
           (loop (cons c acc))])))

    ;; symbol reader
    (define (read-symbol acc)
      (let loop ([acc acc])
        (define c (peek-char p))
        (cond
          [(symbol-char? c)
           (loop (cons (read-char p) acc))]
          [else
           (assert-delimeter! (peek-char p))
           (string->symbol (apply string (reverse acc)))])))

    ;; Main loop

    (define (read-loop)
      ; read and branch
      (skip-until-token!)
      (define c (peek-char p))
      (cond
        [(eof-object? c)
         (read-char p)
         c]
        [(eq? c #\#)
         (read-char p)
         ; special values
         (define c (peek-char p))
         (cond
           [(eq? c #\t)
            ; true
            (read-char p)
            (datum->syntax #t)]
           [(eq? c #\f)
            ; false
            (read-char p)
            (datum->syntax #f)]
           [(eq? c #\\)
            ; character
            (read-char p)
            (datum->syntax (read-character))]
           [(eq? c #\')
            ; quoted syntax
            (read-char p)
            (datum->syntax (list 'syntax (read-loop)))]
           [(eq? c oparen)
            ; vector
            (read-char p)
            (datum->syntax (read-vector))]
           [(eq? c #\&)
            ; box
            (read-char p)
            (datum->syntax (box (read-loop)))]
           [(eq? c #\x)
            ; hex number
            (read-char p)
            (datum->syntax (read-hex-number (peek-char p)))]
           [(eq? c #\;)
            ; datum comment
            (read-char p)
            (skip-until-token!)
            (define c (peek-char p))
            (assert-not-eof! c)
            ; read and ignore, then actually read
            (read-loop)
            (read-loop)]
           [(eq? c #\|)
            ; block comment
            (read-char p)         
            (skip-block-comment!)
            (datum->syntax (read-loop))]
           [else
            ; unknown
            (error 'read "unknown special character" c)])]
        [(or (eq? c #\+) (eq? c #\-))
         ; number or symbol
         (read-char p)
         (define n (peek-char p))
         (cond
           [(digit? n)
            ; optional sign
            (define pos-num (read-number))
            (if (eq? c #\-)
                (datum->syntax (- pos-num))
                (datum->syntax pos-num))]
           [else
            (datum->syntax (read-symbol (list c)))])]
        [(digit? c)
         ; number
         (datum->syntax (read-number))]
        [(eq? c #\")
         ; string
         (read-char p)
         (define str-chars (read-string))
         (assert-delimeter! (peek-char p))
         (datum->syntax (apply string str-chars))]
        [(or (eq? c oparen) (eq? c obrack) (eq? c obrace))
         ; pair
         (read-char p)
         (datum->syntax (read-pair c))]
        [(eq? c #\')
         ; quoted form
         (read-char p)
         (datum->syntax (list 'quote (read-loop)))]
        [(symbol-char? c)
         ; symbol
         (datum->syntax (read-symbol '()))]
        [else
         (error 'read "unexpected input:" c)]))

  (read-loop))

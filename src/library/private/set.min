;;;
;;; Sets
;;;

(import "pre-base.min" "list.min" "record.min")
(export make-set set?
        set-member?
        set-add!
        set-remove!
        set-count
        set->list)

        ; set-union)

;;
;;  Definition
;;

(define-record-type set
  (opaque #t)
  (sealed #t)
  (fields (mutable store))
  (protocol
    (lambda (p)
      (lambda xs
        (define h (make-hashtable))
        (for-each (lambda (x) (hashtable-set! h x '())) xs)
        (p h)))))

;;
;;  Basic operations
;;

(define (set-member? s v)
  (unless (set? s)
    (error 'set-member? "expected a set" s))
  (hashtable-contains? (set-store s) v))

(define (set-count s)
  (unless (set? s)
    (error 'set-count "expected a set" s))
  (hashtable-size (set-store s)))

(define (set-add! s v)
  (unless (set? s)
    (error 'set-add! "expected a set" s))
  (hashtable-set! (set-store s) v '()))

(define (set-remove! s v)
  (unless (set? s)
    (error 'set-remove! "expected a set" s))
  (hashtable-delete! (set-store s) v))

(define (set->list s)
  (unless (set? s)
    (error 'set->list "expected a set" s))
  (hashtable-keys (set-store s)))

;;
;;  Set/Set operations
;;

; (define (set-union . ss)
;   (define u (make-set))
;   (for-each (lambda (s)
;               (unless (set? s)
;                 (error 'set-union "expected a set" s))
;               (for-each (lambda (x) (set-add! u x)) (set->list s)))
;             ss)
;   u)

; (define (set-intersect . ss)
;   (define u (make-set))
;   (for-each (lambda (s)
;               (unless (set? s)
;                 (error 'set-union "expected a set" s))
;               (for-each (lambda (x) (set-add! u x)) (set->list s)))
;             ss)
;   u)

;;;
;;; Sets
;;;

(import "pre-base.min" "list.min" "record.min")
(export make-set
        set?
        set-member?
        set-copy
        set-empty?
        set-count
        set->list

        set-add!
        set-remove!
        set-clear!

        set-map
        set-for-each

        set-union
        set-intersect)

;;
;;  Definition
;;

(define-record-type set
  (opaque #t)
  (sealed #t)
  (fields (mutable store))
  (protocol
    (lambda (p)
      (lambda xs
        (define h (make-hashtable))
        (for-each (lambda (x) (hashtable-set! h x '())) xs)
        (p h)))))

;;
;;  Basic operations
;;

(define (set-member? s v)
  (unless (set? s)
    (error 'set-member? "expected a set" s))
  (hashtable-contains? (set-store s) v))

(define (set-empty? st)
  (unless (set? st)
    (error 'set-empty? "expected a set" st))
  (= (hashtable-size (set-store st)) 0))

(define (set-count s)
  (unless (set? s)
    (error 'set-count "expected a set" s))
  (hashtable-size (set-store s)))

(define (set-copy st)
  (unless (set? st)
    (error 'set-copy "expected a set" st))
  (define cp (make-set))
  (for-each (lambda (x) (set-add! cp x)) (set->list st))
  cp)

(define (set-add! s v)
  (unless (set? s)
    (error 'set-add! "expected a set" s))
  (hashtable-set! (set-store s) v '()))

(define (set-remove! s v)
  (unless (set? s)
    (error 'set-remove! "expected a set" s))
  (hashtable-delete! (set-store s) v))

(define (set-clear! st)
  (unless (set? st)
    (error 'set-clear! "expected a set" st))
  (hashtable-clear! (set-store st)))

(define (set->list s)
  (unless (set? s)
    (error 'set->list "expected a set" s))
  (hashtable-keys (set-store s)))

;;
;;  Set iteration
;;

(define (set-map proc st)
  (unless (set? st)
    (error 'set-map "expected a set" st))
  (map proc (set->list st)))

(define (set-for-each proc st)
  (unless (set? st)
    (error 'set-for-each "expected a set" st))
  (for-each proc (set->list st)))

;;
;;  Set/Set operations
;;

(define (set-union . ss)
  (for-each (lambda (s)
              (unless (set? s)
                (error 'set-union "expected a set" s)))
            ss)
  (cond
    [(null? ss)
     (make-set)]
    [(null? (cdr ss))
     (define s (car ss))
     (define c (make-set))
     (for-each (lambda (x) (set-add! c x)) (set->list s))
     c]
    [else
     (define u (make-set))
     (for-each (lambda (s)
                 (unless (set? s)
                   (error 'set-union "expected a set" s))
                 (for-each (lambda (x) (set-add! u x)) (set->list s)))
               ss)
     u]))

(define (set-intersect . ss)
  (for-each (lambda (s)
              (unless (set? s)
                (error 'set-intersect "expected a set" s)))
            ss)
  (cond
    [(null? ss)
     (make-set)]
    [(null? (cdr ss))
     (define s (car ss))
     (define c (make-set))
     (for-each (lambda (x) (set-add! c x)) (set->list s))
     c]
    [else
     (define s (car ss))
     (define i (make-set))
     (for-each (lambda (x) (set-add! i x)) (set->list s))
     (let loop ([ss (cdr ss)] [i i])
       (cond
         [(null? ss) i]
         [(= (set-count i) 0) i]
         [else
          (define s (car ss))
          (define i* (make-set))
          (for-each (lambda (x)
                      (when (set-member? s x)
                        (set-add! i* x)))
                    (set->list i))
          (loop (cdr ss) i*)]))]))

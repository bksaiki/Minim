;;;
;;; Enumeration
;;;

(import "pre-base.min" "list.min" "record.min" "set.min")
(export make-enumeration
        enum-set-type?
        enum-set->list
        enum-set-universe
        enum-set-constructor)

;;
;;  Type definition
;;

(define-record-type enum-set-type
  (opaque #t)
  (sealed #t)
  (fields id universe subset))

(define (make-enumeration xs)
  (for-each (lambda (x)
              (unless (symbol? x)
                (error 'make-enumeration "expected a symbol?" x)))
            xs)
  (define-record-type empty)
  (make-enum-set-type empty xs xs))

;;
;;  Procedures
;;

(define enum-set->list enum-set-type-subset)

(define (enum-set-universe enum-type)
  (define universe (enum-set-type-universe enum-type))
  (define-record-type empty)
  (make-enum-set-type empty universe universe))

(define (enum-set-constructor enum-type)
  (define universe (enum-set-type-universe enum-type))
  (lambda (xs)
    (define-record-type empty)
    (make-enum-set-type
      empty
      universe
      (let loop ([ys universe] [in-xs '()])
        (cond
          [(null? ys) (reverse in-xs)]
          [(member (car ys) xs) (loop (cdr ys) (cons (car ys) in-xs))]
          [else (loop (cdr ys) in-xs)])))))

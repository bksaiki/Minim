;;
;;  Lists
;;

(import "pre-base.min")
(export first second third fourth fifth sixth seventh eighth ninth tenth
        member
        filter
        foldl foldr
        assoc
        enumerate)

;;;;;;;;;;;;;;;;;;;;;;;;;;;; accessors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (first xs)
  (if (list? xs)
      (car xs)
      (error 'name "list?" xs)))

(define-syntax define-list-accessor
  (syntax-rules ()
    [(_ name npos)
     (define (name xs)
       (if (list? xs)
           (let loop ([xs xs] [pos npos])
             (if (pair? xs)
                 (if (= pos 1)
                     (car xs)
                     (loop (cdr xs) (- pos 1)))
                 (error 'name "list contains too few elements" xs)))
           (error 'name "list?" xs)))]))

(define-list-accessor second  2)
(define-list-accessor third   3)
(define-list-accessor fourth  4)
(define-list-accessor fifth   5)
(define-list-accessor sixth   6)
(define-list-accessor seventh 7)
(define-list-accessor eighth  8)
(define-list-accessor ninth   9)
(define-list-accessor tenth   10)

;;;;;;;;;;;;;;;;;;;;;;;;;;;; list operations ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (member k xs)
  (let loop ([xs xs])
    (cond [(null? xs) #f]
          [(pair? xs) (if (equal? (car xs) k) (car xs) (loop (cdr xs)))]
          [else (error 'member "expected a list" xs)])))

(define (filter f lst)
  (let loop ([xs lst] [acc '()])
    (cond [(null? xs) (reverse acc)]
          [(pair? xs) (if (f (car xs))
                          (loop (cdr xs) (cons (car xs) acc))
                          (loop (cdr xs) acc))]
          [else       (error 'map "expected a list" lst)])))

(define (foldl f acc lst)
  (let loop ([xs lst] [acc acc])
    (cond [(null? xs) acc]
          [(pair? xs) (loop (cdr xs) (f acc (car xs)))]
          [else       (error 'foldl "expected a list" lst)])))

(define (foldr f acc lst)
  (let loop ([xs lst])
    (cond [(null? xs) acc]
          [(pair? xs) (f (loop (cdr xs)) (car xs))]
          [else       (error 'foldr "expected a list" lst)])))

(define (assoc k lst)
  (cond
    [(null? lst) #f]
    [(and (pair? lst) (pair? (car lst)))
     (if (equal? k (caar lst))
         (cdar lst)
         (assoc k (cdr lst)))]
    [else (error 'assoc "expected a list of pairs" lst)]))

(define (enumerate f lst)
  (let loop ([lst lst] [i 0] [acc '()])
    (cond [(null? lst) (reverse acc)]
          [else (loop (cdr lst) (+ i 1) (cons (f (car lst) i) acc))])))

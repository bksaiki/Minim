;;;
;;; Records
;;;

(import "generics.min"
        "pre-base.min"
        "list.min"
        "record-utils.min")

(export record?                       ;; re-exported
        record-rtd                    ;; re-exported
        record-constructor            ;; re-exported
        record-predicate              ;; re-exported
        record-accessor               ;; re-exported
        record-mutator                ;; re-exported
  
        record-type-equal-procedure
        record-type-hash-procedure
        define-record-type

        $make-generics-type           ;; re-exported
        define-generics               ;; re-exported
        generic-instance?             ;; re-exported
        generics-accessor             ;; re-exported
        record-type-add-generic!      ;; re-exported

        gen:equal+hash
        gen:equal+hash?
        gen:custom-write
        gen:custom-write?)

;;
;;  Record equal? and hashing
;;

; Generic interface for comparing and hashing records
(define-generics equal+hash
                 [equal-proc a b rec-equal?]
                 [hash-proc a rec-hash])

(define equal-proc-accessor (generics-accessor gen:equal+hash 'equal-proc))
(define hash-proc-accessor (generics-accessor gen:equal+hash 'hash-proc))

; Fallback implementations for gen:equal+hash methods
(define $default-record-equal-proc ($current-record-equal-procedure))
(define $default-record-hash-proc ($current-record-hash-procedure))

(define (unsafe-record-type-equal-procedure rtd)
  (if (gen:equal+hash? rtd)
      (equal-proc-accessor rtd)
      $default-record-equal-proc))

(define (unsafe-record-type-hash-procedure rtd)
  (if (gen:equal+hash? rtd)
      (hash-proc-accessor rtd)
      $default-record-hash-proc))

(define (record-equal? a b rec-equal?)
  (define a-rtd ($record-rtd a))
  (define b-rtd ($record-rtd b))
  (and (eq? a-rtd b-rtd)
       (let ([equal-proc (unsafe-record-type-equal-procedure a-rtd)])
         (equal-proc a b rec-equal?))))

(define (record-hash r rec-hash)
  (define rtd ($record-rtd r))
  (define hash-proc (unsafe-record-type-hash-procedure rtd))
  (hash-proc r rec-hash))

;; Unlike R6RS, this cannot set the equal procedure
(define (record-type-equal-procedure rtd)
  (unless (record-type-descriptor? rtd)
    (error 'record-type-equal-procedure "expected a record type descriptor" rtd))
  (unsafe-record-type-equal-procedure rtd))

;; Unlike R6RS, this cannot set the hash procedure
(define (record-type-hash-procedure rtd)
  (unless (record-type-descriptor? rtd)
    (error 'record-type-hash-procedure "expected a record type descriptor" rtd))
  (unsafe-record-type-hash-procedure rtd))

($current-record-equal-procedure record-equal?)
($current-record-hash-procedure record-hash)

;;
;;  Record writing
;;

; Generic interface for writing records
(define-generics custom-write
                 [write-proc v port mode])

(define write-proc-accessor (generics-accessor gen:custom-write 'write-proc))

; Fallback implementation for gen:custom-write method
(define $default-record-write-proc ($current-record-write-procedure))

(define (unsafe-record-write-procedure rtd)
  (if (gen:custom-write? rtd)
      (write-proc-accessor rtd)
      $default-record-write-proc))

(define (record-write r port mode)
  (define rtd ($record-rtd r))
  (define write-proc (unsafe-record-write-procedure rtd))
  (write-proc r port mode))
     
($current-record-write-procedure record-write)

;;
;;  High-level macros
;;

;;
;;  Field descriptors have the following possible forms:
;;
;;    '(immutable <name> <accessor-name>)
;;    '(mutable <name> <accessor-name> <mutator-name>)
;;    '(immutable <name>)
;;    '(mutable <name>)
;;    <name>
;;
;;  The third and forth forms are just shorthand for
;;
;;    '(immutable <name> <rtd-name>-<name>)
;;    '(mutable <name> <rtd-name>-<name> <rtd-name>-<name>-set!)
;;
;;  respectively. The fifth form is just an abbreviation for
;;
;;    '(immutable <name>)
;;

(define-syntax (define-record-type stx)
  (syntax-case stx ()
    [(_ (name construct predicate) cls ...)
     ; full form
     (let ()
       (define clause-types '())
       (define parent-rtd #f)
       (define uid-rtd #f)
       (define sealed?-rtd #f)
       (define opaque?-rtd #f)
       (define protocol-rtd #f)
       (define fields-rtd '())
       (define methods-rtd (make-hashtable))

       (define rname (syntax->datum #'name))
       (let loop ([clauses (syntax->list #'(cls ...))])
         (unless (null? clauses)
           (define clause (car clauses))
           (syntax-case clause (fields parent uid sealed opaque protocol methods)
             [(parent prtd)
              (begin
                (when (member 'parent clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (set! clause-types (cons 'parent clause-types))
                (set! parent-rtd #'prtd))]
             [(uid value)
              (begin
                (when (member 'uid clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (set! clause-types (cons 'uid clause-types))
                (set! uid-rtd #'value))]
             [(opaque b)
              (begin
                (when (member 'opaque clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (unless (boolean? (syntax->datum #'b))
                  (syntax-error 'define-record-type "expected a boolean" stx #'b))
                (set! clause-types (cons 'opaque clause-types))
                (set! opaque?-rtd #'b))]
             [(sealed b)
              (begin
                (when (member 'sealed clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (unless (boolean? (syntax->datum #'b))
                  (syntax-error 'define-record-type "expected a boolean" stx #'b))
                (set! clause-types (cons 'sealed clause-types))
                (set! sealed?-rtd #'b))]
             [(protocol proc)
              (begin
                (when (member 'protocol clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (set! clause-types (cons 'protocol clause-types))
                (set! protocol-rtd #'proc))]
             [(methods gen-id impls ...)
              (begin
                (unless (identifier? #'gen-id)
                  (syntax-error 'define-record-type "expected identifier" stx #'gen-id))
                (when (hashtable-contains? methods-rtd (syntax-e #'gen-id))
                  (syntax-error 'define-record-type "duplicate generics" stx #'gen-id))
                (hashtable-set! methods-rtd (syntax-e #'gen-id) (syntax->list #'(impls ...))))]
             [(fields spec ...)
              (begin
                (when (member 'fields clause-types)
                  (syntax-error 'define-record-type "duplicate clause" stx clause))
                (define sname (symbol->string rname))
                (set! clause-types (cons 'fields clause-types))
                (set! fields-rtd
                  (map
                    (lambda (s)
                      (syntax-case s (immutable mutable)
                        [(immutable fname acc)
                         ; full immutable field
                         (begin
                           (unless (identifier? #'fname)
                             (syntax-error 'define-record-type "expected an identifier" s #'fname))
                           (unless (identifier? #'acc)
                             (syntax-error 'define-record-type "expected an identifier" s #'acc))
                           s)]
                        [(mutable fname acc mut)
                         ; full mutable field
                         (begin
                           (unless (identifier? #'fname)
                             (syntax-error 'define-record-type "expected an identifier" s #'fname))
                           (unless (identifier? #'acc)
                             (syntax-error 'define-record-type "expected an identifier" s #'acc))
                           (unless (identifier? #'mut)
                             (syntax-error 'define-record-type "expected an identifier" s #'mut))
                           s)]
                        [(immutable fname)
                         ; simple immutable field
                         (begin
                           (unless (identifier? #'fname)
                             (syntax-error 'define-record-type "expected an identifier" s #'fname))
                           (define field (symbol->string (syntax-e #'fname)))
                           (with-syntax ([acc (string->symbol (string-append sname "-" field))])
                             #'(immutable fname acc)))]
                        [(mutable fname)
                         ; simple mutable field
                         (begin
                           (unless (identifier? #'fname)
                             (syntax-error 'define-record-type "expected an identifier" s #'fname))
                           (define field (symbol->string (syntax-e #'fname)))
                           (with-syntax ([acc (string->symbol (string-append sname "-" field))]
                                         [mut (string->symbol (string-append sname "-" field "-set!"))])
                             #'(mutable fname acc mut)))]
                        [fname
                         ; identifier
                         (begin
                           (unless (identifier? #'fname)
                             (syntax-error 'define-record-type "expected an identifier" #'fname #'fname))
                           (define field (symbol->string (syntax-e #'fname)))
                           (with-syntax ([acc (string->symbol (string-append sname "-" field))])
                             #'(immutable fname acc)))]))
                    (syntax->list #'(spec ...)))))]
             [_ (syntax-error 'define-record-type "invalid clause" stx clause)])
           (loop (cdr clauses))))
       (with-syntax ([parent* parent-rtd]
                     [uid* uid-rtd]
                     [sealed?* sealed?-rtd]
                     [opaque?* opaque?-rtd]
                     [protocol* protocol-rtd]
                     [(gen-methods ...)
                      (map
                        (lambda (gen-id)  ; TODO: weird bugs in `with-syntax`?
                          (with-syntax ([gen-id gen-id]
                                        [(gen-methods ...) (hashtable-ref methods-rtd gen-id)])
                            #'(cons gen-id (list gen-methods ...))))
                        (hashtable-keys methods-rtd))]
                     [(fields ...)
                      (map
                        (lambda (s)
                          (syntax-case s (immutable mutable)
                            [(immutable name _) #'(immutable name)]
                            [(mutable name _ _) #'(mutable name)]))
                        fields-rtd)]
                     [(accs ...)
                      (enumerate
                        (lambda (s i)
                          (with-syntax ([idx i])
                            (syntax-case s (immutable mutable)
                              [(immutable _ acc) #'(define acc (record-accessor name idx))]
                              [(mutable _ acc _) #'(define acc (record-accessor name idx))])))
                        fields-rtd)]
                     [(muts ...)
                      (filter
                        (lambda (x) x)
                        (enumerate
                          (lambda (s i)
                            (with-syntax ([idx i])
                              (syntax-case s (immutable mutable)
                                [(immutable _ _) #f]
                                [(mutable _ _ mut) #'(define mut (record-mutator name idx))])))
                          fields-rtd))])
        #'(begin
            (define name
              (let ([p parent*])
                (if (and p (record-type-sealed? p))
                    (error 'define-record-type
                           "parent record type is sealed"
                           (format "record type: #<record-type:~a>" 'name)
                           (format "parent type: ~a" p))
                    (make-record-type-descriptor 'name p
                      uid* sealed?* opaque?* '#(fields ...)))))
            (begin
              (let ()
                (define methods gen-methods)
                (define gen-id (car methods))
                (define fns (cdr methods))
                (record-type-add-generic! name gen-id fns))
              ...)
            (define construct
              (let ([c (record-constructor name)]
                    [p protocol*])
                (if p (p c) c)))
            (define predicate (record-predicate name))
            (begin accs ...)
            (begin muts ...))))]
    [(_ name cls ...) 
     ; simplified form
     (if (identifier? #'name)
         (let ([sname (symbol->string (syntax-e #'name))])
           (with-syntax ([construct (string->symbol (string-append "make-" sname))]
                         [predicate (string->symbol (string-append sname "?"))])
             #'(define-record-type (name construct predicate) cls ...)))
         (syntax-error 'define-record-type "expected an identifier" stx #'name))]
    [(_ ...)
     ; bad form
     (syntax-error 'define-record-type "missing record name spec" stx)]))

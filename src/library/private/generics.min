;;;
;;; Generics
;;;

(import "list.min" "pre-base.min" "record-utils.min")

(export $make-generics-type
        $generics-type?
        $generics-type-methods
        define-generics
        generic-instance?
        record-type-generics)

;;
;;  Definitions
;;

(define $generics-type
  (make-record-type-descriptor 'generics
                               #f #f #f #f
                               '#((immutable methods))))

(define $generics-type? (record-predicate $generics-type))
(define $generics-type-methods (record-accessor $generics-type 0))

(define ($make-generics-type methods)
  (define $make (record-constructor $generics-type))
  ; TODO: validation

  ($make methods))

;;
;;  Records
;;

(define $record-generics (make-hashtable))

(define (record-type-generics rtd generic)
  (unless ($generics-type? generic)
    (error 'record-type-generics "expected a generic interface" generic))
  (unless (record-type-descriptor? rtd)
    (error 'record-type-generics "expected a record type descriptor" rtd))
  (hashtable-set! $record-generics rtd
                  (cond
                    [(hashtable-contains? $record-generics) 
                     (cons generic (hashtable-ref $record-generics rtd))]
                    [else
                     (list generic)])))

(define ((generic-instance? generic) rtd)
  (unless ($generics-type? generic)
    (error 'generic-instance? "expected a generic interface" generic))
  (unless (record-type-descriptor? rtd)
    (error 'generic-instance? "expected a record type descriptor" rtd))
  (and (hashtable-contains? $record-generics)
       (member (hashtable-ref $record-generics rtd) generic)))

;;
;;  Syntax
;;
;; (define-generics <id>
;;                  [<method-id> . <formals>]
;;                  ...)
;;
;; <formals> ::= (<arg> ...)
;;           ::= (<arg> ... . <rest-id>)
;;           ::= <rest-id>
;;

(define-syntax (define-generics stx)
  (syntax-case stx ()
    [(_ id [method-id . formals] ...)
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-generics "expected an identifier" stx #'id))
       (define method-table (list))
       (define gen-id (symbol->string (syntax-e #'id)))

       (let loop ([method-ids (syntax->list #'(method-id ...))]
                  [formals* (syntax->list #'(formals ...))])
         (unless (null? method-ids)
           (define mid (car method-ids))
           (unless (identifier? mid)
             (syntax-error 'define-generics "expected an identifier" stx mid))

           (define args (car formals*))
           (let loop ([args (syntax-e args)])
             (unless (or (null? args) (identifier? args))
               (unless (pair? args)
                 (syntax-error 'define-generics "expected an identifier" stx args))
               (define arg (car args))
               (unless (identifier? arg)
                 (syntax-error 'define-generics "expected an identifier" stx arg))
               (loop (cdr args))))
           
           (define entry (cons (syntax-e mid) (syntax->datum args)))
           (set! method-table (cons entry method-table))
           (loop (cdr method-ids) (cdr formals*))))
  
       (with-syntax ([gen-id (string->symbol (string-append "gen:" gen-id))]
                     [method-table (reverse method-table)])
         #'(define-values (gen-id) ($make-generics-type 'method-table))))]
    [(_ id cls ...)
     (if (identifier? #'id)
         (let loop ([clauses (syntax->list #'(cls ...))])
           (unless (null? clauses)
             (let ([clause (car clauses)])
               (syntax-case clause ()
                 [(method-id . _) (loop (cdr clauses))]
                 [_ (syntax-error 'define-generics "malformed generic method" stx clause)]))))
         (syntax-error 'define-generics "expected an identifier" stx #'id))]
    [_ (syntax-error 'define-generics "bad syntax" stx)]))
  

;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%fp %sp %env %ret))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real aliases)
  (opaque #t))

(define (validate-register-set! rset)
  (define aliases (register-set-aliases rset))
  (for-each (lambda (r)
              (unless (assoc r aliases)
                (error 'validate-register-set! "missing required register" r)))
            required-registers))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             (let* ([registers (append (map list rregs rregs-aliases rregs-reserved?)
                                       (map list aregs aregs-aliases aregs-reserved?))]
                    [aliases (let loop ([registers registers] [alias-map '()])
                               (cond
                                 [(null? registers) alias-map]
                                 [else
                                  (define reg (caar registers))
                                  (define aliases (cadar registers))
                                  (loop (cdr registers)
                                              (append (map (lambda (a) (cons a reg)) aliases)
                                                      alias-map))]))]
                    [rset (make-register-set registers aliases)])
               (validate-register-set! rset)
               rset))))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs (mutable virtual-regs))
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset '())))))

(define (register-allocator-real-register? allocator r)
  (define rset (register-allocator-target-regs allocator))
  (or (assoc r (register-set-real rset))
      (assoc r (register-set-alias rset))))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (length vregs)))))
  (register-allocator-virtual-regs-set! allocator (cons name vregs))
  name)

;;
;;  Register assigner
;;

(define (sort-vreg-dict vregs dict)
  (map (lambda (r)
         (let ([v (assoc r dict)])
           (cons r v)))
       vregs))

(define (compute-first-use instrs unused reverse? vreg?)
  (let loop ([instrs instrs] [unused unused] [used '()] [i 0])
    (cond
      [(null? instrs) used]
      [else
       (let loop2 ([args (cdar instrs)] [unused unused] [used used])
         (cond
           [(null? args)
            (loop (cdr instrs) unused used (+ i 1))]
           [(and (vreg? (car args)) (member (car args) unused))
            (define idx (if reverse? (- (length instrs) 1) i))
            (loop2 (cdr args) (remove (car args) unused)
                   (cons (cons (car args) idx) used))]
           [else
            (loop2 (cdr args) unused used)]))])))

(define (register-assign instrs init-used alloc)
  (define rset (register-allocator-target-regs alloc))
  (define vregs (reverse (register-allocator-virtual-regs alloc)))

  (define (virtual-register? reg)
    (and (symbol? reg) (member reg vregs)))

  (define (real-register? reg)
    (and (symbol? reg)
         (register-allocator-real-register? allocator reg)))

  ; compute used registers with first/last uses
  (define no-init-used (remove* init-used vregs))
  (define-values (first-use last-use used)
    (let* ([last-use (compute-first-use (reverse instrs) vregs #t virtual-register?)]
           [first-use (append (map (lambda (r) (cons r 0)) init-used)
                             (compute-first-use instrs no-init-used #f virtual-register?))]
           [used (map car (filter (lambda (elt) (cdr elt)) last-use))])
      (values (sort-vreg-dict used first-use)
              (sort-vreg-dict used last-use)
              used)))

  ; compute use spans
  (define sort-span (lambda (elt1 elt2) (> (cdr elt1) (cdr elt2))))
  (define unsorted-use-spans (map (lambda (f l) (cons (car f) (- (cdr l) (cdr f)))) first-use last-use))
  (define use-spans (sort unsorted-use-spans sort-span))

  (printf "~a\n" used)
  (printf "~a\n" first-use)
  (printf "~a\n" last-use)
  (printf "~a\n" use-spans)

  (void))


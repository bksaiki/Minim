;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-virtual-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%cc %sp %env %ret))
(define argument-registers '(%arg0 %arg1 %arg2 %arg3 %arg4 %arg5))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real aliases)
  (opaque #t))

(define (canonicalize-register rset reg)
  (cond
    [(member reg (map car (register-set-real rset)))
     reg]
    [(member reg (map car (register-set-aliases rset)))
     (assoc reg (register-set-aliases rset))]
    [else
     (error 'canonicalize-register "not a register or register alias" reg)]))

(define (validate-register-set! rset)
  (define aliases (register-set-aliases rset))
  (for-each (lambda (r)
              (unless (assoc r aliases)
                (error 'validate-register-set! "missing required register" r)))
            required-registers)
  (let loop ([regs argument-registers] [supported? #t])
    (cond [(null? regs)
           (void)] 
          [(member (car regs) aliases)
           (unless supported?
             (error 'validate-register-set! "missing argument register, before" (car regs)))
           (loop (cdr regs) supported?)]
          [else
           (loop (cdr regs) #f)])))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             (let* ([registers
                     (append
                       (map (lambda (r a r?) (list r a r? #t))
                            rregs rregs-aliases rregs-reserved?)
                       (map (lambda (r a r?) (list r a r? #f))
                            aregs aregs-aliases aregs-reserved?))]
                    [aliases
                     (let loop ([registers registers] [alias-map '()])
                       (cond
                         [(null? registers) alias-map]
                         [else
                          (define reg (caar registers))
                          (define aliases (cadar registers))
                          (loop (cdr registers)
                                      (append (map (lambda (a) (cons a reg)) aliases)
                                              alias-map))]))]
                    [rset (make-register-set registers aliases)])
               (validate-register-set! rset)
               rset))))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs (mutable virtual-regs))
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset '())))))

(define (register-allocator-real-register? allocator r)
  (define rset (register-allocator-target-regs allocator))
  (or (assoc r (register-set-real rset))
      (assoc r (register-set-aliases rset))))

(define (register-allocator-virtual-register? allocator r)
  (define vregs (register-allocator-virtual-regs allocator))
  (member r vregs))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (length vregs)))))
  (register-allocator-virtual-regs-set! allocator (cons name vregs))
  name)

;;
;;  Register assigner
;;

(define (sort-vreg-dict vregs dict)
  (map (lambda (r)
         (let ([v (assoc r dict)])
           (cons r v)))
       vregs))

(define (compute-used-registers instrs vreg?)
  (define used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (when (vreg? (car args))
            (set-add! used (car args)))
          (loop2 (cdr args))))
      (loop (cdr instrs))))
  (set->list used))

(define (compute-live-ranges instrs used)
  (define first (make-vector (length used) #f))
  (define last (make-vector (length used) #f))
  (let loop ([instrs instrs] [i 0])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (define idx (index-of (car args) used))
          (when idx
            (unless (vector-ref first idx)
              (vector-set! first idx i))
            (vector-set! last idx i))
          (loop2 (cdr args))))
      (loop (cdr instrs) (+ i 1))))
  (values (vector->list first)
          (vector->list last)))

; compute the interference graph for virtual registers
; stored as an association list mapping vreg to info:
; `(list rreg forw back span))`
; - `rreg`: the real register assignment (`#f` if not assigned)
; - `forw`: all vregs that this register conflicts with
; - `back`: all vregs that conflict with this register
; - `span`: number of instructions spanned by this vreg
(define (make-if-graph first-uses last-uses)
  (define regs (hashtable-keys first-uses))
  (define forward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (>= (hashtable-ref first-uses r2) first)
                          (< (hashtable-ref first-uses r2) last)))
                   regs))
         regs))
  (define backward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (< (hashtable-ref first-uses r2) first)
                          (>= (hashtable-ref last-uses r2) first)))
                   regs))
         regs))
  (define spans
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (- last first))
         regs))
  (map (lambda (r f b s) (cons r (list #f f b s)))
       regs forward backward spans))


(define (if-graph-get if-graph vreg)
  (assoc vreg if-graph))

(define (if-graph-set if-graph vreg rreg)
  (cond
    [(null? if-graph)
     if-graph]
    [(eq? (caar if-graph) vreg)
     (cons (cons vreg (cons rreg (cddar if-graph))) (cdr if-graph))]
    [else
     (cons (car if-graph) (if-graph-set (cdr if-graph) vreg rreg))]))

(define (apply-known if-graph instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))
  
  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (let loop ([instrs instrs] [if-graph if-graph])
    (cond
        [(null? instrs) if-graph]
        [else
         (case (caar instrs)
           [(init)
            (let loop2 ([args (cdar instrs)] [i 0] [if-graph if-graph])
              (cond
                [(null? args)
                 (loop (cdr instrs) if-graph)]
                [(vreg? (car args))
                 (define vreg (car args))
                 (define reg (arg-register i))
                 (loop2 (cdr args) (+ i 1)
                        (if reg
                            (if-graph-set if-graph vreg (canonicalize-register rset reg))
                            if-graph))]
                [else
                 (loop2 (cdr args) (+ i 1) if-graph)]))]
           [else
            (loop (cdr instrs) if-graph)])])))

(define (register-hints instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))

  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (define (assoc-set lst k v)
    (let loop ([lst lst])
      (cond [(null? lst) lst]
            [(eq? (caar lst) k) (cons (cons k v) (cdr lst))]
            [else (cons (car lst) (loop (cdr lst)))])))

  (define (hint-add hints vreg rreg)
    (define rregs (assoc vreg hints))
    (define rreg* (and rreg (canonicalize-register rset rreg)))
    (cond [(not rregs) (cons (cons vreg (list rreg*)) hints)]
          [(or (not rreg*) (member rreg* rregs)) hints]
          [else (assoc-set hints vreg (cons rreg* rregs))]))

  (let loop ([instrs instrs] [hints '()])
    (if (null? instrs)
        hints
        (case (caar instrs)
          [(c-call)
           (define target (cadar instrs))
           (define args (cddar instrs))
           (define hints* (if (vreg? target) (hint-add hints target '%ret) hints))
           (let loop2 ([args args] [k 0] [hints hints*])
             (cond
               [(null? args)
                (loop (cdr instrs) hints)]
               [(vreg? (car args))
                (loop2 (cdr args) (+ k 1) (hint-add hints (car args) (arg-register k)))]
               [else
                (loop2 (cdr args) (+ k 1) hints)]))]
          [else
           (loop (cdr instrs) hints)]))))

(define (reg>? r1 r2)
    (let ([as1 (second r1)] [p1? (third r1)]
          [as2 (second r2)] [p2? (third r2)])
      (cond
        [(and (null? as1) (not (null? as2))) #t]
        [(and (not (null? as1)) (null? as2)) #f]
        [(and (not p1?) p2?) #t]
        [(and p1? (not p2?)) #f]
        [else #t])))

(define (apply-assign if-graph instrs rset vreg?)
  ; Sorts nodes in the interference graph by index
  ;  `ni` ::= `(cons vreg (list rreg forw back))`
  (define (node>? n1 n2)
    (let ([v1 (cdr n1)] [v2 (cdr n2)])
      (> (+ (length (second v1)) (length (third v1)))
         (+ (length (second v2)) (length (third v2))))))

  (define (connected-rregs conn if-graph)
    (let loop ([conn conn] [rregs '()])
      (cond
        [(null? conn) rregs]
        [else
         (define info (if-graph-get if-graph (car conn)))
         (if (and info (first info))
             (loop (cdr conn) (cons (cons (car conn) (first info)) rregs))
             (loop (cdr conn) rregs))])))


  (define allocable
    (sort (filter (lambda (elt) (not (fourth elt)))
                  (register-set-real rset))
          reg>?))

  (define (unassigned-rreg conflicts)
    (define c-rregs (map cdr conflicts))
    (define open (filter (lambda (elt) (not (member (first elt) c-rregs))) allocable))
    (and (not (null? open)) (first (car open))))

  ; Sort graph and compute hints
  (define not-done (sort if-graph node>?))
  (define hints (register-hints instrs rset vreg?))
  (define spills (make-set))

  ; Iteratively assign
  (let loop ([not-done not-done] [if-graph '()])
    (cond
      [(null? not-done) (values if-graph spills)]
      [else
       (define vreg (caar not-done))
       (define maybe-rreg (first (cdar not-done)))
       (define connected (append (second (cdar not-done)) (third (cdar not-done))))
       ; check if we have a hint
       ; hints is an association list (vreg -> ((idx . rreg) ...))
       (define hint (assoc vreg hints))
       (cond
         [maybe-rreg
          (loop (cdr not-done) (cons (car not-done) if-graph))]
         [hint
          (define rreg (first hint))
          (define conflicts
            (filter (lambda (c-info) (eq? rreg (cdr c-info)))
                    (connected-rregs connected (append not-done if-graph))))
          (cond
            [(not (null? conflicts))
             (define bad-vreg (caar conflicts))
             (set-add! spills bad-vreg)
            ;  (printf "CONFLICT: ~a ~a\n" vreg conflicts)
             (loop (cdr not-done) if-graph)]
            [else
            ;  (printf "~a H> ~a\n" vreg rreg)
             (define if-graph* (cons (car not-done) if-graph))
             (loop (cdr not-done) (if-graph-set if-graph* vreg rreg))])]
         [else
          (define conflicts (connected-rregs connected (append not-done if-graph)))
          (define rreg (unassigned-rreg conflicts))
          (cond
            [(not rreg)
             (set-add! spills vreg)
            ;  (printf "SPILL: ~a ~a\n" vreg)
             (loop (cdr not-done) if-graph)]
            [else
            ;  (printf "~a => ~a\n" vreg rreg)
             (define if-graph* (cons (car not-done) if-graph))
             (loop (cdr not-done) (if-graph-set if-graph* vreg rreg))])])])))

(define (replace-vregs instrs replace-map rset vreg? rreg?)
  (map (lambda (instr)
         (cons (car instr)
               (map (lambda (arg)
                      (cond [(vreg? arg) (assoc arg replace-map)]
                            [(rreg? arg) (canonicalize-register rset arg)]
                            [else arg]))
                    (cdr instr))))
       instrs))

(define (apply-spill spill instrs first-uses alloc id)
  (define (instr-has-vreg? instr vreg)
    (ormap (lambda (arg) (eq? arg vreg)) instr))

  (define (replace-vreg instr vreg1 vreg2)
    (cons (car instr)
          (map (lambda (arg) (if (eq? arg vreg1) vreg2 arg))
               (cdr instr))))

  (define first-use+1 (+ (hashtable-ref first-uses spill) 1))
  (let loop ([instrs instrs] [k 0])
    (cond
      [(null? instrs)
       '()]
      [(< k first-use+1)
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))]
      [(= k first-use+1)
       (cons (list 'load (list 'local id) spill)
             (loop instrs (+ k 1)))]
      [(instr-has-vreg? (car instrs) spill)
       (define t-reg (register-allocator-new! alloc))
       (cons* (list 'load t-reg (list 'local id))
              (replace-vreg (car instrs) spill t-reg)
              (loop (cdr instrs) (+ k 1)))]
      [else
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))])))

(define (apply-callee-saved instrs rset)
  (define callee-saved
    (map car (filter (lambda (elt) (and (third elt) (not (fourth elt))))
                     (register-set-real rset))))

  (define callee-saved-used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (for-each (lambda (arg)
                  (when (member arg callee-saved)
                    (set-add! callee-saved-used arg)))
                (cdr instr))
      (loop (cdr instrs))))

  (define used-in-order
    (filter (lambda (r) (set-member? callee-saved-used r))
            callee-saved))
  
  (define init-instr (car instrs))
  (define rest-instrs (cdr instrs))
  (define prefix (map (lambda (r) (list 'push r)) used-in-order))
  (define suffix (map (lambda (r) (list 'pop r)) (reverse used-in-order)))

  (cons init-instr (append prefix rest-instrs suffix)))

(define (optimize instrs)
  (let loop ([instrs instrs])
    (cond
      [(null? instrs) '()]
      [else
       (define instr (first instrs))
       (case (first instr)
         [(load)
          ; load => remove self-assignment
          (define dst (second instr))
          (define src (third instr))
          (if (eq? dst src)
              (loop (cdr instrs))
              (cons instr (loop (cdr instrs))))]
         [else
          (cons instr (loop (cdr instrs)))])])))

;
; Top-level register assigner
;

(define (register-assign instrs alloc)
  (define rset (register-allocator-target-regs alloc))  
  (let loop ([instrs instrs] [spill-count 0])
    (define vregs (apply make-set (register-allocator-virtual-regs alloc)))
    ; (printf "asm> ~a\n" instrs)

    (define (rreg? reg)
      (and (symbol? reg) (register-allocator-real-register? alloc reg)))

    (define (vreg? reg)
      (and (symbol? reg) (set-member? vregs reg)))

    ; compute live ranges
    (define used-regs (compute-used-registers instrs vreg?))
    (define-values (first-uses last-uses) (compute-live-ranges instrs used-regs))

    ; convert to hashtables
    (define first-use-map (make-hashtable))
    (define last-use-map (make-hashtable))
    (for-each (lambda (r i) (hashtable-set! first-use-map r i)) used-regs first-uses)
    (for-each (lambda (r i) (hashtable-set! last-use-map r i)) used-regs last-uses)

    ; compute interference graph
    (define if-graph (make-if-graph first-use-map last-use-map))

    ; apply known and then color
    (define if-graph* (apply-known if-graph instrs rset vreg?))
    (define-values (if-graph** spills) (apply-assign if-graph* instrs rset vreg?))
      
    ; (printf "~a\n" used-regs)
    ; (printf "~a\n" first-use-map)
    ; (printf "~a\n" last-use-map)
    ; (printf "~a\n" if-graph**)

    (cond
      [(set-empty? spills)
       (define replace-map (map (lambda (i) (cons (car i) (first (cdr i)))) if-graph**))
       (define assigned (replace-vregs instrs replace-map rset vreg? rreg?))
       (define with-stash (apply-callee-saved assigned rset))
       (optimize with-stash)]
      [else
       (let loop2 ([instrs instrs] [spills (set->list spills)] [i spill-count])
         (if (null? spills)
             (loop instrs i)
             (let ([instrs* (apply-spill (car spills) instrs first-use-map alloc i)])
               (loop2 instrs* (cdr spills) (+ i 1)))))])))

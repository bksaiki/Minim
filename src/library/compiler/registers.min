;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%fp %sp %env %ret))
(define argument-registers '(%arg0 %arg1 %arg2 %arg3 %arg4 %arg5))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real aliases)
  (opaque #t))

(define (validate-register-set! rset)
  (define aliases (register-set-aliases rset))
  (for-each (lambda (r)
              (unless (assoc r aliases)
                (error 'validate-register-set! "missing required register" r)))
            required-registers)
  (let loop ([regs argument-registers] [supported? #t])
    (cond [(null? regs)
           (void)] 
          [(member (car regs) aliases)
           (unless supported?
             (error 'validate-register-set! "missing argument register, before" (car regs)))
           (loop (cdr regs) supported?)]
          [else
           (loop (cdr regs) #f)])))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             (let* ([registers (append (map list rregs rregs-aliases rregs-reserved?)
                                       (map list aregs aregs-aliases aregs-reserved?))]
                    [aliases (let loop ([registers registers] [alias-map '()])
                               (cond
                                 [(null? registers) alias-map]
                                 [else
                                  (define reg (caar registers))
                                  (define aliases (cadar registers))
                                  (loop (cdr registers)
                                              (append (map (lambda (a) (cons a reg)) aliases)
                                                      alias-map))]))]
                    [rset (make-register-set registers aliases)])
               (validate-register-set! rset)
               rset))))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs (mutable virtual-regs))
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset '())))))

(define (register-allocator-real-register? allocator r)
  (define rset (register-allocator-target-regs allocator))
  (or (assoc r (register-set-real rset))
      (assoc r (register-set-alias rset))))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (length vregs)))))
  (register-allocator-virtual-regs-set! allocator (cons name vregs))
  name)

;;
;;  Register assigner
;;

(define (sort-vreg-dict vregs dict)
  (map (lambda (r)
         (let ([v (assoc r dict)])
           (cons r v)))
       vregs))

; computes index of instruction of first use/init
(define (compute-first-use instrs unused reverse? vreg?)
  (let loop ([instrs instrs] [unused unused] [used '()] [i 0])
    (cond
      [(null? instrs) used]
      [else
       (let loop2 ([args (cdar instrs)] [unused unused] [used used])
         (cond
           [(null? args)
            (loop (cdr instrs) unused used (+ i 1))]
           [(and (vreg? (car args)) (member (car args) unused))
            (define idx (if reverse? (- (length instrs) 1) i))
            (loop2 (cdr args) (remove (car args) unused)
                   (cons (cons (car args) idx) used))]
           [else
            (loop2 (cdr args) unused used)]))])))

; compute the interference graph
; for virtual registers
(define (make-if-graph first-uses last-uses)
  (define forward
    (map (lambda (elt)
           (define reg (car elt))
           (define first-use (assoc reg first-uses))
           (define last-use (assoc reg last-uses))
           (define conflicts
             (filter (lambda (elt)
                       (define reg2 (car elt))
                       (define first-use2 (cdr elt))
                       (and (not (eq? reg reg2))
                            (>= first-use2 first-use)
                            (< first-use2 last-use)))
                     first-uses))
           (cons reg (map car conflicts)))
         first-uses))

  (define both
    (map (lambda (elt)
           (define reg (car elt))
           (define forw-conflicts (cdr elt))
           (define back-conflicts (map car (filter (lambda (elt) (member reg (cdr elt))) forward)))
           (cons reg (list #f forw-conflicts back-conflicts)))
         forward))

  both)

(define (if-graph-get if-graph vreg)
  (assoc vreg if-graph))

(define (if-graph-set if-graph vreg rreg)
  (cond
    [(null? if-graph)
     if-graph]
    [(eq? (caar if-graph) vreg)
     (cons (cons vreg (cons rreg (cddar if-graph))) (cdr if-graph))]
    [else
     (cons (car if-graph) (if-graph-set (cdr if-graph) vreg rreg))]))

(define (apply-hints if-graph instrs rset vreg?)
  ; (define (arg-register i)
  ;   (define args (filter )

  (define (vreg-assign if-graph vreg rreg)
    (define reg (car (if-graph-get if-graph vreg)))
    (when (and reg (not (eq? reg rreg)))
      (printf "warn: CONFLICT ~a ~a\n" vreg rreg))
    (if-graph-set if-graph vreg rreg))

  (define (c-call-assign-target if-graph vreg)
    (if (vreg? vreg) (vreg-assign if-graph vreg '%res) if-graph))

  (define (c-call-assign if-graph vreg idx)
    (if (vreg? vreg) (vreg-assign if-graph vreg '%arg0) if-graph))

  (let loop ([instrs instrs] [if-graph if-graph])
    (cond
      [(null? instrs) if-graph]
      [else
       (case (caar instrs)
        [(init)
         (printf "init: ~a\n" (car instrs))
         (loop (cdr instrs) if-graph)]
        [(c-call)
         (printf "c-call: ~a\n" (car instrs))
         (define target (cadar instrs))
         (define args (cddar instrs))
         (let loop2 ([if-graph (c-call-assign-target if-graph target)] [args args] [i 0])
           (if (null? args)
               (loop (cdr instrs) if-graph)
               (loop2 (c-call-assign if-graph (car args) i) (cdr args) (+ i 1))))]
        [else
         (loop (cdr instrs) if-graph)])])))

(define (register-assign instrs alloc)
  (define rset (register-allocator-target-regs alloc))
  (define vregs (reverse (register-allocator-virtual-regs alloc)))

  (define (virtual-register? reg)
    (and (symbol? reg) (member reg vregs)))

  (define (real-register? reg)
    (and (symbol? reg)
         (register-allocator-real-register? allocator reg)))

  (define (span>? s1 s2)
    (> (cdr s1) (cdr s2)))

  ; compute used registers with first/last uses
  (define-values (first-uses last-uses used-regs)
    (let* ([first-use (compute-first-use instrs vregs #f virtual-register?)]
           [last-use (compute-first-use (reverse instrs) vregs #t virtual-register?)]
           [used (map car (filter (lambda (elt) (cdr elt)) last-use))])
      (values (sort-vreg-dict used first-use)
              (sort-vreg-dict used last-use)
              used)))

  ; compute use spans
  ; (define use-spans
  ;   (sort (map (lambda (u f l)
  ;                (cons u (- (cdr l) (cdr f))))
  ;              used-regs first-uses last-uses)
  ;         span>?))

  ; compute interference graph
  (define if-graph (make-if-graph first-uses last-uses))
  (define if-graph* (apply-hints if-graph instrs rset virtual-register?))
    
  (printf "~a\n" used-regs)
  (printf "~a\n" first-uses)
  (printf "~a\n" last-uses)
  ; (printf "~a\n" use-spans)
  (printf "~a\n" if-graph*)

  (void))


;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-virtual-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%cc %sp %env %ret))
(define argument-registers '(%arg0 %arg1 %arg2 %arg3 %arg4 %arg5))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real aliases)
  (opaque #t))

(define (canonicalize-register rset reg)
  (cond
    [(member reg (map car (register-set-real rset)))
     reg]
    [(member reg (map car (register-set-aliases rset)))
     (assoc reg (register-set-aliases rset))]
    [else
     (error 'canonicalize-register "not a register or register alias" reg)]))

(define (validate-register-set! rset)
  (define aliases (register-set-aliases rset))
  (for-each (lambda (r)
              (unless (assoc r aliases)
                (error 'validate-register-set! "missing required register" r)))
            required-registers)
  (let loop ([regs argument-registers] [supported? #t])
    (cond [(null? regs)
           (void)] 
          [(member (car regs) aliases)
           (unless supported?
             (error 'validate-register-set! "missing argument register, before" (car regs)))
           (loop (cdr regs) supported?)]
          [else
           (loop (cdr regs) #f)])))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             (let* ([registers
                     (append
                       (map (lambda (r a r?) (list r a r? #t))
                            rregs rregs-aliases rregs-reserved?)
                       (map (lambda (r a r?) (list r a r? #f))
                            aregs aregs-aliases aregs-reserved?))]
                    [aliases
                     (let loop ([registers registers] [alias-map '()])
                       (cond
                         [(null? registers) alias-map]
                         [else
                          (define reg (caar registers))
                          (define aliases (cadar registers))
                          (loop (cdr registers)
                                      (append (map (lambda (a) (cons a reg)) aliases)
                                              alias-map))]))]
                    [rset (make-register-set registers aliases)])
               (validate-register-set! rset)
               rset))))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs (mutable virtual-regs))
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset '())))))

(define (register-allocator-real-register? allocator r)
  (define rset (register-allocator-target-regs allocator))
  (or (assoc r (register-set-real rset))
      (assoc r (register-set-aliases rset))))

(define (register-allocator-virtual-register? allocator r)
  (define vregs (register-allocator-virtual-regs allocator))
  (member r vregs))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (length vregs)))))
  (register-allocator-virtual-regs-set! allocator (cons name vregs))
  name)

;;
;;  Register assigner
;;

(define (sort-vreg-dict vregs dict)
  (map (lambda (r)
         (let ([v (assoc r dict)])
           (cons r v)))
       vregs))

(define (compute-used-registers instrs vreg?)
  (define used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (when (vreg? (car args))
            (set-add! used (car args)))
          (loop2 (cdr args))))
      (loop (cdr instrs))))
  (set->list used))

(define (compute-live-ranges instrs used)
  (define first (make-vector (length used) #f))
  (define last (make-vector (length used) #f))
  (let loop ([instrs instrs] [i 0])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (define idx (index-of (car args) used))
          (when idx
            (unless (vector-ref first idx)
              (vector-set! first idx i))
            (vector-set! last idx i))
          (loop2 (cdr args))))
      (loop (cdr instrs) (+ i 1))))
  (values (vector->list first)
          (vector->list last)))

; compute the interference graph for virtual registers
; stored as an association list mapping vreg to info:
; `(list rreg forw back span))`
; - `rreg`: the real register assignment (`#f` if not assigned)
; - `forw`: all vregs that this register conflicts with
; - `back`: all vregs that conflict with this register
; - `span`: number of instructions spanned by this vreg
(define (make-if-graph first-uses last-uses)
  (define regs (hashtable-keys first-uses))
  (define forward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (>= (hashtable-ref first-uses r2) first)
                          (< (hashtable-ref first-uses r2) last)))
                   regs))
         regs))
  (define backward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (< (hashtable-ref first-uses r2) first)
                          (>= (hashtable-ref last-uses r2) first)))
                   regs))
         regs))
  (define spans
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (- last first))
         regs))

  (define if-graph (make-hashtable))
  (for-each (lambda (r f b s)
              (hashtable-set! if-graph r (list #f f b s)))
            regs forward backward spans)
  if-graph)

(define (if-graph-set-rreg! if-graph vreg rreg)
  (define info (hashtable-ref if-graph vreg))
  (hashtable-set! if-graph vreg (cons rreg (cdr info))))

(define (if-graph-set if-graph vreg rreg)
  (cond
    [(null? if-graph)
     if-graph]
    [(eq? (caar if-graph) vreg)
     (cons (cons vreg (cons rreg (cddar if-graph))) (cdr if-graph))]
    [else
     (cons (car if-graph) (if-graph-set (cdr if-graph) vreg rreg))]))

(define (apply-known if-graph instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))
  
  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (case (car instr)
        [(init)
         (let loop2 ([args (cdr instr)] [i 0])
           (unless (null? args)
             (when (vreg? (car args))
               (define reg (arg-register i))
               (if-graph-set-rreg! if-graph (car args)
                                   (canonicalize-register rset reg)))
             (loop2 (cdr args) (+ i 1))))])
      (loop (cdr instrs)))))


(define (register-hints instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))

  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (define (assoc-set lst k v)
    (let loop ([lst lst])
      (cond [(null? lst) lst]
            [(eq? (caar lst) k) (cons (cons k v) (cdr lst))]
            [else (cons (car lst) (loop (cdr lst)))])))

  (define hints (make-hashtable))
  (define (hint-add! vreg rreg)
    (define rreg* (and rreg (canonicalize-register rset rreg)))
    (when rreg*
      (if (hashtable-contains? hints vreg)
          (hashtable-set! hints vreg (cons rreg* (hashtable-ref hints vreg)))
          (hashtable-set! hints vreg (list rreg*)))))

  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (case (car instr)
        [(c-call)
         (define target (cadr instr))
         (define args (cddr instr))
         (when (vreg? target)
           (hint-add! target '%ret))
         (let loop2 ([args args] [k 0])
           (unless (null? args)
             (when (vreg? (car args))
               (hint-add! (car args) (arg-register k)))
             (loop2 (cdr args) (+ k 1))))])
      (loop (cdr instrs))))

  hints)

(define (reg>? r1 r2)
    (let ([as1 (second r1)] [p1? (third r1)]
          [as2 (second r2)] [p2? (third r2)])
      (cond
        [(and (null? as1) (not (null? as2))) #t]
        [(and (not (null? as1)) (null? as2)) #f]
        [(and (not p1?) p2?) #t]
        [(and p1? (not p2?)) #f]
        [else #t])))

(define (apply-assign if-graph instrs rset vreg?)
  ; Sorts nodes in the interference graph by index
  ; `if-graph` maps `ni` to `(list rreg forw back)`
  (define (node>? n1 n2)
    (define v1 (hashtable-ref if-graph n1))
    (define v2 (hashtable-ref if-graph n2))
    (> (+ (length (second v1)) (length (third v1)))
       (+ (length (second v2)) (length (third v2)))))

  (define (connected-rregs conn)
    (filter (lambda (e) (cdr e))
            (map (lambda (r)
                   (define info (hashtable-ref if-graph r))
                   (cons r (and info (first info))))
                 conn)))

  (define allocable
    (sort (filter (lambda (elt) (not (fourth elt)))
                  (register-set-real rset))
          reg>?))

  (define (unassigned-rreg conflicts)
    (define c-rregs (map cdr conflicts))
    (define open (filter (lambda (elt) (not (member (first elt) c-rregs))) allocable))
    (and (not (null? open)) (first (car open))))

  ; Sort graph and compute hints
  (define ordered-vregs (sort (hashtable-keys if-graph) node>?))
  (define hints (register-hints instrs rset vreg?))
  (define spills (make-set))

  ; Iteratively assign
  (for-each
    (lambda (vreg)
      (define info (hashtable-ref if-graph vreg))
      (define maybe-rreg (first info))
      (define connected (append (second info) (third info)))
      (cond
        [maybe-rreg
         (void)]
        [(hashtable-contains? hints vreg)
         (define rreg (first (hashtable-ref hints vreg)))
         (define conflicts
           (filter (lambda (c-info) (eq? rreg (cdr c-info)))
                   (connected-rregs connected)))
         (cond
           [(not (null? conflicts))
            (define bad-vreg (caar conflicts))
            ; (printf "CONFLICT: ~a ~a\n" bad-vreg conflicts)
            (set-add! spills bad-vreg)]
           [else
            (if-graph-set-rreg! if-graph vreg rreg)])]
        [else
         (define rreg (unassigned-rreg (connected-rregs connected)))
         (cond
           [(not rreg)
            ; (printf "SPILL: ~a ~a\n" vreg)]
            (set-add! spills vreg)]
           [else
            ;  (printf "~a => ~a\n" vreg rreg)
            (if-graph-set-rreg! if-graph vreg rreg)])]))
    ordered-vregs)

  spills)

(define (replace-vregs instrs if-graph rset vreg? rreg?)
  (define (replace-arg arg)
    (cond
      [(vreg? arg) (first (hashtable-ref if-graph arg))]
      [(rreg? arg) (canonicalize-register rset arg)]
      [else arg]))
  (map (lambda (i) (cons (car i) (map replace-arg (cdr i)))) instrs))

(define (apply-spill spill instrs first-uses alloc id)
  (define (instr-has-vreg? instr vreg)
    (ormap (lambda (arg) (eq? arg vreg)) instr))

  (define (replace-vreg instr vreg1 vreg2)
    (cons (car instr)
          (map (lambda (arg) (if (eq? arg vreg1) vreg2 arg))
               (cdr instr))))

  (define first-use+1 (+ (hashtable-ref first-uses spill) 1))
  (let loop ([instrs instrs] [k 0])
    (cond
      [(null? instrs)
       '()]
      [(< k first-use+1)
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))]
      [(= k first-use+1)
       (cons (list 'load (list 'local id) spill)
             (loop instrs (+ k 1)))]
      [(instr-has-vreg? (car instrs) spill)
       (define t-reg (register-allocator-new! alloc))
       (cons* (list 'load t-reg (list 'local id))
              (replace-vreg (car instrs) spill t-reg)
              (loop (cdr instrs) (+ k 1)))]
      [else
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))])))

(define (apply-callee-saved instrs rset)
  (define callee-saved
    (map car (filter (lambda (elt) (and (third elt) (not (fourth elt))))
                     (register-set-real rset))))

  (define callee-saved-used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (for-each (lambda (arg)
                  (when (member arg callee-saved)
                    (set-add! callee-saved-used arg)))
                (cdr instr))
      (loop (cdr instrs))))

  (define used-in-order
    (filter (lambda (r) (set-member? callee-saved-used r))
            callee-saved))
  
  (define init-instr (car instrs))
  (define rest-instrs (cdr instrs))
  (define prefix (map (lambda (r) (list 'push r)) used-in-order))
  (define suffix (map (lambda (r) (list 'pop r)) (reverse used-in-order)))

  (cons init-instr (append prefix rest-instrs suffix)))

(define (optimize instrs)
  (let loop ([instrs instrs])
    (cond
      [(null? instrs) '()]
      [else
       (define instr (first instrs))
       (case (first instr)
         [(load)
          ; load => remove self-assignment
          (define dst (second instr))
          (define src (third instr))
          (if (eq? dst src)
              (loop (cdr instrs))
              (cons instr (loop (cdr instrs))))]
         [else
          (cons instr (loop (cdr instrs)))])])))

;
; Top-level register assigner
;

(define (register-assign instrs alloc)
  (define rset (register-allocator-target-regs alloc))  
  (let loop ([instrs instrs] [spill-count 0])
    (define vregs (apply make-set (register-allocator-virtual-regs alloc)))
    ; (printf "asm> ~a\n" instrs)

    (define (rreg? reg)
      (and (symbol? reg) (register-allocator-real-register? alloc reg)))

    (define (vreg? reg)
      (and (symbol? reg) (set-member? vregs reg)))

    ; compute live ranges
    (define used-regs (compute-used-registers instrs vreg?))
    (define-values (first-uses last-uses) (compute-live-ranges instrs used-regs))

    ; convert to hashtables
    (define first-use-map (make-hashtable))
    (define last-use-map (make-hashtable))
    (for-each (lambda (r i) (hashtable-set! first-use-map r i)) used-regs first-uses)
    (for-each (lambda (r i) (hashtable-set! last-use-map r i)) used-regs last-uses)

    ; compute interference graph
    (define if-graph (make-if-graph first-use-map last-use-map))

    ; apply known and then color
    (apply-known if-graph instrs rset vreg?)
    (define spills (apply-assign if-graph instrs rset vreg?))
      
    ; (printf "~a\n" used-regs)
    ; (printf "~a\n" first-use-map)
    ; (printf "~a\n" last-use-map)
    ; (printf "~a\n" if-graph**)

    (cond
      [(set-empty? spills)
       (define assigned (replace-vregs instrs if-graph rset vreg? rreg?))
       (define with-stash (apply-callee-saved assigned rset))
       (optimize with-stash)]
      [else
       (let loop2 ([instrs instrs] [spills (set->list spills)] [i spill-count])
         (if (null? spills)
             (loop instrs i)
             (let ([instrs* (apply-spill (car spills) instrs first-use-map alloc i)])
               (loop2 instrs* (cdr spills) (+ i 1)))))])))

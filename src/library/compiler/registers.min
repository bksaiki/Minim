;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%fp %sp %env %ret))
(define argument-registers '(%arg0 %arg1 %arg2 %arg3 %arg4 %arg5))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real aliases)
  (opaque #t))

(define (canonicalize-register rset reg)
  (cond
    [(member reg (map car (register-set-real rset)))
     reg]
    [(member reg (map car (register-set-aliases rset)))
     (assoc reg (register-set-aliases rset))]
    [else
     (error 'canonicalize-register "not a register or register alias" reg)]))

(define (validate-register-set! rset)
  (define aliases (register-set-aliases rset))
  (for-each (lambda (r)
              (unless (assoc r aliases)
                (error 'validate-register-set! "missing required register" r)))
            required-registers)
  (let loop ([regs argument-registers] [supported? #t])
    (cond [(null? regs)
           (void)] 
          [(member (car regs) aliases)
           (unless supported?
             (error 'validate-register-set! "missing argument register, before" (car regs)))
           (loop (cdr regs) supported?)]
          [else
           (loop (cdr regs) #f)])))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             (let* ([registers
                     (append
                       (map (lambda (r a r?) (list r a r? #t))
                            rregs rregs-aliases rregs-reserved?)
                       (map (lambda (r a r?) (list r a r? #f))
                            aregs aregs-aliases aregs-reserved?))]
                    [aliases
                     (let loop ([registers registers] [alias-map '()])
                       (cond
                         [(null? registers) alias-map]
                         [else
                          (define reg (caar registers))
                          (define aliases (cadar registers))
                          (loop (cdr registers)
                                      (append (map (lambda (a) (cons a reg)) aliases)
                                              alias-map))]))]
                    [rset (make-register-set registers aliases)])
               (validate-register-set! rset)
               rset))))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs (mutable virtual-regs))
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset '())))))

(define (register-allocator-real-register? allocator r)
  (define rset (register-allocator-target-regs allocator))
  (or (assoc r (register-set-real rset))
      (assoc r (register-set-alias rset))))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (length vregs)))))
  (register-allocator-virtual-regs-set! allocator (cons name vregs))
  name)

;;
;;  Register assigner
;;

(define (sort-vreg-dict vregs dict)
  (map (lambda (r)
         (let ([v (assoc r dict)])
           (cons r v)))
       vregs))

; computes index of instruction of first use/init
(define (compute-first-use instrs unused reverse? vreg?)
  (let loop ([instrs instrs] [unused unused] [used '()] [i 0])
    (cond
      [(null? instrs) used]
      [else
       (let loop2 ([args (cdar instrs)] [unused unused] [used used])
         (cond
           [(null? args)
            (loop (cdr instrs) unused used (+ i 1))]
           [(and (vreg? (car args)) (member (car args) unused))
            (define idx (if reverse? (- (length instrs) 1) i))
            (loop2 (cdr args) (remove (car args) unused)
                   (cons (cons (car args) idx) used))]
           [else
            (loop2 (cdr args) unused used)]))])))

; compute the interference graph for virtual registers
; stored as an association list mapping vreg to info:
; `(list rreg forw back span))`
; - `rreg`: the real register assignment (`#f` if not assigned)
; - `forw`: all vregs that this register conflicts with
; - `back`: all vregs that conflict with this register
; - `span`: number of instructions spanned by this vreg
(define (make-if-graph first-uses last-uses)
  (define forward
    (map (lambda (elt)
           (define reg (car elt))
           (define first-use (assoc reg first-uses))
           (define last-use (assoc reg last-uses))
           (define conflicts
             (filter (lambda (elt)
                       (define reg2 (car elt))
                       (define first-use2 (cdr elt))
                       (and (not (eq? reg reg2))
                            (>= first-use2 first-use)
                            (< first-use2 last-use)))
                     first-uses))
           (cons reg (map car conflicts)))
         first-uses))

  (define both
    (map (lambda (elt)
           (define reg (car elt))
           (define forw-conflicts (cdr elt))
           (define first-use (assoc reg first-uses))
           (define last-use (assoc reg last-uses))

           (define back-conflicts
             (map car
                  (filter (lambda (elt)
                            (and (member reg (cdr elt))
                                 (not (member (car elt) forw-conflicts))))
                          forward)))

           (define span (- last-use first-use))

           (cons reg (list #f forw-conflicts back-conflicts span)))
         forward))

  both)

(define (if-graph-get if-graph vreg)
  (assoc vreg if-graph))

(define (if-graph-set if-graph vreg rreg)
  (cond
    [(null? if-graph)
     if-graph]
    [(eq? (caar if-graph) vreg)
     (cons (cons vreg (cons rreg (cddar if-graph))) (cdr if-graph))]
    [else
     (cons (car if-graph) (if-graph-set (cdr if-graph) vreg rreg))]))

(define (apply-known if-graph instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))
  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (let loop ([instrs instrs] [if-graph if-graph])
    (cond
        [(null? instrs) if-graph]
        [else
         (case (caar instrs)
           [(init)
            (let loop2 ([args (cdar instrs)] [i 0] [if-graph if-graph])
              (cond
                [(null? args)
                 (loop (cdr instrs) if-graph)]
                [(vreg? (car args))
                 (define vreg (car args))
                 (define reg (arg-register i))
                 (loop2 (cdr args) (+ i 1)
                        (if reg
                            (if-graph-set if-graph vreg (canonicalize-register rset reg))
                            if-graph))]
                [else
                 (loop2 (cdr args) (+ i 1) if-graph)]))]
           [else
            (loop (cdr instrs) if-graph)])])))

(define (register-hints instrs rset vreg?)
  (define aliases (map car (register-set-aliases rset)))
  (define arg-regs (filter (lambda (r) (member r aliases)) argument-registers))
  (define (arg-register i)
    (and (< i (length arg-regs))
         (list-ref arg-regs i)))

  (define (assoc-set lst k v)
    (let loop ([lst lst])
      (cond [(null? lst) lst]
            [(eq? (caar lst) k) (cons (cons k v) (cdr lst))]
            [else (cons (car lst) (loop (cdr lst)))])))

  (define (hint-add hints vreg rreg)
    (define rregs (assoc vreg hints))
    (cond [(not rregs) (cons (cons vreg (list rreg)) hints)]
          [(or (not rreg) (member rreg rregs)) hints]
          [else (assoc-set hints vreg (cons rreg rregs))]))

  (let loop ([instrs instrs] [hints '()])
    (cond
      [(null? instrs) hints]
      [else
       (case (caar instrs)
         [(c-call)
          (define target (cadar instrs))
          (define args (cddar instrs))
          (define hints*
            (if (vreg? target)
                (hint-add hints target '%res)
                hints))
          (let loop2 ([args args] [i 0] [hints hints])
            (cond
              [(null? args)
               (loop (cdr instrs) hints)]
              [(vreg? (car args))
               (loop2 (cdr args) (+ i 1)
                      (hint-add hints (car args)
                                (canonicalize-register rset (arg-register i))))]
              [else
               (loop2 (cdr args) (+ i 1) hints)]))]
         [else
          (loop (cdr instrs) hints)])])))

(define (apply-assign if-graph instrs rset vreg?)
  ; Sorts nodes in the interference graph by index
  ;  `ni` ::= `(cons vreg (list rreg forw back))`
  (define (node>? n1 n2)
    (let ([v1 (cdr n1)] [v2 (cdr n2)])
      (> (+ (length (second v1)) (length v1))
         (+ (length (second v2)) (length v2)))))

  (define (connected-rregs connected if-graph*)
    (filter identity
            (map (lambda (conn)
                   (define info
                     (or (if-graph-get if-graph conn) ; try newer first
                         (if-graph-get if-graph0 conn)))
                   (and info (first info)))
                 connected)))

  ; TODO: sort registers by priority
  (define allocable (filter (lambda (elt) (not (fourth elt))) (register-set-real rset)))
  (define (unassigned-rreg conflicts)
    (define open (filter (lambda (elt) (not (member (first elt) conflicts))) allocable))
    (and (not (null? open)) (first (car open))))

  ; Sort graph and compute hints
  (define if-graph0 if-graph)
  (define not-done (sort if-graph node>?))
  (define hints (register-hints instrs rset vreg?))
  (define conflicts '())

  (printf "hints: ~a\n" hints)

  ; Iteratively assign
  (let loop ([not-done not-done] [if-graph '()])
    (cond
      [(null? not-done) (values if-graph conflicts)]
      [else
       (define vreg (caar not-done))
       (define rreg (first (cdar not-done)))
       (define forw (second (cdar not-done)))
       (define back (third (cdar not-done)))
       ; first, check if we have a hint
       (define hint (assoc vreg hints))
       (define maybe-rreg
         (cond
           [hint (first hint)]
           [else
            (define conflicts (connected-rregs (append forw back) if-graph))
            (unassigned-rreg conflicts)]))
       ; second, check for conflicts
       (define conflict?
         (or (not maybe-rreg)
             (and hint (> (length hint) 1))
             (and rreg (not (eq? rreg maybe-rreg)))
             (ormap (lambda (conn-rreg) (eq? maybe-rreg conn-rreg))
                    (connected-rregs (append forw back) if-graph))))
       ; third, update
       (cond
         [conflict?
          (printf (if maybe-rreg "CONFLICT: ~a\n" "SPILL: ~a\n") vreg)
          (set! conflicts (cons vreg conflicts))
          (loop (cdr not-done) (cons (car not-done) if-graph))]
         [else
          (define if-graph* (if-graph-set (cons (car not-done) if-graph) vreg maybe-rreg))
          (loop (cdr not-done) if-graph*)])])))


(define (register-assign instrs alloc)
  (define rset (register-allocator-target-regs alloc))
  (define vregs (reverse (register-allocator-virtual-regs alloc)))

  (let loop ([vregs vregs] [spilled '()])
    (define (virtual-register? reg)
      (and (symbol? reg) (member reg vregs)))

    (define (real-register? reg)
      (and (symbol? reg) (register-allocator-real-register? allocator reg)))

    ; compute used registers with first/last uses
    (define-values (first-uses last-uses used-regs)
      (let* ([first-use (compute-first-use instrs vregs #f virtual-register?)]
            [last-use (compute-first-use (reverse instrs) vregs #t virtual-register?)]
            [used (map car (filter (lambda (elt) (cdr elt)) last-use))])
        (values (sort-vreg-dict used first-use)
                (sort-vreg-dict used last-use)
                used)))

    ; compute interference graph
    (define if-graph (make-if-graph first-uses last-uses))

    ; apply known and then color
    (define if-graph* (apply-known if-graph instrs rset virtual-register?))
    (define-values (if-graph** conflicts) (apply-assign if-graph* instrs rset virtual-register?))
      
    (printf "~a\n" used-regs)
    ; (printf "~a\n" first-uses)
    ; (printf "~a\n" last-uses)
    ; (printf "~a\n" use-spans)
    (printf "~a\n" if-graph**)

    (void)))


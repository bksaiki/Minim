;;;
;;; Compiler registers
;;;

(import "../base.min")
(export define-registers
        make-register-set
        validate-register-set!

        make-register-allocator
        register-allocator-real-register?
        register-allocator-virtual-register?
        register-allocator-new!

        register-assign)

(define required-registers '(%cc %sp %env %ret))
(define argument-registers '(%arg0 %arg1 %arg2 %arg3 %arg4 %arg5))

;;
;;  Machine-dependent register set
;;

(define-record-type register-set
  (fields real in-order aliases)
  (opaque #t))

(define (canonicalize-register rset reg)
  (define real-info (register-set-real rset))
  (define alias-map (register-set-aliases rset))
  (cond [(hashtable-contains? real-info reg) reg]
        [(hashtable-contains? alias-map reg) (hashtable-ref alias-map reg)]
        [else (error 'canonicalize-register "not a register or register alias" reg)]))

(define (register-total-order rset)
  (define reg-info (register-set-real rset))
  (lambda (r1 r2)
    (define r1-info (hashtable-ref reg-info r1))
    (define r2-info (hashtable-ref reg-info r2))
    (define as1 (first r1-info))
    (define as2 (first r2-info))
    (define p1? (second r1-info))
    (define p2? (second r2-info))
    (cond
      [(and (null? as1) (not (null? as2))) #t]
      [(and (not (null? as1)) (null? as2)) #f]
      [(and (not p1?) p2?) #t]
      [(and p1? (not p2?)) #f]
      [else #t])))

(define (validate-register-set! rset)
  (define alias-map (register-set-aliases rset))
  ; all required registers are included
  (for-each (lambda (r)
              (unless (hashtable-contains? alias-map r)
                (error 'validate-register-set! "missing required register" r)))
            required-registers)
  ; subset of argument registers are not disconnected
  (let loop ([regs argument-registers] [supported? #t])
    (unless (null? regs)
      (cond
        [(hashtable-contains? alias-map (car regs))
         (unless supported?
           (error 'validate-register-set!
                  "missing argument register, before"
                  (car regs)))
         (loop (cdr regs) supported?)]
        [else
         (loop (cdr regs) #f)]))))

(define-syntax (define-registers stx)
  (syntax-case stx (reserved allocable)
    [(_ id (reserved [rreg-alias ... rreg rreg-reserved?] ...)
           (allocable [areg-alias ... areg areg-reserved?] ...))
     (begin
       (unless (identifier? #'id)
         (syntax-error 'define-enumeration "bad syntax" stx #'id))
       #'(define id
           (let ([rregs '(rreg ...)]
                 [rregs-aliases '((rreg-alias ...) ...)]
                 [rregs-reserved? '(rreg-reserved? ...)]
                 [aregs '(areg ...)]
                 [aregs-aliases '((areg-alias ...) ...)]
                 [aregs-reserved? '(areg-reserved? ...)])
             ; build the register info and register alias table
             (define reg-info (make-hashtable))
             (define alias-map (make-hashtable))
             (define in-order (append rregs aregs))
             (for-each (lambda (r a r?) (hashtable-set! reg-info r (list a r? #t)))
                       rregs rregs-aliases rregs-reserved?)
             (for-each (lambda (r a r?) (hashtable-set! reg-info r (list a r? #f)))
                       aregs aregs-aliases aregs-reserved?)
             (for-each (lambda (r)
                         (define aliases (first (hashtable-ref reg-info r)))
                         (for-each (lambda (a) (hashtable-set! alias-map a r))
                                   aliases))
                       in-order)
             ; validate and return
             (define rset (make-register-set reg-info in-order alias-map))
             (validate-register-set! rset)
             rset)))]
    [(_ . _)
     (syntax-error 'define-registers "bad syntax" stx)]))

;;
;;  Register allocator
;;

(define-record-type register-allocator
  (fields target-regs virtual-regs)
  (opaque #t)
  (protocol
    (lambda (p)
      (lambda (rset)
        (p rset (make-set))))))

(define (register-allocator-real-register? allocator reg)
  (define rset (register-allocator-target-regs allocator))
  (or (hashtable-contains? (register-set-real rset) reg)
      (hashtable-contains? (register-set-aliases rset) reg)))

(define (register-allocator-virtual-register? allocator r)
  (define vregs (register-allocator-virtual-regs allocator))
  (set-member? vregs r))

(define (register-allocator-new! allocator)
  (define vregs (register-allocator-virtual-regs allocator))
  (define name (string->symbol (string-append "%t" (number->string (set-count vregs)))))
  (set-add! vregs name)
  name)

;;
;;  Register assigner
;;

(define (compute-used-registers instrs vreg?)
  (define used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (when (vreg? (car args))
            (set-add! used (car args)))
          (loop2 (cdr args))))
      (loop (cdr instrs))))
  (set->list used))

(define (compute-live-ranges instrs used)
  (define first (make-vector (length used) #f))
  (define last (make-vector (length used) #f))
  (let loop ([instrs instrs] [i 0])
    (unless (null? instrs)
      (let loop2 ([args (cdar instrs)])
        (unless (null? args)
          (define idx (index-of (car args) used))
          (when idx
            (unless (vector-ref first idx)
              (vector-set! first idx i))
            (vector-set! last idx i))
          (loop2 (cdr args))))
      (loop (cdr instrs) (+ i 1))))
  (values (vector->list first)
          (vector->list last)))

; compute the interference graph for virtual registers
; stored as an association list mapping vreg to info:
; `(list rreg forw back span))`
; - `rreg`: the real register assignment (`#f` if not assigned)
; - `forw`: all vregs that this register conflicts with
; - `back`: all vregs that conflict with this register
; - `span`: number of instructions spanned by this vreg
(define (make-if-graph first-uses last-uses)
  (define regs (hashtable-keys first-uses))
  (define forward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (>= (hashtable-ref first-uses r2) first)
                          (< (hashtable-ref first-uses r2) last)))
                   regs))
         regs))
  (define backward
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (filter (lambda (r2)
                     (and (not (eq? r r2))
                          (< (hashtable-ref first-uses r2) first)
                          (>= (hashtable-ref last-uses r2) first)))
                   regs))
         regs))
  (define spans
    (map (lambda (r)
           (define first (hashtable-ref first-uses r))
           (define last (hashtable-ref last-uses r))
           (- last first))
         regs))

  (define if-graph (make-hashtable))
  (for-each (lambda (r f b s)
              (hashtable-set! if-graph r (list #f f b s)))
            regs forward backward spans)
  if-graph)

(define (if-graph-set-rreg! if-graph vreg rreg)
  (define info (hashtable-ref if-graph vreg))
  (hashtable-set! if-graph vreg (cons rreg (cdr info))))

(define (apply-known if-graph instrs rset vreg?)
  (define alias-map (register-set-aliases rset))
  (define arg-regs
    (list->vector
      (filter (lambda (r) (hashtable-contains? alias-map r))
              argument-registers)))

  (define (arg-register i)
    (and (< i (vector-length arg-regs))
         (vector-ref arg-regs i)))

  (for-each
    (lambda (instr)
      (case (car instr)
        [(init)
         (let loop ([args (cdr instr)] [i 0])
           (unless (null? args)
             (when (vreg? (car args))
               (define reg (canonicalize-register rset (arg-register i)))
               (if-graph-set-rreg! if-graph (car args) reg))
             (loop (cdr args) (+ i 1))))]))
    instrs))


(define (register-hints instrs rset vreg?)
  (define alias-map (register-set-aliases rset))
  (define arg-regs
    (list->vector
      (filter (lambda (r) (hashtable-contains? alias-map r))
              argument-registers)))

  (define (arg-register i)
    (and (< i (vector-length arg-regs))
         (vector-ref arg-regs i)))

  (define hints (make-hashtable))
  (define (hint-add! vreg rreg)
    (define rreg* (and rreg (canonicalize-register rset rreg)))
    (when rreg*
      (if (hashtable-contains? hints vreg)
          (hashtable-set! hints vreg (cons rreg* (hashtable-ref hints vreg)))
          (hashtable-set! hints vreg (list rreg*)))))

  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (case (car instr)
        [(c-call)
         (define target (cadr instr))
         (define args (cddr instr))
         (when (vreg? target)
           (hint-add! target '%ret))
         (let loop2 ([args args] [k 0])
           (unless (null? args)
             (when (vreg? (car args))
               (hint-add! (car args) (arg-register k)))
             (loop2 (cdr args) (+ k 1))))])
      (loop (cdr instrs))))

  hints)

(define (apply-assign if-graph instrs rset vreg?)
  ; Sorts nodes in the interference graph by index
  ; `if-graph` maps `ni` to `(list rreg forw back)`
  (define (node>? n1 n2)
    (define v1 (hashtable-ref if-graph n1))
    (define v2 (hashtable-ref if-graph n2))
    (> (+ (length (second v1)) (length (third v1)))
       (+ (length (second v2)) (length (third v2)))))

  (define (connected-rregs conn)
    (filter (lambda (e) (cdr e))
            (map (lambda (r)
                   (define info (hashtable-ref if-graph r))
                   (cons r (and info (first info))))
                 conn)))

  (define reg-info (register-set-real rset))
  (define allocable
    (sort (filter (lambda (r) (not (third (hashtable-ref reg-info r))))
                  (register-set-in-order rset))
          (register-total-order rset)))

  (define (unassigned-rreg conflicts)
    (define c-rregs (apply make-set (map cdr conflicts)))
    (define open (filter (lambda (reg) (not (set-member? c-rregs reg))) allocable))
    (and (not (null? open)) (first open)))

  ; Sort graph and compute hints
  (define ordered-vregs (sort (hashtable-keys if-graph) node>?))
  (define hints (register-hints instrs rset vreg?))
  (define spills (make-set))

  ; Iteratively assign
  (for-each
    (lambda (vreg)
      (define info (hashtable-ref if-graph vreg))
      (define maybe-rreg (first info))
      (define connected (append (second info) (third info)))
      (cond
        [maybe-rreg
         (void)]
        [(hashtable-contains? hints vreg)
         (define rreg (first (hashtable-ref hints vreg)))
         (define conflicts
           (filter (lambda (c-info) (eq? rreg (cdr c-info)))
                   (connected-rregs connected)))
         (cond
           [(not (null? conflicts))
            (define bad-vreg (caar conflicts))
            ; (printf "CONFLICT: ~a ~a\n" bad-vreg conflicts)
            (set-add! spills bad-vreg)]
           [else
            (if-graph-set-rreg! if-graph vreg rreg)])]
        [else
         (define rreg (unassigned-rreg (connected-rregs connected)))
         (cond
           [(not rreg)
            ; (printf "SPILL: ~a ~a\n" vreg)]
            (set-add! spills vreg)]
           [else
            ;  (printf "~a => ~a\n" vreg rreg)
            (if-graph-set-rreg! if-graph vreg rreg)])]))
    ordered-vregs)

  spills)

(define (replace-vregs instrs if-graph rset vreg? rreg?)
  (define (replace-arg arg)
    (cond
      [(vreg? arg) (first (hashtable-ref if-graph arg))]
      [(rreg? arg) (canonicalize-register rset arg)]
      [else arg]))
  (map (lambda (i) (cons (car i) (map replace-arg (cdr i)))) instrs))

(define (apply-spill spill instrs first-uses alloc id)
  (define (instr-has-vreg? instr vreg)
    (ormap (lambda (arg) (eq? arg vreg)) instr))

  (define (replace-vreg instr vreg1 vreg2)
    (cons (car instr)
          (map (lambda (arg) (if (eq? arg vreg1) vreg2 arg))
               (cdr instr))))

  (define first-use+1 (+ (hashtable-ref first-uses spill) 1))
  (let loop ([instrs instrs] [k 0])
    (cond
      [(null? instrs)
       '()]
      [(< k first-use+1)
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))]
      [(= k first-use+1)
       (cons (list 'load (list 'local id) spill)
             (loop instrs (+ k 1)))]
      [(instr-has-vreg? (car instrs) spill)
       (define t-reg (register-allocator-new! alloc))
       (cons* (list 'load t-reg (list 'local id))
              (replace-vreg (car instrs) spill t-reg)
              (loop (cdr instrs) (+ k 1)))]
      [else
       (cons (car instrs) (loop (cdr instrs) (+ k 1)))])))

(define (apply-callee-saved instrs rset)
  (define reg-info (register-set-real rset))
  (define callee-saved (make-set))
  (for-each (lambda (reg)
              (define info (hashtable-ref reg-info reg))
              (when (and (second info) (not (third info)))
                (set-add! callee-saved reg)))
            (hashtable-keys reg-info))

  (define callee-saved-used (make-set))
  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define instr (car instrs))
      (for-each (lambda (arg)
                  (when (set-member? callee-saved arg)
                    (set-add! callee-saved-used arg)))
                (cdr instr))
      (loop (cdr instrs))))

  (define reg>? (register-total-order rset))
  (define used-in-order
    (filter (lambda (r) (set-member? callee-saved-used r))
            (sort (set->list callee-saved) reg>?)))
  
  (define init-instr (car instrs))
  (define rest-instrs (cdr instrs))
  (define prefix (map (lambda (r) (list 'push r)) used-in-order))
  (define suffix (map (lambda (r) (list 'pop r)) (reverse used-in-order)))

  (cons init-instr (append prefix rest-instrs suffix)))

(define (optimize instrs)
  (let loop ([instrs instrs])
    (cond
      [(null? instrs) '()]
      [else
       (define instr (first instrs))
       (case (first instr)
         [(load)
          ; load => remove self-assignment
          (define dst (second instr))
          (define src (third instr))
          (if (eq? dst src)
              (loop (cdr instrs))
              (cons instr (loop (cdr instrs))))]
         [else
          (cons instr (loop (cdr instrs)))])])))

;
; Top-level register assigner
;

(define (register-assign instrs alloc)
  (define rset (register-allocator-target-regs alloc))  
  (let loop ([instrs instrs] [spill-count 0])
    (define vregs (register-allocator-virtual-regs alloc))
    ; (printf "asm> ~a\n" instrs)

    (define (rreg? reg)
      (and (symbol? reg) (register-allocator-real-register? alloc reg)))

    (define (vreg? reg)
      (and (symbol? reg) (set-member? vregs reg)))

    ; compute live ranges
    (define used-regs (compute-used-registers instrs vreg?))
    (define-values (first-uses last-uses) (compute-live-ranges instrs used-regs))

    ; convert to hashtables
    (define first-use-map (make-hashtable))
    (define last-use-map (make-hashtable))
    (for-each (lambda (r i) (hashtable-set! first-use-map r i)) used-regs first-uses)
    (for-each (lambda (r i) (hashtable-set! last-use-map r i)) used-regs last-uses)

    ; compute interference graph
    (define if-graph (make-if-graph first-use-map last-use-map))

    ; apply known and then color
    (apply-known if-graph instrs rset vreg?)
    (define spills (apply-assign if-graph instrs rset vreg?))
      
    ; (printf "~a\n" used-regs)
    ; (printf "~a\n" first-use-map)
    ; (printf "~a\n" last-use-map)
    ; (printf "~a\n" if-graph**)

    (cond
      [(set-empty? spills)
       (define assigned (replace-vregs instrs if-graph rset vreg? rreg?))
       (define with-stash (apply-callee-saved assigned rset))
       (optimize with-stash)]
      [else
       (let loop2 ([instrs instrs] [spills (set->list spills)] [i spill-count])
         (if (null? spills)
             (loop instrs i)
             (let ([instrs* (apply-spill (car spills) instrs first-use-map alloc i)])
               (loop2 instrs* (cdr spills) (+ i 1)))))])))

;;;
;;; x86-64 specific definitions
;;;

(import "../base.min" "common.min" "registers.min")
(export assemble/x86-64 link/x86-64 x86-64-registers)

;
; Constants
;

(define ALIGNMENT 16)

(define-registers x86-64-registers
  (reserved
    [%cc          %rbp #t]
    [%sp          %rsp #t]
    [%env         %r14 #t]
    [%ret         %rax #f])   ; TODO: allocate %ret
  (allocable
    [%arg0        %rdi #f]
    [%arg1        %rsi #f]
    [%arg2        %rdx #f]
    [%arg3        %rcx #f]
    [%arg4        %r8  #f]
    [%arg5        %r9  #f]
    [             %r10 #f]
    [             %r11 #f]
    [             %r12 #t]
    [             %r13 #t]
    [             %r15 #t]))

;
; Utilities
;

; Creates a positive integer with the corresponding bits
(define (bits . xs)
  (let loop ([xs xs] [r 0])
    (cond [(null? xs) r]
          [else (loop (cdr xs) (+ (* 2 r) (if (car xs) 1 0)))])))

(define-values (decompose/imm64 decompose/imm32 decompose/imm16)
  (begin
    (define (decompose/immN n)
      (lambda (i)
        (let loop ([i i] [k 0] [bits '()])
          (cond
            [(= k n)
             (reverse bits)]
            [else
             (define bit (remainder i 256))
             ; TODO: (loop (floor (/ i 256)) (+ k 1) (cons bit bits))
             (loop (/ i 256) (+ k 1) (cons bit bits))]))))

    (values (decompose/immN 8) (decompose/immN 4) (decompose/immN 2))))

; Creates the REX prefix of an instruction
(define (rex-prefix w r x b)
  (+ 64 (bits w r x b)))

; Creates a MODR/M byte of an instruction
(define (encode/modrm mod reg r/m)
  (+ (* 64 mod) (* 8 reg) r/m))

; Creates a IO byte of an instruction
(define (encode/io op reg)
  (+ op reg))

; Register -> X.RRR
(define (register/code reg)
  (case reg
    [(%rax)   (values #f 0)]
    [(%rcx)   (values #f 1)]
    [(%rdx)   (values #f 2)]
    [(%rbx)   (values #f 3)]
    [(%rsp)   (values #f 4)]
    [(%rbp)   (values #f 5)]
    [(%rsi)   (values #f 6)]
    [(%rdi)   (values #f 7)]

    [(%r8)    (values #t 0)]
    [(%r9)    (values #t 1)]
    [(%r10)   (values #t 2)]
    [(%r11)   (values #t 3)]
    [(%r12)   (values #t 4)]
    [(%r13)   (values #t 5)]
    [(%r14)   (values #t 6)]
    [(%r15)   (values #t 7)]

    [else    (error 'register/code "unknown register" reg)]))

(define (argument/register i)
  (case i
    [(0)  '%rdi ]
    [(1)  '%rsi ]
    [(2)  '%rdx ]
    [(3)  '%rcx ]
    [(4)  '%r8  ]
    [(5)  '%r9  ]
    [else (error 'argument/register "unimplemeneted")]))

;
; Instruction encoding
;

; mov <dst>, <imm64>
(define (instr/load-imm64 dst imm)
  (define-values (b reg) (register/code dst))
  (define imm-bits (decompose/imm64 imm))
  (define rex (rex-prefix #t #f #f b))
  (cons rex (cons (encode/io #xb8 reg) imm-bits)))

; mov <dst>, <src>
(define (instr/load dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x89 (encode/modrm 3 reg r/m)))

; mov [<dst>+imm], <src>
(define (instr/store-at-offset32 dst src offset)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #f r #f b))
  (cond
    [(and (<= 0 offset) (< offset 128))
     (list rex #x89 (encode/modrm 1 reg r/m) offset)]
    [(and (<= (- 128) offset) (< offset 0))
     (list rex #x89 (encode/modrm 1 reg r/m) (+ 256 offset))]
    [else
     (error 'instr/store-at-offset "unimplemented offset" offset)]))

; mov [<dst>+imm], <src>
(define (instr/store-at-offset dst src offset)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (cond
    [(and (<= 0 offset) (< offset 128))
     (list rex #x89 (encode/modrm 1 reg r/m) offset)]
    [(and (<= (- 128) offset) (< offset 0))
     (list rex #x89 (encode/modrm 1 reg r/m) (+ 256 offset))]
    [else
     (error 'instr/store-at-offset "unimplemented offset" offset)]))

; mov <dst>, [<src>+imm]
(define (instr/load-from-offset dst src offset)
  (define-values (b r/m) (register/code src))
  (define-values (r reg) (register/code dst))
  (define rex (rex-prefix #t r #f b))
  (cond
    [(and (<= 0 offset) (< offset 128))
     (list rex #x8b (encode/modrm 1 reg r/m) offset)]
    [(and (<= (- 128) offset) (< offset 0))
     (list rex #x8b (encode/modrm 1 reg r/m) (+ 256 offset))]
    [else
     (error 'instr/load-from-offset "unimplemented offset" offset)]))

; push <imm>
(define (instr/push-imm imm)
  (cond
    [(<= 0 imm 255)
     (list #x6a imm)]
    [else
     (error 'instr/push-imm "unimplemented" imm)]))

; push <src>
(define (instr/push src)
  (define-values (b reg) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (define io (encode/io #x50 reg))
  (if b (list rex io) (list io)))

; pop <src>
(define (instr/pop src)
  (define-values (b reg) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (define io (encode/io #x58 reg))
  (if b (list rex io) (list io)))

; add <dst> <imm>
(define (instr/add-imm dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (cond
    [(<= 0 imm 255)
     (list rex #x83 (encode/io #xc0 reg) imm)]
    [else
     (error 'instr/add-imm "unimplemented" imm)]))

; add <dst> <sub>
(define (instr/add dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x01 (encode/modrm 3 reg r/m)))

; sub <dst> <imm>
(define (instr/sub-imm dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (cond
    [(<= 0 imm 255)
     (list rex #x83 (encode/io #xe8 reg) imm)]
    [else
     (error 'instr/sub-imm "unimplemented" imm)]))

; sub <dst> <sub>
(define (instr/sub dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x29 (encode/modrm 3 reg r/m)))

; shl <dst> <imm>
(define (instr/shl-imm dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (cond
    [(<= 0 imm 64)
     (list rex #xc1 (encode/io #xe0 reg) imm)]
    [else
     (error 'instr/shl-imm "invalid shift amount" imm)]))

; cmp <src:32> <imm>
(define (instr/cmp32-imm src imm)
  (define-values (b r/m) (register/code src))
  (cond
    [b
     ; override-size override required
     (define rex (rex-prefix #f #f #f b))
     (list #x66 rex #x83 (encode/modrm 3 #x7 r/m) imm)]
    [(<= 0 imm 255)
     (list #x83 (encode/modrm 3 #x7 r/m) imm)]
    [else
     (error 'instr/cmp32-imm "unimplemented" imm)]))

; cmp <src1:64> <src2:64>
(define (instr/cmp64 src1 src2)
  (define-values (b r/m) (register/code src1))
  (define-values (r reg) (register/code src2))
  (list (rex-prefix #t r #f b) #x39 (encode/modrm 3 reg r/m)))

; call <reg>
(define (instr/call src)
  (define-values (b r/m) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (if b
      (list rex #xff (encode/modrm 3 2 r/m))
      (list #xff (encode/modrm 3 2 r/m))))

; jmp <imm> (near, relative, 32-bit displacement)
(define (instr/jmp-imm32 imm)
  (define imm-bits (decompose/imm32 imm))
  (cond
    [(>= imm 0) (cons #xe9 imm-bits)]
    [else       (error 'instr/jmp "negative displacement not supported" imm)]))

; je <imm> (near, relative, 32-bit displacement)
(define (instr/je-imm32 imm)
  (define imm-bits (decompose/imm32 imm))
  (cond
    [(>= imm 0) (cons #x0f (cons #x84 imm-bits))]
    [else       (error 'instr/jmp "negative displacement not supported" imm)]))

; ret
(define (instr/ret)
  (list #xc3))

; leave
(define (instr/leave)
  (list #xc9))

; endbr64
(define (instr/endbr)
  (list #xf3 #x0f #x1e #xfa))

;
; Link
;

(define (link/labels proc0 links)
  (define loc->label (make-hashtable))
  (for-each
    (lambda (l)
      (when (eq? (caar l) 'label)
        (define name (cadar l))
        (define loc (cadr l))
        (hashtable-update! loc->label loc
                           (lambda (names)
                             (if (member name names)
                                 names
                                 (cons name names)))
                           (list name))))
    links)

  (define idx->offset (make-hashtable))
  (let loop ([proc proc0] [i 0] [offset 0])
    (unless (null? proc)
      (hashtable-set! idx->offset i offset)
      (loop (cdr proc) (+ i 1) (+ offset (length (car proc))))))

  (define loc->offset (make-hashtable))
  (for-each
    (lambda (k) (hashtable-set! loc->offset k (hashtable-ref idx->offset k)))
    (hashtable-keys loc->label))

  (let loop ([dict '()] [keys (hashtable-keys loc->label)])
    (cond
      [(null? keys) dict]
      [else
       (define names (hashtable-ref loc->label (car keys)))
       (define offset (hashtable-ref loc->offset (car keys)))
       (let loop2 ([dict dict] [names names])
         (cond
           [(null? names) (loop dict (cdr keys))]
           [else (loop2 (cons (cons (car names) offset) dict) (cdr names))]))])))


(define (link/x86-64 proc links info)
  (define label-locs (link/labels proc links))

  (define (replace/top proc0 link)
    (define type (car link))
    (define location (cdr link))
    (let loop ([proc proc0] [offset 0] [idx (car location)])
      (cond
        [(> idx 0)
         (cons (car proc) (loop (cdr proc) (+ offset (length (car proc))) (- idx 1)))]
        [else
         (define rest (cdr location))
         (cons (replace/recur (car proc) type offset (car rest) (cdr rest)) (cdr proc))])))

  (define (replace/recur proc0 type offset idx rest)
    (let loop ([proc proc0] [idx idx] [rest rest])
      (cond
        [(> idx 0)
          (cons (car proc) (loop (cdr proc) (- idx 1) rest))]
        [(null? rest)
          (case (first type)
            [(literal)
             (define addr (assoc 'literal info))
             (decompose/imm64 (+ addr (* WORD-SIZE (second type))))]
            [(procedure)
             (define addr (assoc type info))
             (decompose/imm64 addr)]
            [(runtime)
             (decompose/imm64 (runtime-address (second type)))]
            [(jump)
             (define label-offset (assoc (second type) label-locs))
             (define offset (- label-offset offset (length proc0)))
             (decompose/imm32 offset)]
            [else
             (error 'link/x86-64 "unknown link type" type)])]
        [else
          (cons (loop (car proc) (car rest) (cdr rest)) (cdr proc))])))

  (let loop ([proc proc] [links links])
    (cond
      [(null? links) proc]
      [(eq? (caaar links) 'label) (loop proc (cdr links))]
      [else (loop (replace/top proc (car links)) (cdr links))])))

;
; Frame info
;

;
; |         ...         |
; |=====================|
; |    Return Address   |
; |---------------------|
; |      Saved FP       |
; |---------------------| %sp 
; |        Arg m        |
; |---------------------|
; |         ...         |
; |---------------------|
; |        Arg 0        |
; |---------------------|
; |       Local 0       |
; |---------------------|
; |         ...         |
; |---------------------|
; |       Local n       |
; |---------------------|
; |    Padding (0/8)    |
; |=====================| %fp
; |         ...         |
;

(define-record-type frame
  (fields (mutable argc) (mutable locals) (mutable idx) prev)
  (opaque #t))

(define (make-starting-frame argc)
  (make-frame argc '() 3 #f))

(define (extend-frame prev idx)
  (make-frame 0 '() idx prev))

(define (frame-reserve-args! frame argc)
  (frame-argc-set! frame argc))

; Adds a named local memory location
; Returns the index within the frame of the new location
; Named locations will never be reclaimed
(define (frame-set-local! frame label)
  (define locals (frame-locals frame))
  (define idx (index-of #f (reverse locals)))
  (cond
    [idx  ; open space, update the set of locals
     (frame-locals-set! frame (reverse (list-set (reverse locals) idx label)))
     (+ (frame-argc frame) (+ idx 1))]
    [else ; need to reserve more space
     (frame-locals-set! frame (cons label locals))
     (+ (frame-argc frame) (length (frame-locals frame)))]))

; Gives the offset of a named local memory location in words
(define (frame-get-local frame label)
  (let loop ([frame frame] [offset 0])
    (cond
      [(member label (frame-locals frame))
       (define locals (frame-locals frame))
       (define idx (index-of label locals))
       (+ offset (frame-argc frame) (- (length locals) idx))]
      [else
       (unless (frame-prev frame)
         (error 'frame-get-local! "could not find local" label))
       (define prev (frame-prev frame))
       (define adj-size (+ (* 2 WORD-SIZE) (frame-size prev)))
       (loop prev (- offset adj-size))])))

; Adds an unnamed local memory location
; Returns the index within the frame of the new location
(define (frame-push-local! frame)
  (frame-set-local! frame #t))

; Removes the last memory location created
; using `frame-pop-local!`. Returns the index
; within the frame of the new location
(define (frame-pop-local! frame)
  (define locals (frame-locals frame))
  (define idx (index-of #t locals))
  (unless idx
    (error 'assemble/x86-64 "frame-pop-local!: frame size will be negative"))
  (frame-locals-set! frame (list-set locals idx #f))
  (+ (frame-argc frame) (- (length locals) idx)))

; Frame size ignoring return address and saved FP
(define (frame-size frame)
  (define words (+ (frame-argc frame) (length (frame-locals frame))))
  (define aligned (if (= (remainder words 2) 0) words (+ words 1)))
  (* WORD-SIZE aligned))

;
; Assembler
;

(define prefix (list (instr/endbr) (instr/push '%rbp) (instr/load '%rbp '%rsp)))
(define suffix (list (instr/leave) (instr/ret)))


(define (assemble/instr instr
                        get-assembled
                        link!
                        push-frame! pop-frame! frame)
  (case (first instr)
    [(load)
     ; mov <dst>, <src>
     (define dst (second instr))
     (define src (third instr))
     (cond
       [(number? (third instr))
        ; Imm => Reg
        (list (instr/load-imm64 dst src))]
       [(and (symbol? src) (symbol? dst))
        ; Reg => Reg
        (list (instr/load dst src))]
       [(and (symbol? src) (list? dst) (eq? (car dst) 'local))
        ; Reg => Mem
        (define label (second dst))
        (define offset (frame-set-local! frame label))
        (define byte-offset (- (* WORD-SIZE offset)))
        (list (instr/store-at-offset '%rbp src byte-offset))]
       [(and (list? src) (eq? (car src) 'local) (symbol? dst))
        ; Mem => Reg
        (define label (second src))
        (define offset (frame-get-local frame label))
        (define byte-offset (- (* WORD-SIZE offset)))
        (list (instr/load-from-offset dst '%rbp byte-offset))]
       [else
        ; bad
        (error 'assemble/instr "unknown load type" instr)])]
    [(load-offset)
     ; mov <dst> [<src>+<offset>]
     (define dst (second instr))
     (define src (third instr))
     (define offset (fourth instr))
     (list (instr/load-from-offset dst src offset))]
    [(store-offset)
     ; mov <dst> [<src>+<offset>]
     (define src (second instr))
     (define dst (third instr))
     (define offset (fourth instr))
     (list (instr/store-at-offset dst src offset))]
    [(store-offset32)
     ; mov <dst> [<src>+<offset>]
     (define src (second instr))
     (define dst (third instr))
     (define offset (fourth instr))
     (list (instr/store-at-offset32 dst src offset))]
    [(load-literal)
     ; mov <dst>, <literal address> => 48 b8 [xx]^8
     ; mov <dst>, [<dst>] => 48 8b 00
     (define dst (second instr))
     (define addr (third instr))
     (link! (list 'literal addr) (list (length (get-assembled)) 2))
     (list (instr/load-imm64 dst 0)
           (instr/load-from-offset dst dst 0))]
    [(load-procedure)
     ; mov <dst>, <procedure address> => 48 b8 [xx]^8
     (define dst (second instr))
     (define addr (third instr))
     (link! (list 'procedure addr) (list (length (get-assembled)) 2))
     (list (instr/load-imm64 dst 0))]
    [(load-address)
     ; mov <dst>, <address> => 48 b8 [xx]^8
     (define dst (second instr))
     (define addr (third instr))
     (link! (list 'runtime addr) (list (length (get-assembled)) 2))
     (list (instr/load-imm64 dst 0))]
    [(store-argument)
     ; Stores result at ith argument position
     ; The area directly above `rbp` is the argument stack
     ; Note that the argument stack is reverse so 0 is last
     ; mov [rbp-<offset>], <src>
     (define src (second instr))
     (define offset (* (+ 1 (third instr)) WORD-SIZE))
     (list (instr/store-at-offset '%rbp src (- offset)))]
    [(add)
     (define dst (second instr))
     (define src0 (third instr))
     (define src1 (fourth instr))
     (cond
       [(symbol? src1)
        (cond
          [(eq? dst src0)
           ; x64-style
           (list (instr/add dst src1))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (list (instr/load dst src0) (instr/add dst src1))])]
       [else
        (cond
          [(eq? dst src0)
           ; x64-style
           (list (instr/add-imm dst src1))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (list (instr/load dst src0) (instr/add-imm dst src1))])])]
    [(sub)
     (define dst (second instr))
     (define src0 (third instr))
     (define src1 (fourth instr))
     (cond
       [(symbol? src1)
        (cond
          [(eq? dst src0)
           ; x64-style
           (list (instr/sub dst src1))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (list (instr/load dst src0) (instr/sub dst src1))])]
       [else
        (cond
          [(eq? dst src0)
           ; x64-style
           (list (instr/sub-imm dst src1))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (list (instr/load dst src0) (instr/sub-imm dst src1))])])]
    [(shl)
     (define dst (second instr))
     (define src0 (third instr))
     (define src1 (fourth instr))
     (cond
       [(symbol? src1)
        (error 'assemble/x86-64 "unimplemented" instr)]
       [else
        (cond
          [(eq? dst src0)
           ; x64-style
           (list (instr/shl-imm dst src1))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (list (instr/load dst src0) (instr/shl-imm dst src1))])])]
    [(push-frame)
     ; make new continuation frame
     ; similar to calling convention
     ;  - push label address and BP (do manually to ensure alignment)
     ;  - move BP to SP
     (define label (second instr)) ; TODO handle label
     (push-frame! (+ (length (get-assembled)) 3))
     (list
       (instr/push-imm 0)
       (instr/push '%rbp)
       (instr/load '%rbp '%rsp)
       (instr/sub-imm '%rsp 0))]
    [(prepare-args)
     ; hint for the frame size
     (frame-reserve-args! frame (second instr))
     (list)]
    [(pop-frame)
     ; remove continuation frame
     ; just the reverse of `push_frame`
     (pop-frame!)
     (list
       (instr/load '%rsp '%rbp)
       (instr/pop '%rbp)
       (instr/add-imm '%rsp WORD-SIZE))]
    [(c-call)
     ; function call
     ; assumes registers are in the right place
     ; and do not require stashing
     (list (instr/call '%rax))]
    [(branch)
     ; branching
     (define label (second instr))
     (define mode (third instr))
     (case mode
       [(equal)
        (link! (list 'jump label) (list (length (get-assembled)) 2))
        (list (instr/je-imm32 0))]
       [(always)
        (link! (list 'jump label) (list (length (get-assembled)) 1))
        (list (instr/jmp-imm32 0))]
       [else
        (error 'assemble/x86-64 "branch mode unimplemented" instr)])]
    [(cmp-tag)
     ; comparing object tag for type information
     ; cmp <src:32>, <tag>
     (define src (second instr))
     (define tag (type-tag->integer (third instr)))
     (list (instr/cmp32-imm src tag))]
    [(cmp-ptr)
     ; comparing register-to-register
     ; cmp <src1:64>, <src2:64>
     (define src1 (second instr))
     (define src2 (third instr))
     (list (instr/cmp64 src1 src2))]
    [(push)
     ; really just a move
     (define offset (frame-push-local! frame))
     (define byte-offset (- (* WORD-SIZE offset)))
     (define src (second instr))
     (list (instr/store-at-offset '%rbp src byte-offset))]
    [(pop)
     ; really just a move
     (define offset (frame-pop-local! frame))
     (define byte-offset (- (* WORD-SIZE offset)))
     (define dst (second instr))
     (list (instr/load-from-offset dst '%rbp byte-offset))]
    [(label)
     ; label => just register name and location
     (link! (list 'label (second instr)) (list (length (get-assembled))))
     (list)]
    [(init)
     ; init => marker for register assignment
     (list)]
    [else
     (error 'assemble/x86-64 "unimplemented" instr)]))

(define (padding-length instrs)
  (let loop ([instrs instrs] [len 0])
    (cond
      [(null? instrs)
       (define r16 (remainder len 16))
       (if (= r16 0) 0 (- 16 r16))]
      [else (loop (cdr instrs) (+ len (length (car instrs))))])))

;
; Top-level assembler from generic assembly to x86-64
;

(define (assemble/x86-64 instrs alloc)
  (define asm-instrs '())
  (define links '())
  (define frame (make-starting-frame 0))

  (define (make-link! key loc)
    (set! links (cons (cons key loc) links)))

  (define (adjust-links! start by)
    (set! links
      (let loop ([links links] [links* '()])
        (cond
          [(null? links)
           (reverse links*)]
          [(>= (cadar links) start)
           (define loc* (cons (+ (cadar links) by) (cddar links)))
           (loop (cdr links) (cons (cons (caar links) loc*) links*))]
          [else
           (loop (cdr links) (cons (car links) links*))]))))

  (define (adjust-frame! frame)
    (define instr-idx (frame-idx frame))
    (define fsize (frame-size frame))

    (set! asm-instrs
      (reverse 
        (let loop ([instrs (reverse asm-instrs)] [i 0] [instrs* '()])
          (cond
            [(null? instrs)
             (error 'adjust-frame!
                    "instruction sequence not long enough"
                    instr-idx asm-instrs)]
            [(= i instr-idx)
             (define instr-len (length (car instrs)))
             (cond
               [(= fsize 0)
                (adjust-links! i (- 1))
                (append (reverse instrs*) (cdr instrs))]
               [else
                (define reserve (instr/sub-imm '%rsp fsize))
                (append (reverse instrs*) (cons reserve (cdr instrs)))])]
            [else
             (loop (cdr instrs) (+ i 1) (cons (car instrs) instrs*))])))))

  (define (push-frame! idx)
    (set! frame (extend-frame frame idx)))

  (define (pop-frame!)
    (adjust-frame! frame)
    (set! frame (frame-prev frame)))

  (set! asm-instrs (cons (instr/sub-imm '%rsp 0) (reverse prefix)))

  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define next
        (assemble/instr (car instrs)
                        (lambda _ asm-instrs)
                        make-link!
                        push-frame! pop-frame! frame))
      (set! asm-instrs (append (reverse next) asm-instrs))
      (loop (cdr instrs))))

  (pop-frame!)

  ; apply prefix and suffix
  (define with-suffix (append (reverse suffix) asm-instrs))

  ; apply padding
  (define padding (make-list (padding-length with-suffix) (list #x90)))
  (define with-padding (append padding with-suffix))
  (define final-instrs (reverse with-padding))

  (values final-instrs links))

;;;
;;; x86-64 specific definitions
;;;

(import "../base.min" "common.min")
(export assemble/x86-64 link/x86-64)

;
; Constants
;

(define ALIGNMENT 16)

;
; Utilities
;

; Creates a positive integer with the corresponding bits
(define (bits . xs)
  (let loop ([xs xs] [r 0])
    (cond [(null? xs) r]
          [else (loop (cdr xs) (+ (* 2 r) (if (car xs) 1 0)))])))

(define (decompose/imm64 i)
  (let loop ([i i] [k 0] [bits '()])
    (cond
      [(= k 8)
       (reverse bits)]
      [else
       (define bit (remainder i 256))
       ; TODO: (loop (floor (/ i 256)) (+ k 1) (cons bit bits))
       (loop (/ i 256) (+ k 1) (cons bit bits))])))

; Creates the REX prefix of an instruction
(define (rex-prefix w r x b)
  (+ 64 (bits w r x b)))

; Creates a MODR/M byte of an instruction
(define (encode/modrm mod reg r/m)
  (+ (* 64 mod) (* 8 reg) r/m))

; Creates a IO byte of an instruction
(define (encode/io op reg)
  (+ op reg))

(define (register/from-generic reg)
  (cond
    [(eq? reg CC-REG)   'rbp]
    [(eq? reg SP-REG)   'rsp]
    [(eq? reg ENV-REG)  'rdi]
    [(eq? reg RES-REG)  'rax]
    [(eq? reg T0-REG)   'r10]
    [(eq? reg T1-REG)   'r11]
    [else       (error 'register/translate "unknown register" reg)]))

; Register -> X.RRR
(define (register/code reg)
  (case reg
    [(rax)   (values #f 0)]
    [(rcx)   (values #f 1)]
    [(rdx)   (values #f 2)]
    [(rbx)   (values #f 3)]
    [(rsp)   (values #f 4)]
    [(rbp)   (values #f 5)]
    [(rsi)   (values #f 6)]
    [(rdi)   (values #f 7)]

    [(r8)    (values #t 0)]
    [(r9)    (values #t 1)]
    [(r10)   (values #t 2)]
    [(r11)   (values #t 3)]
    [(r12)   (values #t 4)]
    [(r13)   (values #t 5)]
    [(r14)   (values #t 6)]
    [(r15)   (values #t 7)]))

(define (argument/register i)
  (case i
    [(0)    'rdi]
    [(1)    'rsi]
    [(2)    'rdx]
    [(3)    'rcx]
    [(4)    'r8]
    [(5)    'r9]
    [else   (error 'argument/register "unimplemeneted")]))

;
; Instruction encoding
;

; mov <dst>, <imm64>
(define (instr/load-imm64 dst imm)
  (define-values (b reg) (register/code dst))
  (define imm-bits (decompose/imm64 imm))
  (define rex (rex-prefix #t #f #f b))
  (cons rex (cons (encode/io #xb8 reg) imm-bits)))

; mov <dst>, <sec>
(define (instr/load dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x89 (encode/modrm 3 reg r/m)))

; mov [<dst>+imm], <sec>
(define (instr/load-at-offset dst src offset)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (cond
    [(= offset 0)
     (list rex #x89 (encode/modrm 1 reg r/m) #x00)]
    [(and (<= (- 128) offset) (< offset 0))
     (list rex #x89 (encode/modrm 1 reg r/m) (+ 256 offset))]
    [else
     (error 'instr/load-at-offset "unimplemented offset" offset)]))

; mov <dst>, [<src>+imm]
(define (instr/load-from-offset dst src offset)
  (define-values (b r/m) (register/code src))
  (define-values (r reg) (register/code dst))
  (define rex (rex-prefix #t r #f b))
  (cond
    [(and (< 0 offset) (< offset 128))
     (list rex #x8b (encode/modrm 1 reg r/m) offset)]
    [(= offset 0)
     (list rex #x8b (encode/modrm 0 reg r/m))]
    [(and (<= (- 128) offset) (< offset 0))
     (list rex #x8b (encode/modrm 1 reg r/m) (+ 256 offset))]
    [else
     (error 'instr/load-at-offset "unimplemented offset" offset)]))

; push <src>
(define (instr/push src)
  (define-values (b reg) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (define io (encode/io #x50 reg))
  (if b (list rex io) (list io)))

; pop <src>
(define (instr/pop src)
  (define-values (b reg) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (define io (encode/io #x58 reg))
  (if b (list rex io) (list io)))

; add <dst> <imm>
(define (instr/add-imm dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (cond
    [(<= 0 imm 255)
     (list rex #x83 (encode/io #xc0 reg) imm)]
    [else
     (error 'instr/add-imm "unimplemented" imm)]))

; add <dst> <sub>
(define (instr/add dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x01 (encode/modrm 3 reg r/m)))

; sub <dst> <imm>
(define (instr/sub-imm dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (cond
    [(<= 0 imm 255)
     (list rex #x83 (encode/io #xe8 reg) imm)]
    [else
     (error 'instr/sub-imm "unimplemented" imm)]))

; sub <dst> <sub>
(define (instr/sub dst src)
  (define-values (b r/m) (register/code dst))
  (define-values (r reg) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x29 (encode/modrm 3 reg r/m)))

; call <reg>
(define (instr/call src)
  (define-values (b r/m) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (if b
      (list rex #xff (encode/modrm 3 2 r/m))
      (list #xff (encode/modrm 3 2 r/m))))

; ret
(define (instr/ret)
  (list #xc3))

; leave
(define (instr/leave)
  (list #xc9))

; endbr64
(define (instr/endbr)
  (list #xf3 #x0f #x1e #xfa))

;
; Link
;

(define (link/x86-64 proc links info)
  (define (replace proc link)
    (define type (car link))
    (define location (cdr link))
    (let loop ([proc proc] [idx (car location)] [next (cdr location)])
      (cond
        [(> idx 0)
         (cons (car proc) (loop (cdr proc) (- idx 1) next))]
        [(null? next)
         (case (first type)
           [(literal)
            (define addr (assoc 'literal info))
            (decompose/imm64 (+ addr (* WORD-SIZE (second type))))]
           [(procedure)
            (define addr (assoc type info))
            (decompose/imm64 addr)]
           [(runtime)
            (decompose/imm64 (runtime-address (second type)))]
           [else
            (error 'link/x86-64 "unknown link type" type)])]
        [else
         (cons (loop (car proc) (car next) (cdr next)) (cdr proc))])))

  (let loop ([proc proc] [links links])
    (cond [(null? links) proc]
          [else (loop (replace proc (car links)) (cdr links))])))

;
; Assembler
;

(define prefix (list (instr/endbr) (instr/push 'rbp) (instr/load 'rbp 'rsp)))
(define suffix (list (instr/leave) (instr/ret)))

(define (padding-length instrs)
  (let loop ([instrs instrs] [len 0])
    (cond
      [(null? instrs)
       (define r16 (remainder len 16))
       (if (= r16 0) 0 (- 16 r16))]
      [else (loop (cdr instrs) (+ len (length (car instrs))))])))

(define (c-call-prefix+suffix args push! pop! get-frame)
  (let loop ([args args] [i 0] [prefix '()] [suffix '()])
    (cond
      [(null? args)
       ; no arguments left to stash
       (for-each (lambda _ (pop!)) (make-list i #f))
       (values (reverse prefix) suffix)]
      [else
       (push!)
       (define size (third (get-frame)))
       (define i-reg (argument/register i))
       (define push (instr/load-at-offset 'rbp i-reg (- (* size WORD-SIZE))))
       (define pop (instr/load-from-offset i-reg 'rbp (- (* size WORD-SIZE))))
       (cond
         [(number? (car args))
          ; immediate as argument
          (define ld (instr/load-imm64 (car args)))
          (loop (cdr args) (+ i 1) (cons ld (cons push prefix)) (cons pop suffix))]
         [else
          ; register as argument
          (define src (register/from-generic (car args)))
          (cond
            [(eq? i-reg src)
             (loop (cdr args) (+ i 1) (cons push prefix) (cons pop suffix))]
            [else
             (define ld (instr/load i-reg src))
             (loop (cdr args) (+ i 1) (cons ld (cons push prefix)) (cons pop suffix))])])])))


(define (assemble/instr instr seqs
                        link!
                        push-frame! pop-frame! get-frame
                        reserve-args! push-local! pop-local!)
  (case (first instr)
    [(load)
     ; mov <dst>, <src>
     (cond
       [(number? (third instr))
        (define dst (register/from-generic (second instr)))
        (list (instr/load-imm64 dst 0))]
       [else
        (error 'assemble/instr "unimplemented" instr)])]
    [(load-offset)
     ; mov <dst> [<src>+<offset>]
     (cond
       [(eq? (second instr) (third instr))
        ; x64-style
        (define dst (register/from-generic (second instr)))
        (define src (register/from-generic (third instr)))
        (list (instr/load-from-offset dst src (fourth instr)))]
       [else
        (error 'assemble/instr "unimplemented" instr)])]
    [(load-literal)
     ; mov <dst>, <literal address> => 48 b8 [xx]^8
     ; mov <dst>, [<dst>] => 48 8b 00
     (define dst (register/from-generic (second instr)))
     (link! (list 'literal (third instr)) (list (length seqs) 2))
     (list
       (instr/load-imm64 dst 0)
       (instr/load-from-offset dst dst 0))]
    [(load-procedure)
     ; mov <dst>, <procedure address> => 48 b8 [xx]^8
     (define dst (register/from-generic (second instr)))
     (link! (list 'procedure (third instr)) (list (length seqs) 2))
     (list (instr/load-imm64 dst 0))]
    [(add)
     (cond
       [(symbol? (fourth instr))
        (cond
          [(eq? (second instr) (third instr))
           ; x64-style
           (define dst (register/from-generic (second instr)))
           (define src (register/from-generic (fourth instr)))
           (list (instr/add dst src))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (define dst (register/from-generic (second instr)))
           (define src0 (register/from-generic (third instr)))
           (define src (register/from-generic (fourth instr)))
           (list (instr/load dst src0) (instr/add dst src))])]
       [else
        (cond
          [(eq? (second instr) (third instr))
           ; x64-style
           (define dst (register/from-generic (second instr)))
           (list (instr/add-imm dst (fourth instr)))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (define dst (register/from-generic (second instr)))
           (define src (register/from-generic (third instr)))
           (list
             (instr/load dst src)
             (instr/add-imm dst (fourth instr)))])])]
    [(sub)
     (cond
       [(symbol? (fourth instr))
        (cond
          [(eq? (second instr) (third instr))
           ; x64-style
           (define dst (register/from-generic (second instr)))
           (define src (register/from-generic (fourth instr)))
           (list (instr/sub dst src))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (define dst (register/from-generic (second instr)))
           (define src0 (register/from-generic (third instr)))
           (define src (register/from-generic (fourth instr)))
           (list (instr/load dst src0) (instr/sub dst src))])]
       [else
        (cond
          [(eq? (second instr) (third instr))
           ; x64-style
           (define dst (register/from-generic (second instr)))
           (list (instr/sub-imm dst (fourth instr)))]
          [else
           ; ARM-style
           ;  mov <dst> to <src>
           ;  perform x64-style on <dst>
           (define dst (register/from-generic (second instr)))
           (define src (register/from-generic (third instr)))
           (list
             (instr/load dst src)
             (instr/sub-imm dst (fourth instr)))])])]
    [(c-call)
     ; function call
     ; make prefix and suffix code to stash registers
     (define-values (prefix suffix)
       (c-call-prefix+suffix (cddr instr) push-local! pop-local! get-frame))
     ; compute prefix
     ; the actual call
     (cond
       [(string? (second instr))
        ; link required:
        ;  mov rax, <literal address> => 48 b8 [xx]^8
        ;  call rax => ff d0
        (define link-idx (+ (length seqs) (length prefix)))
        (link! (list 'runtime (second instr)) (list link-idx 2))
        (append
          prefix
          (list
            (instr/load-imm64 'rax 0)
            (instr/call 'rax))
          suffix)]
       [else
        ; pointer provided [at rax]
        ;  call rax => ff d0
        (append
          prefix
          (list (instr/call 'rax))
          suffix)])]
    [(label)
     ; TODO:
     (list)]
    [else
     (error 'assemble/x86-64 "unimplemented" instr)]))


(define (assemble/x86-64 instrs)
  (define asm-instrs '())
  (define frames '((0 0 0)))
  (define framei '())
  (define links '())

  (define (make-link! key loc)
    (set! links (cons (cons key loc) links)))

  (define (adjust-links! start by)
    (set! links
      (let loop ([links links] [links* '()])
        (cond
          [(null? links)
           (reverse links*)]
          [(>= (cadar links) start)
           (define loc* (cons (+ (cadar links) by) (cddar links)))
           (loop (cdr links) (cons (cons (caar links) loc*) links*))]
          [else
           (loop (cdr links) (cons (car links) links*))]))))

  (define (adjust-frame!)
    (define instr-idx (car framei))
    (define frame (car frames))

    (define frame-size (+ (first frame) (second frame)))
    (define aligned-size
      (if (= (remainder frame-size 2) 0)
          frame-size
          (+ frame-size 1)))

    (set! asm-instrs
      (reverse 
        (let loop ([instrs (reverse asm-instrs)] [i 0] [instrs* '()])
          (cond
            [(null? instrs)
             (error 'adjust-frame!
                    "instruction sequence not long enough"
                    instr-idx asm-intsrs)]
            [(= i instr-idx)
             (define instr-len (length (car instrs)))
             (display "adjusting ") (write (car instrs)) (display " ") (write aligned-size) (newline)
             (cond
               [(= aligned-size 0)
                (adjust-links! i (- instr-len))
                (append (reverse instrs*) (cdr instrs))]
               [else
                (define reserve (instr/sub-imm 'rsp (* WORD-SIZE aligned-size)))
                (unless (= (length (car instrs)) (length reserve))
                  (adjust-links! i (- (length reserve) instr-len)))
                (append (reverse instrs*) (cons reserve (cdr instrs)))])]
            [else
             (loop (cdr instrs) (+ i 1) (cons (car instrs) instrs*))])))))

  (define (push-frame! idx)
    (set! framei (cons idx framei))
    (set! frames '((list 0 0 0) frames)))

  (define (pop-frame!)
    (adjust-frame!)
    (set! frames (cdr frames)))
  
  (define (get-frame)
    (car frames))

  (define (reserve-args! count)
    (define frame (car frames))
    (define argc (first frame))
    (define localc (second frame))
    (define locali (third frame))
    (define frame* (list (+ argc count) localc locali))
    (set! frames (cons frame* (cdr frames))))

  (define (push-local!)
    (define frame (car frames))
    (define argc (first frame))
    (define localc (second frame))
    (define locali (third frame))
    (define frame*
      (if (= locali localc)
          (list argc (+ localc 1) (+ locali 1))
          (list argc localc (+ locali 1))))
    (set! frames (cons frame* (cdr frames))))
    
  (define (pop-local!)
    (define frame (car frames))
    (define argc (first frame))
    (define localc (second frame))
    (define locali (third frame))
    (define frame* (list argc localc (- locali 1)))
    (if (= locali 0)
        (error 'assemble/x86-64 "pop-local: frame size will be negative" frames)
        (set! frames (cons frame* (cdr frames)))))
  
  (display instrs) (newline)

  (set! framei (cons (length prefix) framei))
  (set! asm-instrs (cons (instr/sub-imm 'rsp 0) (reverse prefix)))

  (let loop ([instrs instrs])
    (unless (null? instrs)
      (define next
        (assemble/instr (car instrs) asm-instrs
                        make-link!
                        push-frame! pop-frame! get-frame
                        reserve-args! push-local! pop-local!))
      (set! asm-instrs (append (reverse next) asm-instrs))
      (loop (cdr instrs))))

  ; insert stack frame (if necessary)
  ; (define with-frame
  ;   (cond
  ;     [(= max-frame-size 0)
  ;      asm-instrs]
  ;     [else
  ;     (set! links
  ;       (let loop ([links links] [links* '()])
  ;         (cond [(null? links)
  ;                 (reverse links*)]
  ;               [(>= (cadar links) (length prefix))
  ;                 (define loc* (cons (+ (cadar links) 1) (cddar links)))
  ;                 (loop (cdr links) (cons (cons (caar links) loc*) links*))]
  ;               [else
  ;                 (loop (cdr links) (cons (car links) links*))])))
  ;     (define aligned-frame-size
  ;       (if (= (remainder max-frame-size 2) 0)
  ;           max-frame-size
  ;           (+ max-frame-size 1)))
  ;     (reverse
  ;       (let loop ([prefix prefix] [instrs (reverse asm-instrs)])
  ;         (if (null? prefix)
  ;             (cons (instr/sub-imm 'rsp (* WORD-SIZE aligned-frame-size)) instrs)
  ;             (cons (car instrs) (loop (cdr prefix) (cdr instrs))))))]))

  (pop-frame!)

  ; apply prefix and suffix
  (define with-suffix (append (reverse suffix) asm-instrs))

  ; apply padding
  (define padding (make-list (padding-length with-suffix) (list #x90)))
  (define with-padding (append padding with-suffix))
  (define final-instrs (reverse with-padding))

  (values final-instrs links))

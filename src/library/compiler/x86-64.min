;;;
;;; x86-64 specific definitions
;;;

(import "../base.min" "common.min")
(export assemble/x86-64 link/x86-64)

;
; Constants
;

(define ALIGNMENT 16)

;
; Utilities
;

; Creates a positive integer with the corresponding bits
(define (bits . xs)
  (let loop ([xs xs] [r 0])
    (cond [(null? xs) r]
          [else (loop (cdr xs) (+ (* 2 r) (if (car xs) 1 0)))])))

(define (decompose/imm64 i)
  (let loop ([i i] [k 0] [bits '()])
    (cond
      [(= k 8)
       (reverse bits)]
      [else
       (define bit (remainder i 256))
       ; TODO: (loop (floor (/ i 256)) (+ k 1) (cons bit bits))
       (loop (/ i 256) (+ k 1) (cons bit bits))])))

; Creates the REX prefix of an instruction
(define (rex-prefix w r x b)
  (+ 64 (bits w r x b)))

; Creates a MODR/M byte of an instruction
(define (encode/modrm mod reg r/m)
  (+ (* 64 mod) (* 8 reg) r/m))

; Creates a IO byte of an instruction
(define (encode/io op reg)
  (+ op reg))

(define (register/translate reg)
  (cond
    [(eq? reg CC-REG)   'rbp]
    [(eq? reg SP-REG)   'rsp]
    [(eq? reg ENV-REG)  'rdi]
    [(eq? reg SS-REG)   'r12]
    [(eq? reg RES-REG)  'rax]
    [(eq? reg T0-REG)   'r10]
    [(eq? reg T1-REG)   'r11]
    [else       (error 'register/translate "unknown register" reg)]))

; Register -> X.RRR
(define (register/code reg)
  (case (register/translate reg)
    [(rax)   (values #f 0)]
    [(rcx)   (values #f 1)]
    [(rdx)   (values #f 2)]
    [(rbx)   (values #f 3)]
    [(rsp)   (values #f 4)]
    [(rbp)   (values #f 5)]
    [(rsi)   (values #f 6)]
    [(rdi)   (values #f 7)]

    [(r8)    (values #t 0)]
    [(r9)    (values #t 1)]
    [(r10)   (values #t 2)]
    [(r11)   (values #t 3)]
    [(r12)   (values #t 4)]
    [(r13)   (values #t 5)]
    [(r14)   (values #t 6)]
    [(r15)   (values #t 7)]))

;
; Instruction encoding
;

; mov <dst> [<src>]
(define (instr/deref dst src)
  (define-values (r reg) (register/code dst))
  (define-values (b r/m) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (if (or r b)
      (list rex #x8b (encode/modrm 0 reg r/m) #x24)
      (list rex #x8b (encode/modrm 0 reg r/m))))

; mov <dst> <imm64>
(define (instr/load-imm64 dst imm)
  (define-values (b reg) (register/code dst))
  (define imm-bits (decompose/imm64 imm))
  (define rex (rex-prefix #t #f #f b))
  (cons rex (cons (encode/io #xb8 reg) imm-bits)))

; mov <dst> <sec>
(define (instr/load dst src)
  (define-values (r reg) (register/code dst))
  (define-values (b r/m) (register/code src))
  (define rex (rex-prefix #t r #f b))
  (list rex #x89 (encode/modrm 3 reg r/m)))

; push <src>
(define (instr/push src)
  (define-values (b reg) (register/code src))
  (define rex (rex-prefix #f #f #f b))
  (define io (encode/io #x50 reg))
  (if b (list rex io) (list io)))

; sub <dst> <imm8>
(define (instr/sub-imm8 dst imm)
  (define-values (b reg) (register/code dst))
  (define rex (rex-prefix #t #f #f b))
  (list rex #x83 (encode/io #xe8 reg) imm))

;
; Link
;

(define (link/x86-64 proc links info)
  (define (replace proc link)
    (define type (car link))
    (define location (cdr link))
    (let loop ([proc proc] [idx (car location)] [next (cdr location)])
      (cond
        [(> idx 0)
         (cons (car proc) (loop (cdr proc) (- idx 1) next))]
        [(null? next)
         (case (first type)
           [(literal)
            (define addr (assoc 'literal info))
            (decompose/imm64 (+ addr (* WORD-SIZE (second type))))]
           [(procedure)
            (define addr (assoc 'procedure info))
            (decompose/imm64 (+ addr (* WORD-SIZE (second type))))]
           [else
            (error 'link/x86-64 "unknown link type" type)])]
        [else
         (cons (loop (car proc) (car next) (cdr next)) (cdr proc))])))

  (let loop ([proc proc] [links links])
    (cond [(null? links) proc]
          [else (loop (replace proc (car links)) (cdr links))])))

;
; Assembler
;

(define (padding-length instrs)
  (let loop ([instrs instrs] [len 0])
    (cond
      [(null? instrs)
       (define r16 (remainder len 16))
       (if (= r16 0) 0 (- 16 r16))]
      [else (loop (cdr instrs) (+ len (length (car instrs))))])))

(define (assemble/x86-64 instrs)
  (define links '())
  (define bytes
    (let loop ([instrs instrs] [sequences '()])
      (cond
        [(null? instrs)
         (define padding (make-list (padding-length sequences) (list #x90)))
         (reverse (append padding sequences))]
        [else
         (define instr (first instrs))
         (define seqs
           (case (first instr)
             [(label)
              ; TODO:
              (list)]
             [(load-literal)
              ; mov rax, <literal address> => 48 b8 [xx]^8
              ; mov rax, [rax] => 48 8b 00
              (define dst (second instr))
              (define entry (cons (list 'literal (third instr)) (list (length sequences) 2)))
              (set! links (cons entry links))
              (list
                (instr/load-imm64 dst 0)
                (instr/deref dst dst))]
             [(load-procedure)
              ; mov rax, <procedure address> => 48 b8 [xx]^8
              ; mov rax, [rax] => 48 8b 00
              (define dst (second instr))
              (define entry (cons (list 'procedure (third instr)) (list (length sequences) 2)))
              (set! links (cons entry links))
              (list
                (instr/load-imm64 dst 0)
                (instr/deref dst dst))]
             [(sub)
              (cond
                [(<= 0 (fourth instr) 255)
                 (cond
                   [(eq? (second instr) (third instr))
                    ; x64-style
                    (list (instr/sub-imm8 (second instr) (fourth instr)))]
                   [else
                    ; ARM-style
                    ;  mov <dst> to <src>
                    ;  perform x64-style on <dst>
                    (list
                      (instr/load (second instr) (third instr))
                      (instr/sub-imm8 (second instr) (fourth instr)))])]
                [else
                 (error 'assemble/x86-64 "sub: operand size unimplemented" (fourth instr))])]
             [(c-call)
              ; function call
              (define args (cddr instr))
              (cond
                [(string? (second instr))
                 ; link required:
                 ;  mov rax, <literal address> => 48 b8 [xx]^8
                 ;  call rax => ff d0
                 (define entry (cons (list 'runtime (second instr)) (list (length sequences) 2)))
                 (set! links (cons entry links))
                 (list
                   (instr/load-imm64 RES-REG 0)
                   (list #xff #xd0))]
                [else
                 ; pointer provided [at rax]
                 ;  call rax => ff d0
                 (list (list #xff #xd0))])]
             [(push)
              ; push <src>
              (list (instr/push (second instr)))]
             [(return)
              ; ret => c3
              '((#xc3))]
             [else (error 'assemble/x86-64 "unimplemented" instr)]))
         (loop (cdr instrs) (append (reverse seqs) sequences))])))

  (values bytes links))

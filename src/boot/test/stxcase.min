;;;
;;; Tests for 'syntax-case'
;;;

(import "../lib/base.min")

(define num-failed 0)

(define (check-equal? d0 d1)
  (unless (equal? d0 d1)
    (display "[FAIL] expected ")
    (write d0)
    (display ", received ")
    (write d1)
    (newline)
    (set! num-failed (+ num-failed 1))))

;; easy

(define-syntax (macro-1 stx)
  (syntax-case stx ()
    [(_ a) #'1]))

(define-syntax (macro-2 stx)
  (syntax-case stx ()
    [(_ a) #'a]))

(define-syntax (macro-3 stx)
  (syntax-case stx ()
    [(_ a b) #'(list a b)]))

(define-syntax (macro-4 stx)
  (syntax-case stx ()
    [(_ a) #'(list a)]
    [(_ a b) #'(list a b)]))

(define-syntax (macro-5 stx)
  (syntax-case stx ()
    [(_ a . b) #'(cons a b)]))

(define-syntax (macro-6 stx)
  (syntax-case stx (foo)
    [(_ foo) #'(quote good)]
    [_ #'(quote bad)]))

(check-equal? (macro-1 2) 1)
(check-equal? (macro-2 1) 1)
(check-equal? (macro-3 1 2) '(1 2))

(check-equal? (macro-4 1) '(1))
(check-equal? (macro-4 1 2) '(1 2))

(check-equal? (macro-5 1 . 2) '(1 . 2))

(check-equal? (macro-6 foo) 'good)
(check-equal? (macro-6 +) 'bad)

;; actual Scheme macros

(define-syntax (mylet stx)
  (syntax-case stx ()
    [(_ ([var val] ...) body ...)
     #'(let-values ([(var) val] ...) body ...)]))

(define-syntax mywhen
  (syntax-rules ()
    ((_ test e1 e2 ...) (if test (begin e1 e2 ...) (void)))))

(define-syntax myunless
  (syntax-rules ()
    ((_ test e1 e2 ...) (mywhen (not test) (begin e1 e2 ...)))))

; (define-syntax with-syntax
;   (lambda (x)
;     (syntax-case x ()
;       ((_ () e1 e2 ...)
;        (syntax (begin e1 e2 ...)))
;       ((_ ((out in)) e1 e2 ...)
;        (syntax (syntax-case in () (out (begin e1 e2 ...)))))
;       ((_ ((out in) ...) e1 e2 ...)
;        (syntax (syntax-case (list in ...) () ((out ...) (begin e1 e2 ...))))))))

; (define-syntax do
;   (lambda (orig-x)
;     (syntax-case orig-x ()
;       ((_ ((var init . step) ...) (e0 e1 ...) c ...)
;        (with-syntax (((step ...)
;                       (map (lambda (v s)
;                              (syntax-case s ()
;                                (() v)
;                                ((e) (syntax e))
;                                (_ (syntax-error orig-x))))
;                          (syntax (var ...))
;                          (syntax (step ...)))))
;          (syntax-case (syntax (e1 ...)) ()
;            (()
;             (syntax (let do ((var init) ...)
;                        (if (not e0)
;                            (void)
;                            (begin c ... (do step ...))))))
;            ((e1 e2 ...)
;             (syntax (let do ((var init) ...)
;                        (if e0
;                                 (begin e1 e2 ...)
;                                 (begin c ... (do step ...))))))))))))

(check-equal? (mylet () 1) 1)
(check-equal? (mylet ([x 1]) x) 1)
(check-equal? (mylet ([x 1] [y 2]) y) 2)
(check-equal? (mylet ([x 1] [y 2]) (set! x 3) (+ x y)) 5)

(check-equal? (mywhen #t 1) 1)
(check-equal? (mywhen #t 1 2 3) 3)
(check-equal? (mywhen #f 1 2 3) (void))

(check-equal? (myunless #f 1) 1)
(check-equal? (myunless #f 1 2 3) 3)
(check-equal? (myunless #t 1 2 3) (void))

(when (> num-failed 0)
  (error #f "test failed"))

;;;   
;;; 'syntax-case'
;;;

(import "and-or.min" "cond.min" "define.min" "gen-temp.min"
        "let.min" "stx.min" "template.min" "when-unless.min")
(export syntax-case)

(define-syntax (syntax-case stx)
  (define l (syntax->list stx))
  (unless (and (list? l) (> (length l) 3))
    (syntax-error 'syntax-case "bad syntax" stx))
  (let ([arg (quote-syntax arg)]
        [expr (cadr l)]
        [lits (caddr l)]
        [clauses (cdddr l)])
    (for-each
      (lambda (x)
        (unless (identifier? x)
          (syntax-error
            'syntax-case
            "literal is not an identifier"
            stx
            (syntax-e x))))
      (syntax-e lits))
    (for-each
      (lambda (cl)
        (unless (and (stx-list? cl) (<= 2 (length (syntax->list cl)) 3))
          (syntax-error
            'syntax-case
            "expected a clause with a pattern, optional guard expression, and expression"
            stx
            cl)))
      clauses)
    (let ([patterns
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (car cl*)))
            clauses)]
          [fenders
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (if (= (length cl*) 2)
                #f
                (cadr cl*))))
            clauses)]
          [results
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (if (= (length cl*) 2)
                (cadr cl*)
                (caddr cl*))))
            clauses)]
          [get-pattern-vars
      (lambda (pattern0)
        (let loop ([pattern pattern0]
                   [depth 0]
                   [vars null])
          (cond
            [(stx-null? pattern)
             ; empty list
             vars]
            [(stx-pair? pattern)
             ; pair / list
             (let* ([p (syntax-e pattern)]
                    [head-pat (car p)]
                    [tail-pat (if (syntax? (cdr p))
                                  (cdr p)
                                  (datum->syntax (cdr p)))]
                    [ellipse-next? (and (stx-pair? tail-pat)
                                        (identifier? (stx-car tail-pat))
                                        (free-identifier=? (stx-car tail-pat)
                                                           (quote-syntax ...)))])
               (if ellipse-next?
                   (let ([vars (loop head-pat (+ depth 1) vars)]
                         [tail-pat (datum->syntax (stx-cdr tail-pat))])
                     (loop tail-pat depth vars))
                   (let ([vars (loop head-pat depth vars)])
                     (loop tail-pat depth vars))))]
            [(and (identifier? pattern)
                  (free-identifier=? pattern (quote-syntax _)))
             ; wildcard
             vars]
            [(identifier? pattern)
             ; variable
             (cons (cons (syntax-e pattern) depth) vars)]
            [(not (syntax? (syntax-e pattern)))
             ;; datum
             vars]
            [else
             (error 'syntax-case "improper pattern" stx pattern0)])))]

          [gen-matcher
      (lambda (pattern0)
        (let loop ([pattern pattern0]
                   [datum arg])
          (cond
            [(stx-null? pattern)
             ; empty list
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax stx-null/#f)
                     (quote-syntax e)))
                 datum))]
            [(stx-pair? pattern)
             ;; pair / list
             (let* ([p (syntax-e pattern)]
                    [head-pat (car p)]
                    [tail-pat (if (syntax? (cdr p))
                                  (cdr p)
                                  (datum->syntax (cdr p)))]
                    [ellipse-next? (and (stx-pair? tail-pat)
                                        (identifier? (stx-car tail-pat))
                                        (free-identifier=? (stx-car tail-pat)
                                                           (quote-syntax ...)))])
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (cond
                     [ellipse-next?
                      ; nested subpattern
                      (cond
                        [(and (identifier? head-pat)
                              (stx-null? (stx-cdr tail-pat)))
                         ; easy case: single variable matches on the remaining parts of the list
                         (list
                           (quote-syntax if)
                           (list
                             (quote-syntax stx-list?)
                             (quote-syntax e))
                           (list
                             (quote-syntax list)
                             (quote-syntax e))
                           #f)]
                        [(stx-null? (stx-cdr tail-pat))
                         ; harder case: need to match on the subpattern
                         (list
                           (quote-syntax if)
                           (list
                             (quote-syntax stx-list?)
                             (quote-syntax e))
                           (list
                             (quote-syntax let)
                             (list
                               (list
                                 (quote-syntax tmp)
                                 (list
                                   (quote-syntax map/#f)
                                   (list
                                     (quote-syntax lambda)
                                     (list (quote-syntax e))
                                     (loop head-pat (quote-syntax e)))
                                   (list
                                     (quote-syntax stx->list)
                                     (quote-syntax e)))))
                             (list
                               (quote-syntax if)
                               (quote-syntax tmp)
                               (list
                                 (quote-syntax if)
                                 (list (quote-syntax null?) (quote-syntax tmp))
                                 (quote-syntax tmp)
                                 (list
                                   (quote-syntax apply)
                                   (quote-syntax map)
                                   (quote-syntax list)
                                   (quote-syntax tmp)))
                               #f))
                           #f)]
                        [else
                         (error #f "unimplemented")])]
                     [else
                      (list
                        (quote-syntax if)
                        (list
                          (quote-syntax stx-pair?)
                          (quote-syntax e))
                        (cond                          
                          [(and (identifier? head-pat)
                                (free-identifier=? head-pat (quote-syntax _)))
                           ; wildcard
                           (loop tail-pat
                                 (list
                                   (quote-syntax stx-cdr)
                                   (quote-syntax e)))]
                          [(identifier? head-pat)
                           ; variable
                           (list
                             (quote-syntax cons/#f)
                             (list
                               (quote-syntax stx-car)
                               (quote-syntax e))
                             (loop tail-pat
                                   (list
                                     (quote-syntax stx-cdr)
                                     (quote-syntax e))))]
                          [(stx-pair? head-pat)
                           ; subpattern
                           (list
                             (quote-syntax append/#f)
                             (loop head-pat
                                   (list
                                     (quote-syntax stx-car)
                                     (quote-syntax e)))
                             (loop tail-pat
                                   (list
                                     (quote-syntax stx-cdr)
                                     (quote-syntax e))))]
                          [else
                           ;; datum
                           (list
                             (quote-syntax if)
                             (list
                               (quote-syntax equal?)
                               (list
                                 (quote-syntax quote)
                                 (syntax-e head-pat))
                               (list
                                 (quote-syntax syntax-e)
                                 (list
                                   (quote-syntax stx-car)
                                   (quote-syntax e))))
                             (loop tail-pat
                                   (list
                                     (quote-syntax stx-cdr)
                                     (quote-syntax e)))
                             #f)])
                        #f)]))
                 datum)))]
            [(and (identifier? pattern)
                  (free-identifier=? pattern (quote-syntax _)))
             ; wildcard
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list (quote-syntax null)))
                 datum))]
            [(identifier? pattern)
             ; variable
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax list)
                     (quote-syntax e)))
                 datum))]
            [(not (syntax? (syntax-e pattern)))
             ;; datum
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax if)
                     (list
                       (quote-syntax equal?)
                       (syntax-e head-pat)
                       (list
                         (quote-syntax syntax-e)
                         (quote-syntax e))
                       (quote-syntax null)
                       #f)))
                 datum))]
            [else
             (error 'syntax-case "improper pattern" stx pattern0)])))])
      
      (datum->syntax
        (list
          (quote-syntax let)
          (list (list arg expr))
          (let loop ([patterns patterns]
                     [fenders fenders]
                     [results results])
            (if (null? patterns)
                (list
                  (quote-syntax syntax-error)
                  #f
                  "bad syntax"
                  arg)
              (let* ([pattern (car patterns)]
                     [fender (car fenders)]
                     [result (car results)]
                     [pat-vars (reverse (get-pattern-vars pattern))]
                     [matcher (gen-matcher pattern)]
                     [result-stx (quote-syntax rslt)]
                     [temp-vars (map (lambda (t)
                                       (gen-temp-id "sc"))
                                     pat-vars)])
                (list
                  (quote-syntax let)
                  (list (list result-stx matcher))
                  (list
                    (quote-syntax if)
                    result-stx
                    (if fender
                        (error #f "unsupported")
                        (let ([bind-vars
                               (lambda (e)
                                 (datum->syntax
                                   (list
                                     (quote-syntax let)
                                     (let loop ([pat-vars pat-vars]
                                                [temp-vars temp-vars]
                                                [result-stx result-stx]
                                                [bindings null])
                                       (if (null? pat-vars)
                                           (reverse bindings)
                                           (loop (cdr pat-vars)
                                                 (cdr temp-vars)
                                                 (datum->syntax
                                                   (list
                                                     (quote-syntax cdr)
                                                     result-stx))
                                                 (cons
                                                   (list (car temp-vars)
                                                         (list
                                                           (quote-syntax car)
                                                           result-stx))
                                                   bindings))))
                                     e)))]
                              
                              [gen-syntaxes
                               (lambda ()
                                 (list
                                   (quote-syntax let-syntaxes)
                                   (map (lambda (pat-var temp-var)
                                          (list
                                            (list (car pat-var))
                                            (list
                                              (quote-syntax make-pattern-variable)
                                              (list
                                                (quote-syntax quote-syntax)
                                                temp-var)
                                              (list
                                                (quote-syntax quote)
                                                (cdr pat-var)))))
                                      pat-vars temp-vars)
                                   (list
                                     (quote-syntax let-values)
                                     (quote-syntax ())
                                     result)))])

                        (bind-vars (gen-syntaxes))))
                    (loop (cdr patterns)
                          (cdr fenders)
                          (cdr results))))))))))))

;;;   
;;; 'syntax-case'
;;;

(import "and-or.min" "cond.min" "define.min" "gen-temp.min"
        "let.min" "stx.min" "template.min" "when-unless.min")
(export syntax-case)

(define-syntax (syntax-case stx)
  (define l (syntax->list stx))
  (unless (and (list? l) (> (length l) 3))
    (syntax-error 'syntax-case "bad syntax" stx))
  (let ([arg (quote-syntax arg)]
        [expr (cadr l)]
        [lits (caddr l)]
        [clauses (cdddr l)])
    (for-each
      (lambda (x)
        (unless (identifier? x)
          (syntax-error
            'syntax-case
            "literal is not an identifier"
            stx
            (syntax-e x))))
      (syntax-e lits))
    (for-each
      (lambda (cl)
        (unless (and (stx-list? cl) (<= 2 (length (syntax->list cl)) 3))
          (syntax-error
            'syntax-case
            "expected a clause with a pattern, optional guard expression, and expression"
            stx
            cl)))
      clauses)
    (let* ([patterns
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (car cl*)))
            clauses)]
          [fenders
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (if (= (length cl*) 2)
                #f
                (cadr cl*))))
            clauses)]
          [results
      (map
        (lambda (cl)
          (let ([cl* (syntax-e cl)])
            (if (= (length cl*) 2)
                (cadr cl*)
                (caddr cl*))))
            clauses)]
          
          [variable?
      (lambda (s)
        (and (identifier? s)
             (let loop ([lits (syntax->list lits)])
               (cond [(null? lits) #t]
                     [(eq? (syntax-e s) (syntax-e (car lits))) #f]
                     [else (loop (cdr lits))]))))]
             
          [get-pattern-vars
      (lambda (pattern0)
        (let loop ([pattern pattern0]
                   [depth 0]
                   [vars null])
          (cond
            [(stx-null? pattern)
             ; empty list
             vars]
            [(stx-pair? pattern)
             ; pair / list
             (let* ([p (syntax-e pattern)]
                    [head-pat (car p)]
                    [tail-pat (if (syntax? (cdr p))
                                  (cdr p)
                                  (datum->syntax (cdr p)))]
                    [ellipsis-next? (and (stx-pair? tail-pat)
                                        (identifier? (stx-car tail-pat))
                                        (free-identifier=? (stx-car tail-pat)
                                                           (quote-syntax ...)))])
               (if ellipsis-next?
                   (let ([vars (loop head-pat (+ depth 1) vars)]
                         [tail-pat (datum->syntax (stx-cdr tail-pat))])
                     (loop tail-pat depth vars))
                   (let ([vars (loop head-pat depth vars)])
                     (loop tail-pat depth vars))))]
            [(and (identifier? pattern)
                  (free-identifier=? pattern (quote-syntax _)))
             ; wildcard
             vars]
            [(variable? pattern)
             ; variable
             (cons (cons (syntax-e pattern) depth) vars)]
            [(not (syntax? (syntax-e pattern)))
             ;; datum
             vars]
            [else
             (error 'syntax-case "improper pattern" stx pattern0)])))]

          [gen-matcher
      (lambda (pattern0)
        (define (stx-_? stx)
          (and (identifier? stx)
               (eq? (syntax-e stx) '_)))

        (define (stx-...? stx)
          (and (identifier? stx)
               (eq? (syntax-e stx) '...)))

        (define (gen-match/expr pattern arg)
          (cond
            [(stx-pair? pattern)
             ; (non-empty) list / improper list
             (define-values (before-ellipsis after-ellipsis ellipsis? tail?)
               (let loop ([pat pattern] [idx-be 0] [idx-ae 0] [ellipsis? #f])
                 (cond
                  [(stx-null? pat)
                   (values idx-be idx-ae ellipsis? #f)]
                  [(stx-pair? pat)
                   (cond
                     [(stx-...? (stx-car pat))
                      (cond
                        [ellipsis?
                         (syntax-error 'syntax-case "ellipsis in pattern follows other ellipsis"
                                       pattern (stx-car pat))]
                        [(= idx-be 0)
                         (syntax-error 'syntax-case "ellipsis in pattern not preceded by a subpattern"
                                       pattern (stx-car pat))]
                        [else
                         (loop (stx-cdr pat) idx-be idx-ae #t)])]
                     [ellipsis?
                      (loop (stx-cdr pat) idx-be (+ idx-ae 1) ellipsis?)]
                     [else
                      (loop (stx-cdr pat) (+ idx-be 1) idx-ae ellipsis?)])]
                  [else
                   (values idx-be idx-ae ellipsis? #t)])))

             ; case split based on existence and placement of the ellipsis
             (cond
               [(or (not ellipsis?) (= after-ellipsis 0))
                ; no ellipsis / ellipsis at the end
                (let loop ([pat pattern] [idx 0] [arg arg])
                  (cond
                    [(= idx before-ellipsis)
                     ; end (tail) of list => 
                     ;  match on empty list (tail)
                     (if tail?
                         (gen-match/datum pat arg)
                         (gen-match/datum (quote-syntax ()) arg))]
                    [else
                     (define head-pat (stx-car pat))
                     (define tail-pat
                             (let ([tail (stx-cdr pat)])
                               (if (syntax? tail)
                                   tail
                                   (datum->syntax tail))))
                     (datum->syntax
                       (list
                         (list
                           (quote-syntax lambda)
                           (list (quote-syntax e))
                           (cond
                             [(and ellipsis? (= (+ idx 1) before-ellipsis))
                              (list
                                (quote-syntax if)
                                (list
                                  (quote-syntax stx-list?)
                                  (quote-syntax e))
                                (list
                                  (quote-syntax if)
                                  (list
                                    (quote-syntax stx-null?)
                                    (quote-syntax e))
                                  (let ([n (length (get-pattern-vars head-pat))])
                                    (cons
                                      (quote-syntax list)
                                      (let loop ([i 0] [acc null])
                                        (cond [(>= i n) acc]
                                              [else (loop (+ i 1) (cons 'null acc))]))))
                                  (list
                                    (quote-syntax let)
                                    (list
                                      (list
                                        (quote-syntax tmp)
                                        (list
                                          (quote-syntax map/#f)
                                          (list
                                            (quote-syntax lambda)
                                            (list (quote-syntax e))
                                            (gen-match/expr head-pat (quote-syntax e)))
                                          (list
                                            (quote-syntax stx->list)
                                            (quote-syntax e)))))
                                    (list
                                      (quote-syntax if)
                                      (quote-syntax tmp)
                                      (list
                                        (quote-syntax if)
                                        (list
                                          (quote-syntax null?)
                                          (quote-syntax tmp))
                                        (quote-syntax tmp)
                                        (list
                                          (quote-syntax apply)
                                          (quote-syntax map)
                                          (quote-syntax list)
                                          (quote-syntax tmp)))
                                      #f)))
                                #f)]
                             [(stx-_? head-pat)
                              ; wildcard =>
                              ;  check that list if not empty, then skip head
                              (list
                                (quote-syntax if)
                                (list
                                  (quote-syntax stx-null/#f)
                                  (quote-syntax e))
                                #f
                                (loop tail-pat (+ idx 1)
                                      (datum->syntax
                                        (list
                                          (quote-syntax stx-cdr)
                                          (quote-syntax e)))))]
                             [(variable? head-pat)
                              ; variable =>
                              ;  bind one variable
                              (list
                                (quote-syntax cons/#f)
                                  (list
                                    (quote-syntax stx-car)
                                    (quote-syntax e))
                                  (loop tail-pat (+ idx 1)
                                        (datum->syntax
                                          (list
                                            (quote-syntax stx-cdr)
                                            (quote-syntax e)))))]
                             [(stx-pair? head-pat)
                              ; subpattern =>
                              ;  recurse and append
                              (list
                                (quote-syntax append/#f)
                                (gen-match/expr head-pat
                                                (datum->syntax
                                                  (list
                                                    (quote-syntax stx-car)
                                                    (quote-syntax e))))
                                (loop tail-pat (+ idx 1)
                                      (datum->syntax
                                        (list
                                          (quote-syntax stx-cdr)
                                          (quote-syntax e)))))]
                             [else
                              ; datum =>
                              ;  just check if it matches
                              (list
                                (quote-syntax if)
                                (gen-match/expr head-pat
                                                (datum->syntax
                                                  (list
                                                    (quote-syntax stx-car)
                                                    (quote-syntax e))))
                                (loop tail-pat (+ idx 1)
                                      (datum->syntax
                                        (list
                                          (quote-syntax stx-cdr)
                                          (quote-syntax e))))
                                #f)]))
                         arg))]))]
               [else
                ; ellipsis are not at the end
                (error #f "unimplemented")])]
            [else
             (gen-match/datum pattern arg)]))

        (define (gen-match/datum pattern arg)
          (cond
            [(stx-null? pattern)
             ; empty list
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax stx-null/#f)
                     (quote-syntax e)))
                 arg))]
            [(stx-_? pattern)
             ; wildcard
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (quote-syntax null))
                 arg))]
            [(variable? pattern)
             ; variable
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax list)
                     (quote-syntax e)))
                 arg))]
            [(not (syntax? (syntax-e pattern)))
             ;; datum
             (datum->syntax
               (list
                 (list
                   (quote-syntax lambda)
                   (list (quote-syntax e))
                   (list
                     (quote-syntax if)
                     (list
                       (quote-syntax equal?)
                       (list
                         (quote-syntax quote)
                         (syntax-e pattern))
                       (list
                         (quote-syntax syntax-e)
                         (quote-syntax e)))
                     (quote-syntax null)
                     #f))
                 arg))]
            [else
             (error 'syntax-case "improper pattern" stx pattern0)]))
          
        (gen-match/expr pattern0 arg))])
      
      (datum->syntax
        (list
          (quote-syntax let)
          (list (list arg expr))
          (let loop ([patterns patterns]
                     [fenders fenders]
                     [results results])
            (if (null? patterns)
                (list
                  (quote-syntax syntax-error)
                  #f
                  "bad syntax"
                  arg)
              (let* ([pattern (car patterns)]
                     [fender (car fenders)]
                     [result (car results)]
                     [pat-vars (reverse (get-pattern-vars pattern))]
                     [matcher (gen-matcher pattern)]
                     [result-stx (quote-syntax rslt)]
                     [temp-vars (map (lambda (t)
                                       (gen-temp-id "sc"))
                                     pat-vars)])

                (let ([bind-vars
                       (lambda (e)
                         (datum->syntax
                           (list
                             (quote-syntax let)
                             (let loop ([pat-vars pat-vars]
                                        [temp-vars temp-vars]
                                        [result-stx result-stx]
                                        [bindings null])
                               (if (null? pat-vars)
                                   (reverse bindings)
                                   (loop (cdr pat-vars)
                                         (cdr temp-vars)
                                         (datum->syntax
                                           (list
                                             (quote-syntax cdr)
                                             result-stx))
                                         (cons
                                           (list (car temp-vars)
                                                 (list
                                                   (quote-syntax car)
                                                   result-stx))
                                           bindings))))
                             e)))]
                    
                      [gen-syntaxes
                       (lambda (e)
                         (list
                           (quote-syntax let-syntaxes)
                           (map (lambda (pat-var temp-var)
                                  (list
                                    (list (car pat-var))
                                    (list
                                      (quote-syntax make-pattern-variable)
                                      (list
                                        (quote-syntax quote-syntax)
                                        temp-var)
                                      (list
                                        (quote-syntax quote)
                                        (cdr pat-var)))))
                                pat-vars temp-vars)
                           e))])

                  (list
                    (quote-syntax let)
                    (list (list result-stx matcher))
                    (list
                      (quote-syntax if)
                      (if fender
                          (list
                            (quote-syntax and)
                            result-stx
                            (bind-vars
                              (gen-syntaxes
                                (list
                                  (list
                                    (quote-syntax lambda)
                                    (list)
                                    fender)))))
                          result-stx)
                      (bind-vars
                        (gen-syntaxes
                          (list
                            (quote-syntax let-values)
                            (quote-syntax ())
                            result)))

                      (loop (cdr patterns)
                            (cdr fenders)
                            (cdr results)))))))))))))

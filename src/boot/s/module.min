;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   File reader for importing Minim files
;;;

;; Base environment when loading modules
(define $base-env (environment))

;; Module cache
;;  name -> (xforms, exports)
(define $module-table '())

(define ($load-module name)
  ;; current parameters
  (define cwd (current-directory))

  ;; resolve path
  (define path
    (if (is-absolute-path? name)
        name
        (build-path cwd name)))
  (define new-cwd (car (split-path path)))

  ;; module information
  (define exported '())
  (define imported '())
  (define module-env #f)

  ;; read phase
  (define ($read)
    (define p (open-input-file path))
    (let loop ([exprs '()])
      (define datum (read p))
      (cond
        [(eof-object? datum)
         (close-input-port p)
         (reverse exprs)]
        [else
         (loop (cons datum exprs))])))

  ;; import phase
  (define ($import exprs)
    (let loop ([exprs exprs] [evalable '()])
      (cond
        [(null? exprs)
         (reverse evalable)]
        [else
         (define expr (syntax-e (car exprs)))
         (cond
           [(and (pair? expr) (eq? (syntax-e (car expr)) 'import))
            (let loop2 ([imports (cdr expr)])
              (define imports* (syntax-e imports))
              (cond
                [(null? imports*)
                 (loop (cdr exprs) evalable)]
                [(pair? imports*)
                 (define maybe-import (syntax-e (car imports*)))
                 (cond
                   [(string? maybe-import)
                    (define path (build-path new-cwd maybe-import))
                    (define maybe-cached (assoc path $module-table))
                    (define from-module
                      (if maybe-cached
                          (cdr maybe-cached)
                          (begin
                            ($load-module path)
                            (cdr (assoc path $module-table)))))
                    (set! imported (append from-module imported))
                    (loop2 (cdr imports*))]
                   [else
                    (error 'import "bad syntax")])]
                [else
                 (error 'import "bad syntax")]))]
           [(and (pair? expr) (eq? (syntax-e (car expr)) 'export))
            (let loop2 ([exports (cdr expr)])
              (define exports* (syntax-e exports))
              (cond
                [(null? exports*)
                 (loop (cdr exprs) evalable)]
                [(pair? exports*)
                 (define maybe-export (syntax-e (car exports*)))
                 (cond
                   [(symbol? maybe-export)
                    (set! exported (cons maybe-export exported))
                    (loop2 (cdr exports*))]
                   [else
                    (error 'export "bad syntax")])]
                [else
                 (error 'import "bad syntax")]))]
           [else
            (loop (cdr exprs) (cons (car exprs) evalable))])])))

  ;; expand phase
  (define ($expand exprs)
    (let loop ([exprs exprs] [acc '()])
      (cond
        [(null? exprs)
         (reverse acc)]
        [else
         (define expanded-and-xforms (expand (car exprs) xforms))
         (set! xforms (cdr expanded-and-xforms))
         (loop (cdr exprs) (cons (car expanded-and-xforms) acc))])))

  ;; eval phase
  (define ($eval exprs)
    (define env (extend-environment $base-env))
    (let loop ([imported imported])
      (cond
        [(null? imported) (void)]
        [else
         (define name (caar imported))
         (define value (cdar imported))
         (environment-set-variable-value! env name value)
         (loop (cdr imported))]))
         
    (set! module-env env)
    (let loop ([exprs exprs] [result (void)])
      (if (null? exprs)
          result
          (loop (cdr exprs)
                (eval (syntax->datum (car exprs)) env)))))

  ;; apply non-eval phases
  (define raw-exprs ($read))
  (define non-import-exprs ($import raw-exprs))
  (define expanded-exprs ($expand non-import-exprs))

  ;; evaluate
  (current-directory new-cwd)
  (define last ($eval expanded-exprs))
  (current-directory cwd)

  ;; handle exports
  (define export-map
    (let loop ([exported exported] [accum '()])
      (cond
        [(null? exported) (reverse accum)]
        [else
         (define export (car exported))
         (define value
           (environment-variable-value
             module-env
             export
             (lambda () (error 'export "undefined export" export))))
         (loop (cdr exported) (cons (cons export value) accum))])))

  ;; update module table
  (set! $module-table
        (cons (cons path (cons '() export-map))
              $module-table))

  ;; and done
  last)

(define (load name)
  ($load-module name))

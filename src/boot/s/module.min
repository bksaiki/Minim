;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   File reader for importing Minim files
;;;

;; Base environment when loading modules
(define $base-env (environment))

;; Module cache
;;  name -> (exporting xforms, exporting values)
(define $module-table '())
;;  name -> (current xforms, current env)
(define $module-envs '())

;; Like `$load-module`, but does not check the cache
(define ($load-module path)
  ;; paths
  (define new-cwd (car (split-path path)))

  ;; module information
  (define exported '())
  (define imported '())
  (define imported-xforms '())
  (define module-env (extend-environment $base-env))
  (define module-xforms '())

  ;; read phase
  (define ($read)
    (define p (open-input-file path))
    (let loop ([exprs '()])
      (define datum (read p))
      (cond
        [(eof-object? datum)
         (close-input-port p)
         (reverse exprs)]
        [else
         (loop (cons datum exprs))])))

  ;; import phase
  (define ($import exprs)
    (let loop ([exprs exprs] [evalable '()])
      (cond
        [(null? exprs)
         (reverse evalable)]
        [else
         (define expr (syntax-e (car exprs)))
         (cond
           [(and (pair? expr) (eq? (syntax-e (car expr)) 'import))
            (let loop2 ([imports (cdr expr)])
              (cond
                [(null? imports)
                 (loop (cdr exprs) evalable)]
                [(pair? imports)
                 (define maybe-import (syntax-e (car imports)))
                 (cond
                   [(string? maybe-import)
                    (define path (build-path new-cwd maybe-import))
                    (import path)
                    (define from-module (assoc path $module-table))
                    (set! imported-xforms (append (car from-module) imported-xforms))
                    (set! imported (append (cdr from-module) imported))
                    (loop2 (cdr imports))]
                   [else
                    (error 'import "bad syntax")])]
                [else
                 (error 'import "bad syntax")]))]
           [(and (pair? expr) (eq? (syntax-e (car expr)) 'export))
            (let loop2 ([exports (cdr expr)])
              (cond
                [(null? exports)
                 (loop (cdr exprs) evalable)]
                [(pair? exports)
                 (define maybe-export (syntax-e (car exports)))
                 (cond
                   [(symbol? maybe-export)
                    (set! exported (cons maybe-export exported))
                    (loop2 (cdr exports))]
                   [else
                    (error 'export "bad syntax")])]
                [else
                 (error 'export "bad syntax")]))]
           [else
            (loop (cdr exprs) (cons (car exprs) evalable))])])))

  ;; expand phase
  (define ($expand exprs)
    (define stx-env (extend-environment $base-env))
    ;; setup environment
    (let loop ([imported imported])
      (cond
        [(null? imported) (void)]
        [else
         (define name (caar imported))
         (define value (cdar imported))
         (environment-set-variable-value! stx-env name value)
         (loop (cdr imported))]))

    ;; apply transformers
    (define old-xforms $xforms)
    (set! module-xforms imported-xforms)
    (let loop ([exprs exprs] [acc '()])
      (cond
        [(null? exprs)
         (set! $xforms old-xforms)
         (reverse acc)]
        [else
         (define expanded (expand (car exprs)))
         (define expanded* (syntax-e expanded))
         (cond
           [(and (pair? expanded*) (eq? (syntax-e (car expanded*)) 'define-syntax))
            (define (panic!) (syntax-error 'define-syntax "bad syntax" expanded))
            (define rib (cdr expanded*))
            (cond
              [(and (pair? rib) (symbol? (syntax-e (car rib))))
               (define xform-name (syntax-e (car rib)))
               (define rib (cdr rib))
               (cond
                 [(and (pair? rib) (null? (cdr rib)))
                  (set! $xforms (map cdr module-xforms))
                  (define xform (eval (syntax->datum (car rib)) stx-env))
                  (set! module-xforms (cons (cons xform-name xform) module-xforms))]
                 [else
                  (panic!)])]
               [else
                (panic!)])
            (loop (cdr exprs) acc)]
           [else
            (loop (cdr exprs) (cons expanded acc))])])))

  ;; apply non-eval phases
  (define raw-exprs ($read))
  (define non-import-exprs ($import raw-exprs))
  (define expanded-exprs ($expand non-import-exprs))
 
  ;; return result
  (list expanded-exprs module-xforms imported exported))

;; prepares the evaluation environment given
;; an association list of additional values
(define ($eval-environment env imports)
  (define env* (extend-environment env))
  (let loop ([imports imports])
    (cond
      [(null? imports) env*]
      [else
       (define name (caar imports))
       (define value (cdar imports))
       (environment-set-variable-value! env* name value)
       (loop (cdr imports))])))

;; evaluates a set of expressions under a given environment
(define ($eval-exprs exprs env print-handler)
  (let loop ([exprs exprs] [result (void)])
    (cond
      [(null? exprs) result]
      [else
       (define result (eval (syntax->datum (car exprs)) env))
       (cond [(and print-handler (not (void? result)))
              (print-handler result)])
       (loop (cdr exprs) result)])))

(define ($load-or-import-no-check path print-handler result-handler)
  ;; paths
  (define cwd (current-directory))
  (define new-cwd (car (split-path path)))
  ;; load expressions
  (define module-info ($load-module path))
  (define exprs (car module-info))
  (define module-xforms (cadr module-info))
  (define imports (caddr module-info))
  (define exports (cadddr module-info))
  ;; evaluate
  (current-directory new-cwd)
  (define env ($eval-environment $base-env imports))
  (define last ($eval-exprs exprs env print-handler))
  (current-directory cwd)
  ;; handle exports
  (define export-values '())
  (define export-xforms '())
  (let loop ([exports exports])
    (cond
      [(null? exports) (void)]
      [else
       (define export (car exports))
       (define maybe-xform (assoc export module-xforms))
       (cond
         [maybe-xform
          (set! export-xforms (cons (cons export maybe-xform) export-xforms))]
         [else
          (define value
            (environment-variable-value env export
              (lambda () (error 'export "undefined export" export))))
          (set! export-values (cons (cons export value) export-values))])
       (loop (cdr exports))]))

  ;; update module tables
  (set! $module-table (cons (cons path (cons export-xforms export-values)) $module-table))
  (set! $module-envs (cons (cons path (cons module-xforms env)) $module-envs))

  ;; and done
  (cond [result-handler (result-handler last)]))

;; REPL with env
(define ($repl xforms env)
  (set! $xforms xforms)
  (let loop ()
    ;; read
    (display "> ")
    (define stx (read))
    (cond [(eof-object? stx) (exit)])
    ;; expand
    (define stx* (expand stx))
    ;; evaluate
    (define result (eval (syntax->datum stx*) env))
    ;; display
    (cond [(not (void? result)) (writeln result)])
    (loop)))

(define ($load-or-import name print-handler result-handler)
  ;; resolve path
  (define path
    (if (is-absolute-path? name)
        name
        (build-path (current-directory) name)))
  ;; check cache first
  (cond [(not (assoc path $module-table))
         ($load-or-import-no-check path print-handler result-handler)]))

;; imports a file
(define (import name)
  ($load-or-import name (lambda (o) (writeln o)) #f))

;; loads a file
(define (load name)
  (define result ($load-or-import name #f (lambda (o) o)))
  (cond [(not (void? result)) (writeln result)])
  (enter! name))

(define (enter! name)
  ;; resolve path
  (define path
    (if (is-absolute-path? name)
        name
        (build-path (current-directory) name)))
  ;; set up environment
  (define maybe-env (assoc path $module-envs))
  (cond [(not maybe-env)
         (error 'enter! "unknown module" name)])
  ;; REPL
  ($repl (car maybe-env) (extend-environment (cdr maybe-env))))

;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Redefines read functions
;;;   Overwrites primitive functions
;;;

;; Rebind primitives
(define $read read)
(define $load load)

;; Reader
(define (read . args)
  ;; argument selection
  (define p
    (cond
      [(null? args)       (current-input-port)]
      [(null? (cdr args)) (car args)]
      [else
       (error "read: arity mismatch\n expected 0 or 1 arguments,"
              "received" (length args))]))

    (if (not (input-port? p))
        (error "read: expected an input port, received " p)
        (void))

    ;; Character

    (define oparen (integer->char 40))
    (define cparen (integer->char 41))
    (define obrack (integer->char 91))
    (define cbrack (integer->char 93))
    (define obrace (integer->char 123))
    (define cbrace (integer->char 125))

    (define (space? c)
      (or (eq? c #\space)
          (eq? c #\newline)))

    (define (delimeter? c)
      (or (eof-object? c) (space? c)
          (eq? c oparen) (eq? c obrack) (eq? c obrace)
          (eq? c cparen) (eq? c cbrack) (eq? c cbrace)
          (eq? c #\") (eq? c #\;)))

    (define (symbol-char? c)
      (not (or (eq? c #\#) (delimeter? c))))

    (define (digit? c)
      (and (<= (char->integer #\0) (char->integer c))
           (<= (char->integer c) (char->integer #\9))))

    (define (digit-prefix? c)
      (or (digit? c)
          (and (or (eq? c #\-) (eq? c #\+))
               (digit? (peek-char p)))))

    ;; Errors

    (define (assert-not-eof! c)
      (if (eof-object? c)
          (error "read: unexpected end of input")
          (void)))

    (define (assert-matching-parens! open close)
      (if (or (and (eq? open oparen) (eq? close cparen))
              (and (eq? open obrack) (eq? close cbrack))
              (and (eq? open obrace) (eq? close cbrace)))
          (void)
          (error "read: parenthesis mismatch " open " " close)))

    (define (assert-delimeter! c)
      (if (not (delimeter? c))
          (error "read: expected a delimeter")
          (void)))

    ;; Whitespace reading
    
    (define (skip-comment!)
      (define c (peek-char p))
      (cond
        [(eof-object? c)   (void)]
        [(eq? c #\newline) (void)]
        [else
         (read-char p)
         (skip-comment!)]))

    (define (skip-block-comment!)
      (let loop ([block-level 1])
        (cond
          [(= block-level 0) (void)]
          [else
           (define c (read-char p))
           (cond
             [(eq? c #\#)
              (define c (peek-char p))
              (assert-not-eof! c)
              (cond
                [(eq? c #\|)
                 (read-char p)
                 (loop (+ block-level 1))]
                [else
                 (loop block-level)])]
                [(eq? c #\|)
                 (define c (peek-char p))
                 (assert-not-eof! c)
                 (cond
                   [(eq? c #\#)
                    (read-char p)
                    (loop (- block-level 1))]
                   [else
                    (loop block-level)])]
                [else
                  (loop block-level)])])))

    (define (skip-until-token!)
      (define c (peek-char p))
      (cond
        [(space? c)
         (read-char p)
         (skip-until-token!)]
        [(eq? c #\;)
         (read-char p)
         (skip-comment!)
         (skip-until-token!)]
        [else
         (void)]))

    (define (check-expected-string! s)
      (define len (string-length s))
      (let loop ([i 0])
        (cond
          [(< i len)
           (define c (read-char p))
           (cond
             [(eof-object? c)
              (error "read: unexpected end of input")]
             [(eq? c (string-ref s i))
              (loop (+ i 1))]
             [else
              (error "read: unexpected character" c)])]
          [else
           (void)])))

    ; pair reader
    (define (read-pair open)
      (skip-until-token!)
      (define c (peek-char p))
      (assert-not-eof! c)

      (cond
        [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
         (assert-matching-parens! open c)
         (read-char p)
         '()]
        [else
         (define car (read-loop))
         (skip-until-token!)
         (define c (peek-char p))
         (assert-not-eof! c)

         (cond
           [(eq? c #\.)
            ; improper list
            (read-char p)
            (assert-delimeter! (peek-char p))
            (define cdr (read-loop))

            (skip-until-token!)
            (define c (peek-char p))
            (assert-not-eof! c)

            (cond
              [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
               (assert-matching-parens! open c)
               (read-char p)
               (cons car cdr)]
              [else
               (error "read: missing closing parenthesis")])]
           [else
            (define cdr (read-pair open))
            (cons car cdr)])]))

    ; character reader
    (define (read-character)
      (define c (read-char p))  
      (if (eof-object? c)
          (error "read: incomplete character literal")
          (void))
        
      ; check for special values
      (cond
        [(eq? c #\s)
         (define cn (peek-char p))
         (cond
           [(eq? cn #\p)
            (check-expected-string! "pace")
            #\space]
           [else
            (assert-delimeter! (peek-char p))
            c])]
        [(eq? c #\n)
         (define cn (peek-char p))
         (cond
           [(eq? cn #\e)
            (check-expected-string! "ewline")
            #\newline]
           [else
            (assert-delimeter! (peek-char p))
            c])]
        [else
         (assert-delimeter! (peek-char p))
         c]))

    ; number reader
    (define (read-number c)
      ; optional sign
      (define num 0)
      (define sign
        (cond
          [(eq? c #\-)
           (read-char p)
           -1]
          [(eq? c #\+)
           (read-char p)
           1]
          [else
           1]))

      ; magnitude
      (let read-digit! ()
        (define c (peek-char p))
        (cond
          [(digit? c)
           (read-char p)
           (set! num (+ (* 10 num) (- (char->integer c) (char->integer #\0))))
           (read-digit!)]
          [else
           (assert-delimeter! (peek-char p))
           (* num sign)])))

    ; string reader
    (define (read-string)
      (let loop ([acc '()])
        (define c (peek-char p))
        (cond
          [(eof-object? c)
           (error "read: non-terminated string literal")
           (void)]
          [(eq? c #\\)
           ; escape character
           (read-char p)
           (define c (peek-char p))
           (cond
             [(eq? c #\n)
              (read-char p)
              (loop (cons #\newline acc))]
             [(eq? c #\\)
              (read-char p)
              (loop (cons #\\ acc))]
             [else
              (error "read: unknown escape character" c)])]
             [(eq? c #\")
              (read-char p)
              (reverse acc)]
             [else
              (read-char p)
              (loop (cons c acc))])))

    ;; Main loop

    (define (read-loop)
      ; read and branch
      (skip-until-token!)
      (define c (peek-char p))
      (cond
        [(eof-object? c)
         (read-char p)
         c]
        [(eq? c #\#)
         (read-char p)
         ; special values
         (define c (peek-char p))
         (cond
           [(eq? c #\t)
            ; true
            (read-char p)
            (datum->syntax #t)]
           [(eq? c #\f)
            ; false
            (read-char p)
            (datum->syntax #f)]
           [(eq? c #\\)
            ; character
            (read-char p)
            (datum->syntax (read-character))]
           [(eq? c #\')
            ; quoted syntax
            (read-char p)
            (datum->syntax (list 'quote-syntax (read-loop)))]
           [(eq? c #\;)
            ; datum comment
            (read-char p)
            (skip-until-token!)
            (define c (peek-char p))
            (assert-not-eof! c)
                
            ; read and ignore, then actually read
            (read-loop)
            (read-loop)]
           [(eq? c #\|)
            ; block comment
            (read-char p)         
            (skip-block-comment!)
            (datum->syntax (read-loop))]
           [else
            ; unknown
            (error "read: unknown special character" c)])]
        [(digit-prefix? c)
          ; number
          (datum->syntax (read-number c))]
        [(eq? c #\")
         ; string
         (read-char p)
         (define str-chars (read-string))
         (assert-delimeter! (peek-char p))
         (datum->syntax (apply string str-chars))]
        [(or (eq? c oparen) (eq? c obrack) (eq? c obrace))
         ; pair
         (read-char p)
         (datum->syntax (read-pair c))]
        [(eq? c #\')
         ; quoted form
         (read-char p)
         (datum->syntax (list 'quote (read-loop)))]
        [(symbol-char? c)
         ; symbol
         (define (read-symbol acc)
           (define c (peek-char p))
           (if (symbol-char? c)
               (read-symbol (cons (read-char p) acc))
               (reverse acc)))

         (define sym-chars (read-symbol '()))
         (assert-delimeter! (peek-char p))
         (datum->syntax (string->symbol (apply string sym-chars)))]
        [else
         (error "read: unexpected input:" c)]))

  (read-loop))

(define (syntax->datum stx)
  (define e (syntax-e stx))
  (if (pair? e)
      (cons (syntax->datum (car e))
            (syntax->datum (cdr e)))
      e))

(define (load name)
  (define p (open-input-file name))
  (let loop ()
    (define stx (read p))
    (cond
      [(eof-object? stx)
       (void)]
      [else
       (eval (syntax->datum stx))
       (loop)]))
  (close-input-port p))

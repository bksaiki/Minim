;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Redefines read functions
;;;   Overwrites primitive functions
;;;

;; Rebind primitives
(define $read read)
(define $load load)

(define read
  (lambda args

    ;; Argument selection
  
    (define p
      (cond
        [(null? args)       (current-input-port)]
        [(null? (cdr args)) (car args)]
        [else
          (error "read: arity mismatch\n expected 0 or 1 arguments,"
                 "received" (length args))]))

    (if (not (input-port? p))
        (error "read: expected an input port, received " p)
        (void))

    ;; Character

    (define oparen (integer->char 40))
    (define cparen (integer->char 41))
    (define obrack (integer->char 91))
    (define cbrack (integer->char 93))
    (define obrace (integer->char 123))
    (define cbrace (integer->char 125))

    (define space?
      (lambda (c)
        (or (eq? c #\space)
            (eq? c #\newline))))

    (define delimeter?
      (lambda (c)
        (or (eof-object? c) (space? c)
            (eq? c oparen) (eq? c obrack) (eq? c obrace)
            (eq? c cparen) (eq? c cbrack) (eq? c cbrace)
            (eq? c #\") (eq? c #\;))))

    (define symbol-char?
      (lambda (c)
        (not (or (eq? c #\#)
             (delimeter? c)))))

    (define digit?
      (lambda (c)
        (and (<= (char->integer #\0) (char->integer c))
             (<= (char->integer c) (char->integer #\9)))))

    (define digit-prefix?
      (lambda (c)
        (or (digit? c)
            (and (or (eq? c #\-) (eq? c #\+))
                 (digit? (peek-char c))))))

    ;; Errors

    (define assert-not-eof!
      (lambda (c)
        (if (eof-object? c)
            (error "read: unexpected end of input")
            (void))))

    (define assert-matching-parens!
      (lambda (open close)
        (cond
          [(and (eq? open oparen)       ; ()
                (eq? close cparen))
            (void)]
          [(and (eq? open obrack)       ; []
                (eq? close cbrack))
            (void)]
          [(and (eq? open obrace)       ; {}
                (eq? close cbrace))
            (void)]
          [else
            (error "read: parenthesis mismatch " open " " close)])))

    (define assert-delimeter!
      (lambda (c)
        (if (not (delimeter? c))
            (error "read: expected a delimeter")
            (void))))

    ;; Whitespace reading
    
    (define skip-comment!
      (lambda ()
        (define c (peek-char p))
        (cond
          [(eof-object? c)   (void)]
          [(eq? c #\newline) (void)]
          [else
           (read-char p)
           (skip-comment!)])))

    (define skip-block-comment!
      (lambda ()

        (define loop
          (lambda (block-level)
            (cond
              [(= block-level 0) (void)]
              [else
                (define c (read-char p))
                (cond
                  [(eq? c #\#)
                    (define c (peek-char p))
                    (assert-not-eof! c)
                    (cond
                      [(eq? c #\|)
                        (read-char p)
                        (loop (+ block-level 1))]
                      [else
                        (loop block-level)])]
                  [(eq? c #\|)
                    (define c (peek-char p))
                    (assert-not-eof! c)
                    (cond
                      [(eq? c #\#)
                        (read-char p)
                        (loop (- block-level 1))]
                      [else
                        (loop block-level)])]
                  [else
                    (loop block-level)])])))

        (loop 1)))

    (define skip-until-token!
      (lambda ()
        (define c (peek-char p))
        (cond
          [(space? c)
           (read-char p)
           (skip-until-token!)]
          [(eq? c #\;)
           (read-char p)
           (skip-comment!)
           (skip-until-token!)]
          [else
           (void)])))

    (define check-expected-string!
      (lambda (s)
        (define len (string-length s))

        (define loop
          (lambda (i)
            (if (= i len)
                (void)
                (let ([c (read-char p)])
                  (cond
                    [(eof-object? c)
                      (error "read: unexpected end of input")]
                    [(eq? c (string-ref s i))
                      (loop (+ i 1))]
                    [else
                      (error "read: unexpected character" c)])))))

        (loop 0)))

    ; pair reader
    (define read-pair
      (lambda (open)
        (skip-until-token!)
        (define c (peek-char p))
        (assert-not-eof! c)

        (cond
          [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
            (assert-matching-parens! open c)
            (read-char p)
            '()]
          [else
            (define car (read-loop))
            (skip-until-token!)
            (define c (peek-char p))
            (assert-not-eof! c)

            (cond
              [(eq? c #\.)
                ; improper list
                (read-char p)
                (assert-delimeter! (peek-char p))
                (define cdr (read-loop))

                (skip-until-token!)
                (define c (peek-char p))
                (assert-not-eof! c)

                (cond
                  [(or (eq? c cparen) (eq? c cbrack) (eq? c cbrace))
                    (assert-matching-parens! open c)
                    (read-char p)
                    (cons car cdr)]
                  [else
                    (error "read: missing closing parenthesis")])]
              [else
                (define cdr (read-pair open))
                (cons car cdr)])])))

    ; character reader
    (define read-character
      (lambda ()
        (define c (read-char p))
        
        (if (eof-object? c)
            (error "read: incomplete character literal")
            (void))
        
        ; check for special values
        (cond
          [(eq? c #\s)
            (define cn (peek-char p))
            (cond
              [(eq? cn #\p)
                (check-expected-string! "pace")
                #\space]
              [else
                (assert-delimeter! (peek-char p))
                c])]
          [(eq? c #\n)
            (define cn (peek-char p))
            (cond
              [(eq? cn #\e)
                (check-expected-string! "ewline")
                #\newline]
              [else
                (assert-delimeter! (peek-char p))
                c])]
          [else
            (assert-delimeter! (peek-char p))
            c])))

    ; number reader
    (define read-number
      (lambda (c)
        ; optional sign
        (define num 0)
        (define sign
          (cond
            [(eq? c #\-)
              (read-char p)
              -1]
            [(eq? c #\+)
              (read-char p)
              1]
            [else
              1]))

        ; magnitude
        (define read-digit!
          (lambda ()
            (define c (peek-char p))
            (cond
              [(digit? c)
                (read-char p)
                (set! num (+ (* 10 num) (- (char->integer c) (char->integer #\0))))
                (read-digit!)]
              [else
                (void)])))

        (read-digit!)
        (assert-delimeter! (peek-char p))
        (* num sign)))

    ; number reader
    (define read-string
      (lambda ()
        (define loop
          (lambda (acc)
            (define c (peek-char p))

            (cond
              [(eof-object? c)
                (error "read: non-terminated string literal")
                (void)]
              [(eq? c #\\)
                ; escape character
                (read-char p)
                (define c (peek-char p))
                (cond
                  [(eq? c #\n)
                    (read-char p)
                    (loop (cons #\newline acc))]
                  [(eq? c #\\)
                    (read-char p)
                    (loop (cons #\\ acc))]
                  [else
                    (error "read: unknown escape character" c)])]
              [(eq? c #\")
                (read-char p)
                (reverse acc)]
              [else
                (read-char p)
                (loop (cons c acc))])))

        (loop '())))

    ;; Main loop

    (define read-loop
      (lambda ()

        ; read and branch

        (skip-until-token!)
        (define c (peek-char p))
        (cond
          [(eof-object? c)
            (read-char p)
            c]
          [(eq? c #\#)
            (read-char p)
            ; special values
            (define c (peek-char p))
            (cond
              [(eq? c #\t)
                ; true
                (read-char p)
                #t]
              [(eq? c #\f)
                ; false
                (read-char p)
                #f]
              [(eq? c #\\)
                ; character
                (read-char p)
                (read-character)]
              [(eq? c #\')
                ; quoted syntax
                (read-char p)
                (list 'quote-syntax (read-loop))]
              [(eq? c #\;)
                ; datum comment
                (read-char p)
                (skip-until-token!)
                (define c (peek-char p))
                (assert-not-eof! c)
                
                ; read and ignore, then actually read
                (read-loop)
                (read-loop)]
              [(eq? c #\|)
                ; block comment
                (read-char p)         
                (skip-block-comment!)
                (read-loop)]
              [else
                ; unknown
                (error "read: unknown special character" c)])]
          [(digit-prefix? c)
            ; number
            (read-number c)]
          [(eq? c #\")
            ; string
            (read-char p)
            (define str-chars (read-string))
            (assert-delimeter! (peek-char p))
            (apply string str-chars)]
          [(or (eq? c oparen) (eq? c obrack) (eq? c obrace))
            ; pair
            (read-char p)
            (read-pair c)]
          [(eq? c #\')
            ; quoted form
            (read-char p)
            (list 'quote (read-loop))]
          [(symbol-char? c)
            ; symbol

            (define read-symbol
              (lambda (acc)
                (define c (peek-char p))
                (if (symbol-char? c)
                    (read-symbol (cons (read-char p) acc))
                    (reverse acc))))

            (define sym-chars (read-symbol '()))
            (assert-delimeter! (peek-char p))
            (string->symbol (apply string sym-chars))]
          [else
            (error "read: unexpected input:" c)])))

    (read-loop)))

(define-values (cons*) (lambda (x . xs) (letrec-values (((loop) (lambda (x xs) (if (null? xs) x (cons x (loop (car xs) (cdr xs))))))) (loop x xs))))
(define-values (first) (lambda (xs) (if (list? xs) (car xs) (error (quote first) "list?" xs))))
(define-values (second) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote second) "list contains too few elements" xs))))) (loop xs 2)) (error (quote second) "list?" xs))))
(define-values (third) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote third) "list contains too few elements" xs))))) (loop xs 3)) (error (quote third) "list?" xs))))
(define-values (fourth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote fourth) "list contains too few elements" xs))))) (loop xs 4)) (error (quote fourth) "list?" xs))))
(define-values (fifth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote fifth) "list contains too few elements" xs))))) (loop xs 5)) (error (quote fifth) "list?" xs))))
(define-values (sixth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote sixth) "list contains too few elements" xs))))) (loop xs 6)) (error (quote sixth) "list?" xs))))
(define-values (seventh) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote seventh) "list contains too few elements" xs))))) (loop xs 7)) (error (quote seventh) "list?" xs))))
(define-values (eighth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote eighth) "list contains too few elements" xs))))) (loop xs 8)) (error (quote eighth) "list?" xs))))
(define-values (ninth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote ninth) "list contains too few elements" xs))))) (loop xs 9)) (error (quote ninth) "list?" xs))))
(define-values (tenth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote tenth) "list contains too few elements" xs))))) (loop xs 10)) (error (quote tenth) "list?" xs))))
(define-values (list-ref) (lambda (lst k) (if (integer? k) (void) (let-values () (error (quote list-ref) "expected a non-negative integer" k))) (letrec-values (((loop) (lambda (xs i) (if (null? xs) (error (quote list-ref) "index out of bounds" lst k) (if (= i k) (car xs) (loop (cdr xs) (+ i 1))))))) (loop lst 0))))
(define-values (member) (lambda (k xs) (letrec-values (((loop) (lambda (xs) (if (null? xs) #f (if (pair? xs) (if (equal? (car xs) k) (car xs) (loop (cdr xs))) (error (quote member) "expected a list" xs)))))) (loop xs))))
(define-values (remove) (lambda (k xs) (letrec-values (((loop) (lambda (xs) (if (null? xs) (quote ()) (if (pair? xs) (if (equal? (car xs) k) (loop (cdr xs)) (cons (car xs) (loop (cdr xs)))) (error (quote remove) "expected a list" xs)))))) (loop xs))))
(define-values (remove*) (lambda (ks xs) (if (list? ks) (void) (let-values () (error (quote remove*) "expected a list" ks))) (letrec-values (((loop) (lambda (ks xs) (if (null? ks) xs (if (null? xs) (quote ()) (loop (cdr ks) (letrec-values (((loop2) (lambda (xs) (if (null? xs) (quote ()) (if (pair? xs) (if (equal? (car xs) (car ks)) (loop2 (cdr xs)) (cons (car xs) (loop2 (cdr xs)))) (error (quote remove*) "expected a list" xs)))))) (loop2 xs)))))))) (loop ks xs))))
(define-values (filter) (lambda (f lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) (reverse acc) (if (pair? xs) (if (f (car xs)) (loop (cdr xs) (cons (car xs) acc)) (loop (cdr xs) acc)) (error (quote filter) "expected a list" lst)))))) (loop lst (quote ())))))
(define-values (foldl) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) acc (if (pair? xs) (loop (cdr xs) (f acc (car xs))) (error (quote foldl) "expected a list" lst)))))) (loop lst acc))))
(define-values (foldr) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs) (if (null? xs) acc (if (pair? xs) (f (loop (cdr xs)) (car xs)) (error (quote foldr) "expected a list" lst)))))) (loop lst))))
(define-values (assoc) (lambda (k lst) (letrec-values (((loop) (lambda (xs) (if (null? xs) #f (if (not (pair? xs)) (error (quote assoc) "not a proper list" lst) (if (not (pair? (car xs))) (error (quote assoc) "non-pair found in list" lst) (if (equal? k (caar xs)) (car xs) (loop (cdr xs))))))))) (loop lst))))
(define-values (index-of) (lambda (k lst) (letrec-values (((loop) (lambda (lst i) (if (null? lst) #f (if (equal? k (car lst)) i (loop (cdr lst) (+ i 1))))))) (loop lst 0))))
(define-values (list-set) (lambda (lst k v) (if (integer? k) (void) (let-values () (error (quote list-set) "expected a non-negative integer" k))) (letrec-values (((loop) (lambda (xs i xs*) (if (null? xs) (error (quote list-set) "index out of bounds" lst k) (if (= i k) (append (reverse xs*) (cons v (cdr xs))) (if (pair? xs) (loop (cdr xs) (+ i 1) (cons (car xs) xs*)) (error (quote list-set) "expected a list" lst))))))) (loop lst 0 (quote ())))))
(define-values (is-absolute-path?) (lambda (path) (if (> (string-length path) 0) (eq? (string-ref path 0) #\/) #f)))
(define-values (build-path) (lambda (base . subpaths) (letrec-values (((string-terminates-with-/?) (lambda (str) (letrec-values (((len) (string-length str))) (eq? (string-ref str (- len 1)) #\/)))) ((paths) (letrec-values (((loop) (lambda (paths accum) (if (null? paths) (reverse accum) (if (= (string-length (car paths)) 0) (loop (cdr paths) accum) (if (string-terminates-with-/? (car accum)) (loop (cdr paths) (cons (car paths) accum)) (loop (cdr paths) (cons (car paths) (cons "/" accum))))))))) (loop subpaths (list base))))) (apply string-append paths))))
(define-values (split-path) (lambda (path) (if (string? path) (void) (let-values () (error (quote split-path) "expected string?" path))) (letrec-values (((path-elems) (reverse (path->list path)))) (if (pair? (cdr path-elems)) (let-values () (letrec-values (((end) (car path-elems)) ((rest) (cdr path-elems))) (cons (apply build-path (reverse rest)) end))) (cons #f (car path-elems))))))
(define-values (path->list) (lambda (path) (if (string? path) (void) (let-values () (error (quote path->list) "expected string?" path))) (letrec-values (((loop) (lambda (path accum) (if (= (string-length path) 0) (reverse accum) (let-values () (letrec-values (((len) (string-length path))) (letrec-values (((loop2) (lambda (i) (if (= i len) (loop "" (cons path accum)) (if (eq? (string-ref path i) #\/) (if (= i 0) (loop (substring path 1 len) (cons "/" accum)) (let-values () (letrec-values (((elem) (substring path 0 i)) ((rest) (substring path (+ i 1) len))) (loop rest (cons elem accum))))) (loop2 (+ i 1))))))) (loop2 0)))))))) (loop path (quote ())))))
(define-values ($generics-type) (make-record-type-descriptor (quote generics) #f #f #f #f (quote #((immutable name) (immutable methods)))))
(define-values ($generics-type?) (record-predicate $generics-type))
(define-values ($make-generics-type) (record-constructor $generics-type))
(define-values ($generics-type-name) (record-accessor $generics-type 0))
(define-values ($generics-type-methods) (record-accessor $generics-type 1))
(define-values ($generics-type-method-names) (lambda (generics) (if ($generics-type? generics) (void) (let-values () (error (quote $generics-type-method-names) "expected a generics interface" generics))) (map car ($generics-type-methods generics))))
(define-values ($record-generics) (make-hashtable))
(define-values (record-type-add-generic!) (lambda (rtd generic impls) (if ($generics-type? generic) (void) (let-values () (error (quote record-type-add-generics!) "expected a generics interface" generic))) (if (record-type-descriptor? rtd) (void) (let-values () (error (quote record-type-add-generics!) "expected a record type descriptor" rtd))) (if (andmap procedure? impls) (void) (let-values () (error (quote record-type-add-generics!) "expected procedures" impls))) (letrec-values (((names) ($generics-type-method-names generic)) (() (let-values () (if (= (length names) (length impls)) (void) (let-values () (error (quote record-type-add-generics!) "number of procedures does not match interface" (format "expected: ~a" (length names)) (format "got: ~a" (length impls))))) (values))) (() (let-values () (for-each (lambda (entry impl) (letrec-values (((id) (car entry)) ((formals) (cdr entry)) ((expected-arity) (letrec-values (((loop) (lambda (formals i) (if (null? formals) i (if (symbol? formals) (cons i #f) (loop (cdr formals) (+ i 1))))))) (loop formals 0))) ((arity) (procedure-arity impl))) (if (equal? arity expected-arity) (void) (let-values () (error (quote record-type-add-generics!) "method implementation does not match formals" (format "method definition: ~a ~a" id formals) (format "actual arity: ~a" arity)))))) ($generics-type-methods generic) impls) (values)))) (hashtable-set! $record-generics rtd (if (hashtable-contains? $record-generics rtd) (cons (cons generic impls) (hashtable-ref $record-generics rtd)) (list (cons generic impls)))))))
(define-values (generics-accessor) (lambda (generic name) (if ($generics-type? generic) (void) (let-values () (error (quote generics-accessor) "expected a generics interface" generic))) (if (symbol? name) (void) (let-values () (error (quote generics-accessor) "expected a generics interface" generic))) (letrec-values (((idx) (index-of name ($generics-type-method-names generic))) (() (let-values () (if idx (void) (let-values () (error (quote generics-accessor) "method name not associated with generics interface" name))) (values)))) (lambda (rtd) (if (record-type-descriptor? rtd) (void) (let-values () (error (quote generics-accessor) "expected a record type descriptor" rtd))) (letrec-values (((rtd-generics) (hashtable-ref $record-generics rtd (quote ()))) ((maybe-entry) (assoc generic rtd-generics))) (if maybe-entry (list-ref (cdr maybe-entry) idx) (error (quote generics-accessor) "generic not associated with record type" ($generics-type-name generic) rtd)))))))
(define-values (generic-instance?) (lambda (generic) (if ($generics-type? generic) (void) (let-values () (error (quote generic-instance?) "expected a generics interface" generic))) (lambda (rtd) (if (record-type-descriptor? rtd) (let-values (((generics) (hashtable-ref $record-generics rtd #f))) (if generics (assoc generic generics) #f)) #f))))
(define-values (gen:equal+hash gen:equal+hash?) (let-values (((:gen) ($make-generics-type (quote equal+hash) (quote ((equal-proc a b rec-equal?) (hash-proc a rec-hash)))))) (values :gen (generic-instance? :gen))))
(define-values (gen:custom-write gen:custom-write?) (let-values (((:gen) ($make-generics-type (quote custom-write) (quote ((write-proc v port mode)))))) (values :gen (generic-instance? :gen))))
(define-values (set) (let-values (((p) #f)) (if (if p (record-type-sealed? p) #f) (error (quote define-record-type) "parent record type is sealed" (format "record type: #<record-type:~a>" (quote set)) (format "parent type: ~a" p)) (make-record-type-descriptor (quote set) p #f #t #t (quote #((immutable store)))))))
(define-values (make-set) (let-values (((c) (record-constructor set)) ((p) (lambda (p) (lambda xs (letrec-values (((h) (make-hashtable)) (() (let-values () (for-each (lambda (x) (hashtable-set! h x #f)) xs) (values)))) (p h)))))) (if p (p c) c)))
(define-values (set?) (record-predicate set))
(define-values (set-store) (record-accessor set 0))
(define-values (set-member?) (lambda (s v) (if (set? s) (void) (let-values () (error (quote set-member?) "expected a set" s))) (hashtable-contains? (set-store s) v)))
(define-values (set-empty?) (lambda (st) (if (set? st) (void) (let-values () (error (quote set-empty?) "expected a set" st))) (= (hashtable-size (set-store st)) 0)))
(define-values (set-count) (lambda (s) (if (set? s) (void) (let-values () (error (quote set-count) "expected a set" s))) (hashtable-size (set-store s))))
(define-values (set-copy) (lambda (st) (if (set? st) (void) (let-values () (error (quote set-copy) "expected a set" st))) (letrec-values (((cp) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! cp x)) (set->list st)) (values)))) cp)))
(define-values (set-add!) (lambda (s v) (if (set? s) (void) (let-values () (error (quote set-add!) "expected a set" s))) (hashtable-set! (set-store s) v #f)))
(define-values (set-remove!) (lambda (s v) (if (set? s) (void) (let-values () (error (quote set-remove!) "expected a set" s))) (hashtable-delete! (set-store s) v)))
(define-values (set-clear!) (lambda (st) (if (set? st) (void) (let-values () (error (quote set-clear!) "expected a set" st))) (hashtable-clear! (set-store st))))
(define-values (set->list) (lambda (s) (if (set? s) (void) (let-values () (error (quote set->list) "expected a set" s))) (vector->list (hashtable-keys (set-store s)))))
(define-values (subset?) (lambda (st st2) (if (set? st) (void) (let-values () (error (quote subset?) "expected a set" st))) (if (set? st2) (void) (let-values () (error (quote subset?) "expected a set" st2))) (letrec-values (((loop) (lambda (elts) (if (null? elts) #t (if (set-member? st2 (car elts)) (loop (cdr elts)) #f))))) (loop (set->list st)))))
(define-values (proper-subset?) (lambda (st st2) (if (set? st) (void) (let-values () (error (quote proper-subset?) "expected a set" st))) (if (set? st2) (void) (let-values () (error (quote proper-subset?) "expected a set" st2))) (if (subset? st st2) (not (subset? st2 st)) #f)))
(define-values (set=?) (lambda (st st2) (if (set? st) (void) (let-values () (error (quote set=?) "expected a set" st))) (if (set? st2) (void) (let-values () (error (quote set=?) "expected a set" st2))) (if (subset? st st2) (subset? st2 st) #f)))
(define-values (set-map) (lambda (proc st) (if (set? st) (void) (let-values () (error (quote set-map) "expected a set" st))) (map proc (set->list st))))
(define-values (set-for-each) (lambda (proc st) (if (set? st) (void) (let-values () (error (quote set-for-each) "expected a set" st))) (for-each proc (set->list st))))
(define-values (set-union) (lambda ss (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-union) "expected a set" s)))) ss) (if (null? ss) (make-set) (if (null? (cdr ss)) (let-values () (letrec-values (((s) (car ss)) ((c) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! c x)) (set->list s)) (values)))) c)) (let-values () (letrec-values (((u) (make-set)) (() (let-values () (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-union) "expected a set" s))) (for-each (lambda (x) (set-add! u x)) (set->list s))) ss) (values)))) u))))))
(define-values (set-intersect) (lambda ss (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-intersect) "expected a set" s)))) ss) (if (null? ss) (make-set) (if (null? (cdr ss)) (let-values () (letrec-values (((s) (car ss)) ((c) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! c x)) (set->list s)) (values)))) c)) (let-values () (letrec-values (((s) (car ss)) ((i) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! i x)) (set->list s)) (values)))) (letrec-values (((loop) (lambda (ss i) (if (null? ss) i (if (= (set-count i) 0) i (let-values () (letrec-values (((s) (car ss)) ((i*) (make-set)) (() (let-values () (for-each (lambda (x) (if (set-member? s x) (let-values () (set-add! i* x)) (void))) (set->list i)) (values)))) (loop (cdr ss) i*)))))))) (loop (cdr ss) i))))))))
(define-values (set-subtract) (lambda (st0 . sts) (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-subtract) "expected a set" s)))) (cons st0 sts)) (letrec-values (((diff) (set-copy st0))) (letrec-values (((loop) (lambda (sts) (if (null? sts) diff (let-values () (letrec-values (((st) (car sts)) (() (let-values () (set-for-each (lambda (x) (if (set-member? st x) (let-values () (set-remove! diff x)) (void))) diff) (values)))) (loop (cdr sts)))))))) (loop sts)))))
(define-values (set-symmetric-difference) (lambda (st0 . sts) (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-symmetric-difference) "expected a set" s)))) (cons st0 sts)) (letrec-values (((diff) (set-copy st0))) (letrec-values (((loop) (lambda (sts) (if (null? sts) diff (let-values () (letrec-values (((st) (car sts)) (() (let-values () (set-for-each (lambda (x) (if (set-member? diff x) (set-remove! diff x) (set-add! diff x))) st) (values)))) (loop (cdr sts)))))))) (loop sts)))))
(define-values (substring) (lambda (str start end) (letrec-values (((len) (string-length str))) (if (not (string? str)) (error (quote substring) "expected string? for" str) (if (not (number? start)) (error (quote substring) "expected number? for" start) (if (not (number? end)) (error (quote substring) "expected number? for" end) (if (> end len) (error (quote substring) "index out of bounds" end) (if (> start end) (error (quote substring) "invalid bounds" start end) (if (= start end) "" (let-values () (letrec-values (((sstr) (make-string (- end start)))) (letrec-values (((loop) (lambda (i n) (if (= n end) sstr (let-values () (string-set! sstr i (string-ref str n)) (loop (+ i 1) (+ n 1))))))) (loop 0 start)))))))))))))
(define-values (identifier?) (lambda (t) (if (syntax? t) (symbol? (syntax-e t)) #f)))
(define-values (free-identifier=?) (lambda (a b) (if (not (identifier? a)) (error (quote free-identifier=?) "expected identifier?" a) (if (not (identifier? b)) (error (quote free-identifier=?) "expected identifier?" b) (eq? (syntax-e a) (syntax-e b))))))
(define-values (stx-null?) (lambda (t) (if (null? t) #t (if (syntax? t) (null? (syntax-e t)) #f))))
(define-values (stx-pair?) (lambda (t) (if (pair? t) #t (if (syntax? t) (pair? (syntax-e t)) #f))))
(define-values (stx-list?) (lambda (t) (if (list? t) #t (if (syntax? t) (list? (syntax-e t)) #f))))
(define-values (stx-vector?) (lambda (t) (if (vector? t) #t (if (syntax? t) (vector? (syntax-e t)) #f))))
(define-values (stx-car) (lambda (t) (if (pair? t) (car t) (car (syntax-e t)))))
(define-values (stx-cdr) (lambda (t) (if (pair? t) (cdr t) (cdr (syntax-e t)))))
(define-values (stx-vector-ref) (lambda (s i) (vector-ref (syntax-e s) i)))
(define-values (stx-null/#f) (lambda (t) (if (null? t) null (if (syntax? t) (if (null? (syntax-e t)) null #f) #f))))
(define-values (cons/#f) (lambda (x1 x2) (if x2 (cons x1 x2) #f)))
(define-values (append/#f) (lambda (l1 l2) (if l1 (if l2 (if (null? l2) l1 (append l1 l2)) #f) #f)))
(define-values (map/#f) (lambda (fn x . xs) (let-values (((lsts) (cons x xs))) (if (andmap (lambda (x) x) lsts) (apply map fn lsts) #f))))
(define-values (stx->list) (lambda (t) (if (syntax? t) (if (stx-list? t) (syntax-e t) #f) (if (list? t) (if (andmap (lambda (x) (syntax? x)) t) t #f) #f))))
(define-values (split-stx-list) (lambda (s n prop?) (let-values (((pre post m) (letrec-values (((loop) (lambda (s) (if (stx-pair? s) (let-values (((pre post m) (loop (stx-cdr s)))) (if (< m n) (values null s (+ m 1)) (values (cons (stx-car s) pre) post m))) (values null s (if prop? (if (stx-null? s) 0 -1) 1)))))) (loop s)))) (values pre post (= m n)))))
(define-values (scope) (let-values (((p) #f)) (if (if p (record-type-sealed? p) #f) (error (quote define-record-type) "parent record type is sealed" (format "record type: #<record-type:~a>" (quote scope)) (format "parent type: ~a" p)) (make-record-type-descriptor (quote scope) p #f #f #f (quote #((mutable bound) (mutable prev)))))))
(define-values (make-scope) (let-values (((c) (record-constructor scope)) ((p) #f)) (if p (p c) c)))
(define-values (scope?) (record-predicate scope))
(define-values (scope-bound) (record-accessor scope 0))
(define-values (scope-prev) (record-accessor scope 1))
(define-values (scope-bound-set!) (record-mutator scope 0))
(define-values (scope-prev-set!) (record-mutator scope 1))
(define-values (make-base-scope) (lambda () (letrec-values (((bound) (make-set)) (() (let-values () (for-each (lambda (n) (set-add! bound n)) (environment-names $base-env)) (values)))) (make-scope bound #f))))
(define-values (scope-extend) (lambda (prev) (make-scope (make-set) prev)))
(define-values (scope-add!) (lambda (scope name) (set-add! (scope-bound scope) name)))
(define-values (scope-names) (lambda (scope) (letrec-values (((names) (make-set)) (() (let-values () (letrec-values (((loop) (lambda (scope) (if scope (let-values () (for-each (lambda (n) (set-add! names n)) (set->list (scope-bound scope))) (loop (scope-prev scope))) (void))))) (loop scope)) (values)))) names)))
(define-values (scope-contains?) (lambda (scope name) (letrec-values (((loop) (lambda (scope) (if (not scope) #f (if (set-member? (scope-bound scope) name) #t (loop (scope-prev scope))))))) (loop scope))))
(define-values ($base-env) (environment))
(define-values ($base-scope) (make-base-scope))
(define-values (lookup-xform) (lambda (maybe-id xforms) (if (identifier? maybe-id) (let-values (((entry) (assoc (syntax-e maybe-id) xforms))) (if entry (cdr entry) #f)) #f)))
(define-values (merge-xforms) (lambda (xforms new-xforms) (letrec-values (((loop) (lambda (xforms new-xforms) (if (null? new-xforms) xforms (if (assoc (caar new-xforms) xforms) (loop xforms (cdr new-xforms)) (loop (cons (car new-xforms) xforms) (cdr new-xforms))))))) (loop xforms new-xforms))))
(define-values (_-form?) (lambda (form-name) (lambda (expr) (if (stx-pair? expr) (let-values (((head) (stx-car expr))) (if (identifier? head) (eq? (syntax-e head) form-name) #f)) #f))))
(define-values (define-values-form?) (_-form? (quote define-values)))
(define-values (define-syntaxes-form?) (_-form? (quote define-syntaxes)))
(define-values (let-values-form?) (_-form? (quote let-values)))
(define-values (letrec-values-form?) (_-form? (quote letrec-values)))
(define-values (let-syntaxes-form?) (_-form? (quote let-syntaxes)))
(define-values (set!-form?) (_-form? (quote set!)))
(define-values (quote-form?) (_-form? (quote quote)))
(define-values (quote-syntax-form?) (_-form? (quote quote-syntax)))
(define-values (lambda-form?) (_-form? (quote lambda)))
(define-values (begin-form?) (_-form? (quote begin)))
(define-values (if-form?) (_-form? (quote if)))
(define-values (stx-self-evaluating?) (lambda (stx) (letrec-values (((datum) (syntax-e stx))) (let-values (((or-t) (boolean? datum))) (if or-t or-t (let-values (((or-t) (number? datum))) (if or-t or-t (let-values (((or-t) (string? datum))) (if or-t or-t (let-values (((or-t) (vector? datum))) (if or-t or-t (let-values (((or-t) (box? datum))) (if or-t or-t (char? datum))))))))))))))
(define-values (duplicate-identifier) (lambda (ids new-ids) (letrec-values (((new-unique) (make-set))) (letrec-values (((loop) (lambda (new-ids) (if (null? new-ids) #f (if (set-member? ids (car new-ids)) (car new-ids) (if (set-member? new-unique (car new-ids)) (car new-ids) (let-values () (set-add! new-unique (car new-ids)) (loop (cdr new-ids))))))))) (loop new-ids)))))
(define-values (check-define-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error name "bad syntax" form)) (void)) (values))) ((ids) (syntax->list (stx-car rib0))) ((rib1) (stx-cdr rib0)) (() (let-values () (if (if (list? ids) (andmap identifier? ids) #f) (void) (let-values () (syntax-error name "not identifiers" form ids))) (values))) (() (let-values () (if (stx-null? rib1) (let-values () (syntax-error name "expected an expression after identifiers" form)) (void)) (values))) ((rib2) (stx-cdr rib1))) (if (stx-null? rib2) (void) (let-values () (syntax-error name "too many expressions" form))))))
(define-values (check-let-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib) (stx-cdr form)) (() (let-values () (if (stx-null? rib) (let-values () (syntax-error name "bad syntax" form)) (void)) (values))) ((bindings) (syntax->list (stx-car rib))) ((bind-rib) (stx-cdr rib)) (() (let-values () (if (null? bind-rib) (let-values () (syntax-error name "missing body" form)) (void)) (values))) (() (let-values () (if (let-values (((or-t) (list? bind-rib))) (if or-t or-t (if (syntax? bind-rib) (list? (syntax->list bind-rib)) #f))) (void) (let-values () (syntax-error name "not a sequence of bindings" form bindings))) (values))) (() (let-values () (if (list? bindings) (void) (let-values () (syntax-error name "expected a sequence of expressions after the bindings" form))) (values)))) (letrec-values (((loop) (lambda (bindings) (if (null? bindings) (void) (let-values () (letrec-values (((bind) (syntax->list (car bindings))) (() (let-values () (if (if (list? bind) (= (length bind) 2) #f) (void) (let-values () (syntax-error name "expected a sequence of expressions after the bindings" form))) (values))) ((ids) (syntax->list (car bind))) (() (let-values () (if (if (list? ids) (andmap identifier? ids) #f) (void) (let-values () (syntax-error name "not identifiers" form ids))) (values)))) (loop (cdr bindings)))))))) (loop bindings)))))
(define-values (check-set!-form!) (lambda (form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error (quote set!) "bad syntax" form)) (void)) (values))) ((id) (stx-car rib0)) ((rib1) (stx-cdr rib0)) (() (let-values () (if (identifier? id) (void) (let-values () (syntax-error (quote set!) "not identifier" form id))) (values))) (() (let-values () (if (stx-null? rib1) (let-values () (syntax-error (quote set!) "expected an expression after identifier" form)) (void)) (values))) ((rib2) (stx-cdr rib1))) (if (stx-null? rib2) (void) (let-values () (syntax-error (quote set!) "too many expressions" form))))))
(define-values (check-lambda-form!) (lambda (form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error #f "missing formals" form)) (void)) (values))) ((formals) (stx-car rib0)) ((rib1) (stx-cdr rib0)) (() (let-values () (if (null? rib1) (let-values () (syntax-error #f "missing expression after formals" form)) (void)) (values))) ((rib2) (stx-cdr rib1))) (if (let-values (((or-t) (list? rib2))) (if or-t or-t (if (syntax? rib2) (list? (syntax->list rib2)) #f))) (void) (let-values () (syntax-error #f "expected a sequence of expressions after formals" form))))))
(define-values (check-begin-form!) (lambda (form) (if (syntax->list form) (void) (let-values () (syntax-error (quote begin) "bad syntax" form)))))
(define-values (check-1ary-form!) (lambda (name form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error name "expected an expression" form)) (void)) (values))) ((rib1) (stx-cdr rib0))) (if (stx-null? rib1) (void) (let-values () (syntax-error name "too many expressions" form))))))
(define-values (check-if-form!) (lambda (form) (letrec-values (((rib) (stx-cdr form)) (() (let-values () (if (stx-null? rib) (let-values () (syntax-error (quote if) "bad syntax" form)) (void)) (values))) ((cond-rib) (stx-cdr rib)) (() (let-values () (if (stx-null? cond-rib) (let-values () (syntax-error (quote if) "bad syntax" form)) (void)) (values))) ((ift-rib) (stx-cdr cond-rib)) (() (let-values () (if (stx-null? ift-rib) (let-values () (syntax-error (quote if) "missing an "else" statement" form)) (void)) (values))) ((iff-rib) (stx-cdr ift-rib))) (if (stx-null? iff-rib) (void) (let-values () (syntax-error (quote if) "too many expressions" form))))))
(define-values (check-duplicate-identifier!) (lambda (form name ids new-ids) (letrec-values (((dup) (duplicate-identifier ids new-ids))) (if dup (let-values () (syntax-error name "duplicate identifier" form (datum->syntax dup))) (void)))))
(define-values ($expander-pattern-vars) null)
(define-values ($base-stx-env) (lambda (env) (let-values (((env) (environment-extend env))) (environment-set! env (quote get-pattern-variable) (lambda (k) (if (symbol? k) (letrec-values (((loop) (lambda (assoc) (if (null? assoc) #f (if (eq? (caar assoc) k) (cadar assoc) (loop (cdr assoc))))))) (loop $expander-pattern-vars)) (error (quote get-pattern-variable) "expected symbol?" k)))) env)))
(define-values (define-syntaxes/values-identifiers) (lambda (form) (map syntax-e (syntax->list (stx-car (stx-cdr form))))))
(define-values (define-syntaxes/values-expr) (lambda (form) (stx-car (stx-cdr (stx-cdr form)))))
(define-values (check/module!) (lambda (path exprs scope) (letrec-values (((bind/define-values) (lambda (form) (for-each (lambda (id) (scope-add! scope id)) (define-syntaxes/values-identifiers form)))) ((check/expr!) (lambda (expr0 scope) (letrec-values (((loop) (lambda (expr) (if (lambda-form? expr) (let-values () (letrec-values (((formals) (stx-car (stx-cdr expr))) ((body) (stx-cdr (stx-cdr expr))) ((scope*) (scope-extend scope)) (() (let-values () (letrec-values (((rec) (lambda (formals) (if (symbol? formals) (scope-add! scope* formals) (if (pair? formals) (let-values () (scope-add! scope* (car formals)) (rec (cdr formals))) (void)))))) (rec (syntax->datum formals))) (values)))) (for-each (lambda (e) (check/expr! e scope*)) body))) (if (let-values (((or-t) (let-values-form? expr))) (if or-t or-t (letrec-values-form? expr))) (let-values () (letrec-values (((bindings) (stx-car (stx-cdr expr))) ((body) (stx-cdr (stx-cdr expr))) ((scope*) (scope-extend scope)) ((rec-scope) (if (let-values-form? expr) scope scope*)) (() (let-values () (letrec-values (((rec) (lambda (bindings) (if (null? bindings) (void) (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((ids) (syntax->datum (first binding))) (() (let-values () (for-each (lambda (id) (scope-add! scope* id)) ids) (values)))) (rec (cdr bindings)))))))) (rec (syntax->list bindings))) (values))) (() (let-values () (letrec-values (((rec) (lambda (bindings) (if (null? bindings) (void) (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((val) (second binding)) (() (let-values () (check/expr! val rec-scope) (values)))) (rec (cdr bindings)))))))) (rec (syntax->list bindings))) (values)))) (for-each (lambda (e) (check/expr! e scope*)) body))) (if (set!-form? expr) (loop (third (syntax->list expr))) (if (if-form? expr) (for-each loop (stx-cdr expr)) (if (begin-form? expr) (for-each loop (stx-cdr expr)) (if (let-values (((or-t) (quote-form? expr))) (if or-t or-t (let-values (((or-t) (quote-syntax-form? expr))) (if or-t or-t (stx-self-evaluating? expr))))) (void) (if (stx-pair? expr) (for-each loop (syntax->list expr)) (if (identifier? expr) (let-values () (letrec-values (((id) (syntax-e expr))) (if (scope-contains? scope id) (void) (let-values () (printf "~a: unknown variable `~a`\n" path id) (printf "  at: ~a\n" (syntax->datum expr0)) (exit 1))))) (error (quote check/expr!) "cannot check" expr)))))))))))) (loop expr0)))) (() (let-values () (for-each (lambda (form) (if (define-values-form? form) (let-values () (bind/define-values form)) (void))) exprs) (values))) (() (let-values () (for-each (lambda (form) (if (define-values-form? form) (check/expr! (define-syntaxes/values-expr form) scope) (check/expr! form scope))) exprs) (values)))) (void))))
(define-values (expand/module) (lambda (path exprs xforms env scope) (letrec-values (((eval/values) (lambda (expr env) (call-with-values (lambda () (eval expr env)) (lambda results results)))) ((eval/xform) (lambda (xform expr name) (letrec-values (((fn) (car xform))) (call-with-values (lambda () (fn expr)) (lambda results (if (not (= (length results) 1)) (error #f "result arity mismatch" "expected 1" "received" 2) (if (syntax? (car results)) (car results) (error name "transformer produced something other than syntax" (car results))))))))) ((expand/body) (lambda (exprs xforms) (letrec-values (((loop) (lambda (expr0 rest defines) (letrec-values (((expr*) (expand/expr expr0 xforms #f))) (if (begin-form? expr*) (let-values () (letrec-values (((form) (syntax->list expr*))) (loop (cadr form) (append (cddr form) rest) defines))) (if (define-syntaxes-form? expr*) (let-values () (if (null? rest) (let-values () (error (quote define-syntaxes) "last form is not an expression" expr0)) (void)) (letrec-values (((form) (syntax->list expr*)) ((ids) (second form)) ((value) (third form))) (list (datum->syntax (list (quote-syntax letrec-values) (map (lambda (bind) (list (car bind) (cdr bind))) (reverse defines)) (expand/expr (datum->syntax (cons* (quote-syntax let-syntaxes) (list (list ids value)) rest)) xforms #t)))))) (if (define-values-form? expr*) (let-values () (if (null? rest) (let-values () (error (quote define-values) "last form is not an expression" expr0)) (void)) (letrec-values (((form) (syntax->list expr*)) ((ids) (second form)) ((value) (expand/expr (third form) xforms #t))) (loop (car rest) (cdr rest) (cons (cons ids value) defines)))) (if (not (null? rest)) (if (null? defines) (cons* expr* (loop (car rest) (cdr rest) defines)) (let-values () (letrec-values (((bind-expr) (list (quote-syntax let-values) (quote ()) expr* (list (quote-syntax values))))) (loop (car rest) (cdr rest) (cons (cons (quote ()) bind-expr) defines))))) (if (null? defines) (list expr*) (list (datum->syntax (list (quote-syntax letrec-values) (map (lambda (bind) (list (car bind) (cdr bind))) (reverse defines)) expr*)))))))))))) (loop (car exprs) (cdr exprs) (quote ()))))) ((expand/expr) (lambda (expr xforms recur-begin?) (letrec-values (((patterns) (filter (lambda (e) (pattern-variable? (cadr e))) xforms)) (() (let-values () (set! $expander-pattern-vars patterns) (values)))) (letrec-values (((loop) (lambda (expr) (if (stx-self-evaluating? expr) expr (if (identifier? expr) (let-values () (letrec-values (((id) (syntax->datum expr)) ((maybe-xform) (lookup-xform expr xforms))) (if maybe-xform (loop (eval/xform maybe-xform expr id)) expr))) (if (let-values (((or-t) (define-values-form? expr))) (if or-t or-t (define-syntaxes-form? expr))) expr (if (let-syntaxes-form? expr) (let-values () (check-let-syntaxes/values-form! (quote let-syntaxes) expr) (letrec-values (((form) (syntax->list expr)) ((body) (cddr form)) ((let-ids) (make-set))) (letrec-values (((rec) (lambda (bindings xforms) (if (null? bindings) (datum->syntax (cons* (quote-syntax let-values) (quote ()) (expand/body body xforms))) (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((binding-ids) (syntax->datum (car binding))) (() (let-values () (check-duplicate-identifier! expr (quote let-syntaxes) let-ids binding-ids) (values))) ((rhs) (expand/expr (cadr binding) xforms #t)) ((results) (eval/values (syntax->datum rhs) env)) (() (let-values () (if (= (length binding-ids) (length results)) (void) (let-values () (error (quote let-syntaxes) "result arity mismatch" "expected" (length binding-ids) "received" (length results)))) (values)))) (letrec-values (((bind-xforms) (lambda (ids results xforms) (if (null? ids) (let-values () (for-each (lambda (id) (set-add! let-ids id)) binding-ids) (rec (cdr bindings) xforms)) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results)) (() (let-values () (if (let-values (((or-t) (procedure? xform))) (if or-t or-t (pattern-variable? xform))) (void) (let-values () (error (quote let-syntaxes) "expected a procedure? received" xform))) (values))) ((xform-entry) (cons id (list xform xforms)))) (bind-xforms (cdr ids) (cdr results) (cons xform-entry xforms)))))))) (bind-xforms binding-ids results xforms)))))))) (rec (syntax->list (cadr form)) xforms)))) (if (let-values (((or-t) (let-values-form? expr))) (if or-t or-t (letrec-values-form? expr))) (let-values () (letrec-values (((name) (if (let-values-form? expr) (quote let-values) (quote letrec-values))) (() (let-values () (check-let-syntaxes/values-form! name expr) (values))) ((form) (syntax->list expr)) ((body) (cddr form)) ((ids) (make-set))) (datum->syntax (cons* (car form) (map (lambda (bind) (letrec-values (((bind*) (syntax->list bind)) ((bind-ids) (syntax->datum (first bind*))) (() (let-values () (check-duplicate-identifier! expr name ids bind-ids) (values))) (() (let-values () (for-each (lambda (id) (set-add! ids id)) bind-ids) (values)))) (list (first bind*) (loop (second bind*))))) (syntax->list (cadr form))) (expand/body body xforms))))) (if (lambda-form? expr) (let-values () (check-lambda-form! expr) (letrec-values (((head) (stx-car expr)) ((formals) (stx-car (stx-cdr expr))) ((body) (stx-cdr (stx-cdr expr)))) (datum->syntax (cons* head formals (expand/body body xforms))))) (if (if-form? expr) (let-values () (check-if-form! expr) (letrec-values (((form) (syntax->list expr))) (datum->syntax (cons (first form) (map loop (cdr form)))))) (if (begin-form? expr) (let-values () (check-begin-form! expr) (letrec-values (((body) (stx-cdr expr))) (if (null? body) (datum->syntax (quote (void))) (if recur-begin? (let-values () (letrec-values (((body*) (expand/body body xforms))) (if (null? (cdr body*)) (car body*) (datum->syntax (cons* (quote begin) body*))))) (datum->syntax (cons* (quote begin) (map loop body))))))) (if (set!-form? expr) (let-values () (check-set!-form! expr) (letrec-values (((form) (syntax->list expr))) (datum->syntax (list (first form) (second form) (loop (third form)))))) (if (quote-form? expr) (let-values () (check-1ary-form! (quote quote) expr) expr) (if (quote-syntax-form? expr) (let-values () (check-1ary-form! (quote quote-syntax) expr) expr) (if (stx-pair? expr) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/expr (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms xforms (cadr maybe-xform)) recur-begin?) (let-values (((stx-lst) (syntax->list expr))) (if (list? stx-lst) (datum->syntax (map loop stx-lst)) (error (quote expand/expr) "invalid application" expr)))))) (syntax-error (quote expand/expr) "bad syntax" expr)))))))))))))))) (loop expr))))) ((expand/module*) (lambda (exprs xforms) (letrec-values (((expand/top-level) (lambda (expr xforms) (if (define-syntaxes-form? expr) (values expr xforms) (if (define-values-form? expr) (values expr xforms) (if (begin-form? expr) (values expr xforms) (if (if (stx-pair? expr) (identifier? (stx-car expr)) #f) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/top-level (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms xforms (cadr maybe-xform))) (values expr xforms)))) (values expr xforms))))))) ((expand/non-define-values) (lambda (exprs xforms) (letrec-values (((xforms) xforms) ((define-ids) (make-set)) ((xform-ids) (make-set)) ((exprs*) (letrec-values (((loop) (lambda (exprs) (if (null? exprs) null (letrec-values (((with-scope) (lambda (exprs in-scope) (letrec-values (((expr in-scope) (expand/top-level (car exprs) in-scope))) (if (define-syntaxes-form? expr) (let-values () (check-define-syntaxes/values-form! (quote define-syntaxes) expr) (letrec-values (((ids rhs) (let-values (((ids) (define-syntaxes/values-identifiers expr))) (check-duplicate-identifier! expr (quote define-syntaxes) xform-ids ids) (values ids (define-syntaxes/values-expr expr)))) ((rhs*) (expand/expr rhs in-scope #t)) ((results) (eval/values (syntax->datum rhs*) env)) (() (let-values () (if (= (length ids) (length results)) (void) (let-values () (error (quote define-syntaxes) "result arity mismatch" "expected" (length ids) "received" (length results)))) (values)))) (letrec-values (((rec) (lambda (ids results) (if (null? ids) (loop (cdr exprs)) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results)) (() (let-values () (if (procedure? xform) (void) (let-values () (error (quote define-syntaxes) "expected a procedure?" "received" xform))) (values))) ((binding) (cons id (list xform null))) ((xforms-in-scope) (cons binding xforms)) (() (let-values () (set-add! xform-ids id) (values))) (() (let-values () (set! xforms (letrec-values (((loop) (lambda (xforms new-xforms) (if (null? xforms) new-xforms (let-values () (letrec-values (((xform) (first xforms)) ((id) (first xform)) ((value) (second xform)) ((xform*) (if (set-member? xform-ids id) (cons id (list value xforms-in-scope)) xform))) (loop (cdr xforms) (cons xform* new-xforms)))))))) (loop xforms-in-scope (quote ())))) (values)))) (rec (cdr ids) (cdr results)))))))) (rec ids results)))) (if (define-values-form? expr) (let-values () (check-define-syntaxes/values-form! (quote define-values) expr) (letrec-values (((ids) (define-syntaxes/values-identifiers expr)) (() (let-values () (check-duplicate-identifier! expr (quote define-values) define-ids ids) (values))) (() (let-values () (for-each (lambda (id) (set-add! define-ids id)) ids) (values)))) (cons expr (loop (cdr exprs))))) (if (begin-form? expr) (let-values () (check-begin-form! expr) (letrec-values (((forms) (cdr (syntax->list expr)))) (if (null? forms) (loop (cdr exprs)) (append (with-scope forms in-scope) (loop (cdr exprs)))))) (cons (expand/expr expr in-scope #t) (loop (cdr exprs)))))))))) (with-scope exprs xforms)))))) (loop exprs)))) (values exprs* xforms)))) ((expand/define-values) (lambda (exprs xforms) (letrec-values (((loop) (lambda (exprs exprs*) (if (null? exprs) (reverse exprs*) (if (define-values-form? (car exprs)) (let-values () (letrec-values (((form) (syntax->list (car exprs))) ((form*) (datum->syntax (list (first form) (second form) (expand/expr (third form) xforms #t))))) (loop (cdr exprs) (cons form* exprs*)))) (loop (cdr exprs) (cons (car exprs) exprs*))))))) (loop exprs null)))) ((exprs* xforms*) (expand/non-define-values exprs xforms)) ((exprs**) (expand/define-values exprs* xforms*)) (() (let-values () (check/module! path exprs** scope) (values)))) (values exprs** xforms*))))) (expand/module* exprs xforms))))
(define-values (expand) (lambda (expr env xforms scope) (letrec-values (((exprs* xforms*) (expand/module #f (list expr) xforms env scope))) (if (null? exprs*) (values (quote-syntax (void)) xforms*) (values (car exprs*) xforms*)))))
(define-values (writeln) (lambda (o) (write o) (newline)))
(define-values ($module-table) (make-hashtable))
(define-values ($module-envs) (make-hashtable))
(define-values ($module-internals) (make-hashtable))
(define-values ($load-module) (lambda (path print-handler result-handler) (letrec-values (((new-cwd) (car (split-path path))) ((scope) (scope-extend $base-scope)) ((exported) (quote ())) ((imported) (quote ())) ((imported-xforms) (quote ())) ((imported-modules) (quote ())) ((stx-env) #f) ((module-xforms) (quote ())) (($read) (lambda () (letrec-values (((p) (open-input-file path))) (letrec-values (((loop) (lambda (exprs) (letrec-values (((datum) (read p))) (if (eof-object? datum) (let-values () (close-input-port p) (reverse exprs)) (loop (cons datum exprs))))))) (loop (quote ())))))) (($import) (lambda (exprs) (letrec-values (((loop) (lambda (exprs evalable) (if (null? exprs) (reverse evalable) (let-values () (letrec-values (((expr) (syntax-e (car exprs)))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote import)) #f) (letrec-values (((loop2) (lambda (imports) (if (null? imports) (loop (cdr exprs) evalable) (if (pair? imports) (let-values () (letrec-values (((maybe-import) (syntax-e (car imports))) ((path) (build-path new-cwd maybe-import))) (if (string? maybe-import) (let-values () ($load-or-import path print-handler result-handler) (letrec-values (((from-module) (hashtable-ref $module-table path)) (() (let-values () (set! imported-modules (cons path imported-modules)) (values))) (() (let-values () (set! imported-xforms (merge-xforms imported-xforms (car from-module))) (values))) (() (let-values () (set! imported (append (cdr from-module) imported)) (values))) (() (let-values () (for-each (lambda (name) (scope-add! scope name)) (map car (cdr from-module))) (values)))) (loop2 (cdr imports)))) (error (quote import) "bad import syntax")))) (error (quote import) "bad import syntax")))))) (loop2 (cdr expr))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote export)) #f) (letrec-values (((loop2) (lambda (exports) (if (null? exports) (loop (cdr exprs) evalable) (if (pair? exports) (let-values () (letrec-values (((maybe-export) (syntax-e (car exports)))) (if (symbol? maybe-export) (let-values () (set! exported (cons maybe-export exported)) (loop2 (cdr exports))) (if (pair? maybe-export) (if (eq? (syntax-e (car maybe-export)) (quote all)) (let-values () (letrec-values (((module-name) (syntax-e (cadr maybe-export))) ((path) (build-path new-cwd module-name))) (if (if (string? module-name) (if (null? (cddr maybe-export)) (member path imported-modules) #f) #f) (let-values () (letrec-values (((from-module) (hashtable-ref $module-table path)) (() (let-values () (set! exported (append (map car (car from-module)) (map car (cdr from-module)) exported)) (values)))) (loop2 (cdr exports)))) (error (quote export) "bad export syntax")))) (error (quote export) "bad export syntax")) (error (quote export) "bad export syntax"))))) (error (quote export) "bad export syntax")))))) (loop2 (cdr expr))) (loop (cdr exprs) (cons (car exprs) evalable)))))))))) (loop exprs (quote ()))))) (($expand) (lambda (exprs) (set! stx-env ($base-stx-env ($eval-environment $base-env imported))) (letrec-values (((exprs* xforms*) (expand/module path exprs imported-xforms stx-env scope)) (() (let-values () (set! module-xforms xforms*) (values)))) exprs*))) ((raw-exprs) ($read)) ((non-import-exprs) ($import raw-exprs)) ((expanded-exprs) ($expand non-import-exprs))) (values expanded-exprs module-xforms imported exported stx-env scope))))
(define-values ($eval-environment) (lambda (env imports) (letrec-values (((env*) (environment-extend env))) (letrec-values (((loop) (lambda (imports) (if (null? imports) env* (let-values () (letrec-values (((name) (caar imports)) ((value) (cdar imports)) (() (let-values () (environment-set! env* name value) (values)))) (loop (cdr imports)))))))) (loop imports)))))
(define-values ($eval-exprs) (lambda (exprs env print-handler) (letrec-values (((loop) (lambda (exprs result) (if (null? exprs) result (let-values () (letrec-values (((expr) (syntax->datum (car exprs)))) (call-with-values (lambda () (eval expr env)) (lambda results (letrec-values (((loop2) (lambda (results prev) (if (null? results) (loop (cdr exprs) prev) (let-values () (if (void? (car results)) (void) (let-values () (writeln (car results)))) (loop2 (cdr results) (car results))))))) (loop2 results (void))))))))))) (loop exprs (void)))))
(define-values ($load-or-import-no-check) (lambda (path print-handler result-handler) (letrec-values (((exprs module-xforms imports exports stx-env scope) ($load-module path print-handler result-handler)) ((env) ($eval-environment $base-env imports)) ((last) ($eval-exprs exprs env print-handler)) ((export-values) (quote ())) ((export-xforms) (quote ())) (() (let-values () (letrec-values (((loop) (lambda (exports) (if (null? exports) (void) (let-values () (letrec-values (((export) (car exports)) ((maybe-xform) (assoc export module-xforms)) (() (let-values () (if maybe-xform (let-values () (letrec-values (((xform) (cdr maybe-xform))) (set! export-xforms (cons (cons export xform) export-xforms)))) (let-values () (letrec-values (((value) (environment-ref env export (lambda () (error (quote export) "undefined export" export))))) (set! export-values (cons (cons export value) export-values))))) (values)))) (loop (cdr exports)))))))) (loop exports)) (values))) (() (let-values () (hashtable-set! $module-table path (cons export-xforms export-values)) (values))) (() (let-values () (hashtable-set! $module-envs path (cons stx-env env)) (values))) (() (let-values () (hashtable-set! $module-internals path (list exprs module-xforms imports exports stx-env scope)) (values)))) (if result-handler (let-values () (result-handler last)) (void)))))
(define-values ($repl) (lambda (env stx-env xforms scope) (letrec-values (((loop) (lambda (xforms) (display "> ") (letrec-values (((expr) (read)) (() (let-values () (if (eof-object? expr) (let-values () (exit)) (void)) (values))) ((expr* xforms*) (expand expr stx-env xforms scope)) (() (let-values () (call-with-values (lambda () (eval (syntax->datum expr*) env)) (lambda results (for-each (lambda (result) (if (void? result) (void) (let-values () (writeln result)))) results))) (values)))) (loop xforms*))))) (loop xforms))))
(define-values ($load-or-import) (lambda (name print-handler result-handler) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) (if (hashtable-contains? $module-table path) (void) (let-values () ($load-or-import-no-check path print-handler result-handler))))))
(define-values (read/module) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) ($load-module path #f #f))))
(define-values (import) (lambda (name) ($load-or-import name (lambda (o) (writeln o)) #f)))
(define-values (load) (lambda (name) (letrec-values (((result) ($load-or-import name #f (lambda (o) o))) (() (let-values () (if (void? result) (void) (let-values () (writeln result))) (values)))) (enter! name))))
(define-values (enter!) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name))) (() (let-values () (if (hashtable-contains? $module-envs path) (void) (let-values () (error (quote enter!) "unknown module" name))) (values))) ((envs) (hashtable-ref $module-envs path)) ((internals) (hashtable-ref $module-internals path)) ((xforms) (second internals)) ((scope) (sixth internals))) ($repl (environment-extend (car envs)) (environment-extend (cdr envs)) xforms scope))))
(define-values (read) (lambda args (letrec-values (((p) (if (null? args) (current-input-port) (if (null? (cdr args)) (car args) (error (quote read) "arity mismatch\n expected 0 or 1 arguments," "received" (length args))))) (() (let-values () (if (not (input-port? p)) (error (quote read) "expected an input port, received " p) (void)) (values))) ((oparen) (integer->char 40)) ((cparen) (integer->char 41)) ((obrack) (integer->char 91)) ((cbrack) (integer->char 93)) ((obrace) (integer->char 123)) ((cbrace) (integer->char 125)) ((space?) (lambda (c) (let-values (((or-t) (eq? c #\space))) (if or-t or-t (eq? c #\newline))))) ((delimeter?) (lambda (c) (let-values (((or-t) (eof-object? c))) (if or-t or-t (let-values (((or-t) (space? c))) (if or-t or-t (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (let-values (((or-t) (eq? c obrace))) (if or-t or-t (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (let-values (((or-t) (eq? c cbrace))) (if or-t or-t (let-values (((or-t) (eq? c #\"))) (if or-t or-t (eq? c #\;))))))))))))))))))))) ((symbol-char?) (lambda (c) (not (delimeter? c)))) ((digit?) (lambda (c) (letrec-values (((0-char) (char->integer #\0)) ((9-char) (char->integer #\9)) ((i) (char->integer c))) (<= 0-char i 9-char)))) ((hex-digit?) (lambda (c) (letrec-values (((i) (char->integer c))) (let-values (((or-t) (<= (char->integer #\0) i (char->integer #\9)))) (if or-t or-t (let-values (((or-t) (<= (char->integer #\a) i (char->integer #\f)))) (if or-t or-t (<= (char->integer #\A) i (char->integer #\F))))))))) ((digit-prefix?) (lambda (c) (let-values (((or-t) (digit? c))) (if or-t or-t (if (let-values (((or-t) (eq? c #\-))) (if or-t or-t (eq? c #\+))) (digit? (peek-char p)) #f))))) ((assert-not-eof!) (lambda (c) (if (eof-object? c) (error (quote read) "unexpected end of input") (void)))) ((assert-matching-parens!) (lambda (open close) (if (let-values (((or-t) (if (eq? open oparen) (eq? close cparen) #f))) (if or-t or-t (let-values (((or-t) (if (eq? open obrack) (eq? close cbrack) #f))) (if or-t or-t (if (eq? open obrace) (eq? close cbrace) #f))))) (void) (error (quote read) "parenthesis mismatch " open " " close)))) ((assert-delimeter!) (lambda (c) (if (not (delimeter? c)) (error (quote read) "expected a delimeter") (void)))) ((skip-comment!) (lambda () (letrec-values (((c) (peek-char p))) (if (eof-object? c) (void) (if (eq? c #\newline) (void) (let-values () (read-char p) (skip-comment!))))))) ((skip-block-comment!) (lambda () (letrec-values (((loop) (lambda (block-level) (if (= block-level 0) (void) (let-values () (letrec-values (((c) (read-char p))) (if (eq? c #\#) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\|) (let-values () (read-char p) (loop (+ block-level 1))) (loop block-level)))) (if (eq? c #\|) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\#) (let-values () (read-char p) (loop (- block-level 1))) (loop block-level)))) (loop block-level))))))))) (loop 1)))) ((skip-until-token!) (lambda () (letrec-values (((c) (peek-char p))) (if (space? c) (let-values () (read-char p) (skip-until-token!)) (if (eq? c #\;) (let-values () (read-char p) (skip-comment!) (skip-until-token!)) (void)))))) ((check-expected-string!) (lambda (s) (letrec-values (((len) (string-length s))) (letrec-values (((loop) (lambda (i) (if (< i len) (let-values () (letrec-values (((c) (read-char p))) (if (eof-object? c) (error (quote read) "unexpected end of input") (if (eq? c (string-ref s i)) (loop (+ i 1)) (error (quote read) "unexpected character" c))))) (void))))) (loop 0))))) ((read-pair) (lambda (open) (skip-until-token!) (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (assert-matching-parens! open c) (read-char p) (quote ())) (let-values () (letrec-values (((car) (read-loop))) (letrec-values (((loop) (lambda (car) (skip-until-token!) (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\.) (let-values () (letrec-values (((maybe-dot) (read-loop))) (if (eq? (syntax-e maybe-dot) (quote .)) (let-values () (letrec-values (((cdr) (read-loop)) (() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (assert-matching-parens! open c) (read-char p) (cons car cdr)) (error (quote read) "missing closing parenthesis")))) (cons car (loop maybe-dot))))) (let-values () (letrec-values (((cdr) (read-pair open))) (cons car cdr)))))))) (loop car)))))))) ((read-vector) (lambda () (letrec-values (((loop) (lambda (elems) (skip-until-token!) (letrec-values (((c) (peek-char p))) (if (eq? c cparen) (let-values () (read-char p) (list->vector (reverse elems))) (loop (cons (read-loop) elems))))))) (loop (quote ()))))) ((read-character) (lambda () (letrec-values (((c) (read-char p)) (() (let-values () (if (eof-object? c) (error (quote read) "incomplete character literal") (void)) (values)))) (if (eq? c #\s) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\p) (let-values () (check-expected-string! "pace") #\space) (let-values () (assert-delimeter! (peek-char p)) c)))) (if (eq? c #\n) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\e) (let-values () (check-expected-string! "ewline") #\newline) (let-values () (assert-delimeter! (peek-char p)) c)))) (let-values () (assert-delimeter! (peek-char p)) c)))))) ((read-number) (lambda () (letrec-values (((0-char) (char->integer #\0)) ((chars) (quote ())) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (digit? c) (let-values () (read-char p) (set! num (+ (* 10 num) (- (char->integer c) 0-char))) (read-digit!)) (if (symbol-char? c) (let-values () (read-char p) (read-symbol chars)) (let-values () (assert-delimeter! (peek-char p)) num))))))) (read-digit!))))) ((read-hex-number) (lambda (c) (letrec-values (((chars) (quote ())) ((sign) (if (eq? c #\-) (let-values () (read-char p) (set! chars (cons c chars)) -1) (if (eq? c #\+) (let-values () (read-char p) (set! chars (cons c chars)) 1) 1))) ((0-char) (char->integer #\0)) ((a-char) (char->integer #\a)) ((A-char) (char->integer #\A)) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (hex-digit? c) (let-values () (read-char p) (letrec-values (((i) (char->integer c)) (() (let-values () (if (digit? c) (set! num (+ (* 16 num) (- i 0-char))) (if (>= i a-char) (set! num (+ (* 16 num) (+ 10 (- i a-char)))) (set! num (+ (* 16 num) (+ 10 (- i A-char)))))) (values)))) (read-digit!))) (if (symbol-char? c) (let-values () (read-char p) (read-symbol chars)) (let-values () (assert-delimeter! (peek-char p)) (* num sign)))))))) (read-digit!))))) ((read-string) (lambda () (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (eof-object? c) (let-values () (error (quote read) "non-terminated string literal") (void)) (if (eq? c #\\) (let-values () (read-char p) (letrec-values (((c) (peek-char p))) (if (eq? c #\n) (let-values () (read-char p) (loop (cons #\newline acc))) (if (eq? c #\\) (let-values () (read-char p) (loop (cons #\\ acc))) (if (eq? c #\") (let-values () (read-char p) (loop (cons #\" acc))) (error (quote read) "unknown escape character" c)))))) (if (eq? c #\") (let-values () (read-char p) (reverse acc)) (let-values () (read-char p) (loop (cons c acc)))))))))) (loop (quote ()))))) ((read-symbol) (lambda (acc) (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (symbol-char? c) (loop (cons (read-char p) acc)) (let-values () (assert-delimeter! (peek-char p)) (string->symbol (apply string (reverse acc))))))))) (loop acc)))) ((read-loop) (lambda () (skip-until-token!) (letrec-values (((c) (peek-char p))) (if (eof-object? c) (let-values () (read-char p) c) (if (eq? c #\#) (let-values () (read-char p) (letrec-values (((c) (peek-char p))) (if (eq? c #\t) (let-values () (read-char p) (datum->syntax #t)) (if (eq? c #\f) (let-values () (read-char p) (datum->syntax #f)) (if (eq? c #\\) (let-values () (read-char p) (datum->syntax (read-character))) (if (eq? c #\') (let-values () (read-char p) (datum->syntax (list (quote syntax) (read-loop)))) (if (eq? c oparen) (let-values () (read-char p) (datum->syntax (read-vector))) (if (eq? c #\&) (let-values () (read-char p) (datum->syntax (box (read-loop)))) (if (eq? c #\x) (let-values () (read-char p) (datum->syntax (read-hex-number (peek-char p)))) (if (eq? c #\;) (let-values () (read-char p) (skip-until-token!) (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values))) (() (let-values () (read-loop) (values)))) (read-loop))) (if (eq? c #\|) (let-values () (read-char p) (skip-block-comment!) (datum->syntax (read-loop))) (error (quote read) "unknown special character" c)))))))))))) (if (let-values (((or-t) (eq? c #\+))) (if or-t or-t (eq? c #\-))) (let-values () (read-char p) (letrec-values (((n) (peek-char p))) (if (digit? n) (let-values () (letrec-values (((pos-num) (read-number))) (if (eq? c #\-) (datum->syntax (- pos-num)) (datum->syntax pos-num)))) (datum->syntax (read-symbol (list c)))))) (if (digit? c) (datum->syntax (read-number)) (if (eq? c #\") (let-values () (read-char p) (letrec-values (((str-chars) (read-string)) (() (let-values () (assert-delimeter! (peek-char p)) (values)))) (datum->syntax (apply string str-chars)))) (if (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (eq? c obrace))))) (let-values () (read-char p) (datum->syntax (read-pair c))) (if (eq? c #\') (let-values () (read-char p) (datum->syntax (list (quote quote) (read-loop)))) (if (symbol-char? c) (datum->syntax (read-symbol (quote ()))) (error (quote read) "unexpected input:" c))))))))))))) (read-loop))))

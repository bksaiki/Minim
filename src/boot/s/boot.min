(define-values (cons*) (lambda (x . xs) (letrec-values (((loop) (lambda (x xs) (if (null? xs) x (cons x (loop (car xs) (cdr xs))))))) (loop x xs))))
(define-values (first) (lambda (xs) (if (list? xs) (car xs) (error (quote first) "list?" xs))))
(define-values (second) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote second) "list contains too few elements" xs))))) (loop xs 2)) (error (quote second) "list?" xs))))
(define-values (third) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote third) "list contains too few elements" xs))))) (loop xs 3)) (error (quote third) "list?" xs))))
(define-values (fourth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote fourth) "list contains too few elements" xs))))) (loop xs 4)) (error (quote fourth) "list?" xs))))
(define-values (fifth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote fifth) "list contains too few elements" xs))))) (loop xs 5)) (error (quote fifth) "list?" xs))))
(define-values (sixth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote sixth) "list contains too few elements" xs))))) (loop xs 6)) (error (quote sixth) "list?" xs))))
(define-values (seventh) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote seventh) "list contains too few elements" xs))))) (loop xs 7)) (error (quote seventh) "list?" xs))))
(define-values (eighth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote eighth) "list contains too few elements" xs))))) (loop xs 8)) (error (quote eighth) "list?" xs))))
(define-values (ninth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote ninth) "list contains too few elements" xs))))) (loop xs 9)) (error (quote ninth) "list?" xs))))
(define-values (tenth) (lambda (xs) (if (list? xs) (letrec-values (((loop) (lambda (xs pos) (if (pair? xs) (if (= pos 1) (car xs) (loop (cdr xs) (- pos 1))) (error (quote tenth) "list contains too few elements" xs))))) (loop xs 10)) (error (quote tenth) "list?" xs))))
(define-values (list-ref) (lambda (lst k) (letrec-values ((() (let-values () (if (integer? k) (void) (let-values () (error (quote list-ref) "expected a non-negative integer" k))) (values)))) (letrec-values (((loop) (lambda (xs i) (if (null? xs) (error (quote list-ref) "index out of bounds" lst k) (if (= i k) (car xs) (loop (cdr xs) (+ i 1))))))) (loop lst 0)))))
(define-values (member) (lambda (k xs) (letrec-values (((loop) (lambda (xs) (if (null? xs) #f (if (pair? xs) (if (equal? (car xs) k) (car xs) (loop (cdr xs))) (error (quote member) "expected a list" xs)))))) (loop xs))))
(define-values (remove) (lambda (k xs) (letrec-values (((loop) (lambda (xs) (if (null? xs) (quote ()) (if (pair? xs) (if (equal? (car xs) k) (loop (cdr xs)) (cons (car xs) (loop (cdr xs)))) (error (quote remove) "expected a list" xs)))))) (loop xs))))
(define-values (remove*) (lambda (ks xs) (letrec-values ((() (let-values () (if (list? ks) (void) (let-values () (error (quote remove*) "expected a list" ks))) (values)))) (letrec-values (((loop) (lambda (ks xs) (if (null? ks) xs (if (null? xs) (quote ()) (loop (cdr ks) (letrec-values (((loop2) (lambda (xs) (if (null? xs) (quote ()) (if (pair? xs) (if (equal? (car xs) (car ks)) (loop2 (cdr xs)) (cons (car xs) (loop2 (cdr xs)))) (error (quote remove*) "expected a list" xs)))))) (loop2 xs)))))))) (loop ks xs)))))
(define-values (filter) (lambda (f lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) (reverse acc) (if (pair? xs) (if (f (car xs)) (loop (cdr xs) (cons (car xs) acc)) (loop (cdr xs) acc)) (error (quote filter) "expected a list" lst)))))) (loop lst (quote ())))))
(define-values (foldl) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) acc (if (pair? xs) (loop (cdr xs) (f acc (car xs))) (error (quote foldl) "expected a list" lst)))))) (loop lst acc))))
(define-values (foldr) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs) (if (null? xs) acc (if (pair? xs) (f (loop (cdr xs)) (car xs)) (error (quote foldr) "expected a list" lst)))))) (loop lst))))
(define-values (assoc) (lambda (k lst) (letrec-values (((loop) (lambda (xs) (if (null? xs) #f (if (not (pair? xs)) (error (quote assoc) "not a proper list" lst) (if (not (pair? (car xs))) (error (quote assoc) "non-pair found in list" lst) (if (equal? k (caar xs)) (car xs) (loop (cdr xs))))))))) (loop lst))))
(define-values (enumerate) (lambda (f lst) (letrec-values (((loop) (lambda (lst i acc) (if (null? lst) (reverse acc) (loop (cdr lst) (+ i 1) (cons (f (car lst) i) acc)))))) (loop lst 0 (quote ())))))
(define-values (index-of) (lambda (k lst) (letrec-values (((loop) (lambda (lst i) (if (null? lst) #f (if (equal? k (car lst)) i (loop (cdr lst) (+ i 1))))))) (loop lst 0))))
(define-values (list-set) (lambda (lst k v) (letrec-values ((() (let-values () (if (integer? k) (void) (let-values () (error (quote list-set) "expected a non-negative integer" k))) (values)))) (letrec-values (((loop) (lambda (xs i xs*) (if (null? xs) (error (quote list-set) "index out of bounds" lst k) (if (= i k) (append (reverse xs*) (cons v (cdr xs))) (if (pair? xs) (loop (cdr xs) (+ i 1) (cons (car xs) xs*)) (error (quote list-set) "expected a list" lst))))))) (loop lst 0 (quote ()))))))
(define-values (is-absolute-path?) (lambda (path) (if (> (string-length path) 0) (eq? (string-ref path 0) #\/) #f)))
(define-values (build-path) (lambda (base . subpaths) (letrec-values (((string-terminates-with-/?) (lambda (str) (letrec-values (((len) (string-length str))) (eq? (string-ref str (- len 1)) #\/)))) ((paths) (letrec-values (((loop) (lambda (paths accum) (if (null? paths) (reverse accum) (if (= (string-length (car paths)) 0) (loop (cdr paths) accum) (if (string-terminates-with-/? (car accum)) (loop (cdr paths) (cons (car paths) accum)) (loop (cdr paths) (cons (car paths) (cons "/" accum))))))))) (loop subpaths (list base))))) (apply string-append paths))))
(define-values (split-path) (lambda (path) (letrec-values ((() (let-values () (if (string? path) (void) (let-values () (error (quote split-path) "expected string?" path))) (values))) ((path-elems) (reverse (path->list path)))) (if (pair? (cdr path-elems)) (let-values () (letrec-values (((end) (car path-elems)) ((rest) (cdr path-elems))) (cons (apply build-path (reverse rest)) end))) (cons #f (car path-elems))))))
(define-values (path->list) (lambda (path) (letrec-values ((() (let-values () (if (string? path) (void) (let-values () (error (quote path->list) "expected string?" path))) (values)))) (letrec-values (((loop) (lambda (path accum) (if (= (string-length path) 0) (reverse accum) (let-values () (letrec-values (((len) (string-length path))) (letrec-values (((loop2) (lambda (i) (if (= i len) (loop "" (cons path accum)) (if (eq? (string-ref path i) #\/) (if (= i 0) (loop (substring path 1 len) (cons "/" accum)) (let-values () (letrec-values (((elem) (substring path 0 i)) ((rest) (substring path (+ i 1) len))) (loop rest (cons elem accum))))) (loop2 (+ i 1))))))) (loop2 0)))))))) (loop path (quote ()))))))
(define-values (record-type-size) (lambda (rtd) (vector-length (record-type-field-names rtd))))
(define-values (record-size) (lambda (rtd) (letrec-values (((loop) (lambda (rtd size) (let-values (((size) (+ size (record-type-size rtd)))) (if (record-type-parent rtd) (loop (record-type-parent rtd) size) size))))) (loop rtd 0))))
(define-values (record-is-type?) (lambda (rtd r) (letrec-values (((loop) (lambda (r-rtd) (if (eq? rtd r-rtd) #t (if (record-type-parent r-rtd) (loop (record-type-parent r-rtd)) #f))))) (loop ($record-rtd r)))))
(define-values (record?) (lambda (r) (if ($record-value? r) (not (record-type-opaque? ($record-rtd r))) #f)))
(define-values (record-rtd) (lambda (r) (letrec-values (((rtd) ($record-rtd r))) (if (record-type-opaque? rtd) (error (quote record-rtd) "cannot inspect opaque records" (format " record: ~a" r)) rtd))))
(define-values (record-constructor) (lambda (rtd) (letrec-values (((size) (record-size rtd))) (lambda args (letrec-values ((() (let-values () (if (= (length args) size) (void) (let-values () (error (quote arity-mismatch) (format "~s constructor" rtd) (format " field count: ~a" size) (format " fields provided: ~a" (length args))))) (values)))) (apply $make-record rtd args))))))
(define-values (record-predicate) (lambda (rtd) (lambda (r) (if ($record-value? r) (record-is-type? rtd r) #f))))
(define-values (record-accessor) (lambda (rtd idx) (letrec-values (((rtd?) (record-predicate rtd)) ((prtd) (record-type-parent rtd)) ((parent-size) (if prtd (record-size prtd) 0)) ((this-size) (record-type-size rtd)) ((idx*) (+ parent-size idx)) (() (let-values () (if (number? idx) (void) (let-values () (error (quote record-accessor) "expected a non-negative integer?" idx))) (values))) (() (let-values () (if (if (<= 0 idx) (< idx this-size) #f) (void) (let-values () (error (quote record-accessor) "index out of bounds: " idx))) (values)))) (lambda (r) (letrec-values ((() (let-values () (if (rtd? r) (void) (let-values () (error (quote record-accessor) "type-violation" (format "expected: ~a" rtd) (format "got: ~a" r)))) (values)))) ($record-ref r idx*))))))
(define-values (record-mutator) (lambda (rtd idx) (letrec-values (((rtd?) (record-predicate rtd)) ((prtd) (record-type-parent rtd)) ((parent-size) (if prtd (record-size prtd) 0)) ((this-size) (record-type-size rtd)) ((idx*) (+ parent-size idx)) (() (let-values () (if (number? idx) (void) (let-values () (error (quote record-mutator) "expected a non-negative integer?" idx))) (values))) (() (let-values () (if (if (<= 0 idx) (< idx this-size) #f) (void) (let-values () (error (quote record-mutator) "index out of bounds: " idx))) (values))) (() (let-values () (if (record-type-field-mutable? rtd idx) (void) (let-values () (error (quote record-mutator) "field not mutable: " idx))) (values)))) (lambda (r v) (letrec-values ((() (let-values () (if (rtd? r) (void) (let-values () (error (quote record-mutator) "type-violation" (format "expected: ~a" rtd) (format "got: ~a" r)))) (values)))) ($record-set! r idx* v))))))
(define-values ($record-eq-procs) (make-hashtable))
(define-values ($record-hash-procs) (make-hashtable))
(define-values (record-type-equal-procedure) (lambda (rtd equal-proc) (letrec-values ((() (let-values () (if (record-type-descriptor? rtd) (void) (let-values () (error (quote record-type-equal-procedure) "expected a record type descriptor" rtd))) (values)))) (hashtable-set! $record-eq-procs rtd equal-proc))))
(define-values (record-type-hash-procedure) (lambda (rtd hash-proc) (letrec-values ((() (let-values () (if (record-type-descriptor? rtd) (void) (let-values () (error (quote record-type-hash-procedure) "expected a record type descriptor" rtd))) (values)))) (hashtable-set! $record-hash-procs rtd hash-proc))))
(define-values (record-equal?) (lambda (a b rec-equal?) (letrec-values (((a-rtd) ($record-rtd a)) ((b-rtd) ($record-rtd b))) (if (eq? a-rtd b-rtd) (let-values (((proc) (hashtable-ref $record-eq-procs a-rtd #f))) (if proc (proc a b rec-equal?) #f)) #f))))
(define-values (record-hash) (lambda (r rec-hash) (letrec-values (((rtd) ($record-rtd r)) ((proc) (hashtable-ref $record-hash-procs rtd #f))) (if proc (proc r rec-hash) #f))))
(define-values (set) (let-values (((p) #f)) (if (if p (record-type-sealed? p) #f) (error (quote define-record-type) "parent record type is sealed" (format "record type: #<record-type:~a>" (quote set)) (format "parent type: ~a" p)) (make-record-type-descriptor (quote set) p #f #t #t (quote #((mutable store)))))))
(define-values (make-set) (let-values (((c) (record-constructor set)) ((p) (lambda (p) (lambda xs (letrec-values (((h) (make-hashtable)) (() (let-values () (for-each (lambda (x) (hashtable-set! h x (quote ()))) xs) (values)))) (p h)))))) (if p (p c) c)))
(define-values (set?) (record-predicate set))
(define-values (set-store) (record-accessor set 0))
(define-values (set-store-set!) (record-mutator set 0))
(define-values (set-member?) (lambda (s v) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set-member?) "expected a set" s))) (values)))) (hashtable-contains? (set-store s) v))))
(define-values (set-empty?) (lambda (st) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set-empty?) "expected a set" st))) (values)))) (= (hashtable-size (set-store st)) 0))))
(define-values (set-count) (lambda (s) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set-count) "expected a set" s))) (values)))) (hashtable-size (set-store s)))))
(define-values (set-copy) (lambda (st) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set-copy) "expected a set" st))) (values))) ((cp) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! cp x)) (set->list st)) (values)))) cp)))
(define-values (set-add!) (lambda (s v) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set-add!) "expected a set" s))) (values)))) (hashtable-set! (set-store s) v (quote ())))))
(define-values (set-remove!) (lambda (s v) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set-remove!) "expected a set" s))) (values)))) (hashtable-delete! (set-store s) v))))
(define-values (set-clear!) (lambda (st) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set-clear!) "expected a set" st))) (values)))) (hashtable-clear! (set-store st)))))
(define-values (set->list) (lambda (s) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set->list) "expected a set" s))) (values)))) (hashtable-keys (set-store s)))))
(define-values (subset?) (lambda (st st2) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote subset?) "expected a set" st))) (values))) (() (let-values () (if (set? st2) (void) (let-values () (error (quote subset?) "expected a set" st2))) (values)))) (letrec-values (((loop) (lambda (elts) (if (null? elts) #t (if (set-member? st2 (car elts)) (loop (cdr elts)) #f))))) (loop (set->list st))))))
(define-values (proper-subset?) (lambda (st st2) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote proper-subset?) "expected a set" st))) (values))) (() (let-values () (if (set? st2) (void) (let-values () (error (quote proper-subset?) "expected a set" st2))) (values)))) (if (subset? st st2) (not (subset? st2 st)) #f))))
(define-values (set=?) (lambda (st st2) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set=?) "expected a set" st))) (values))) (() (let-values () (if (set? st2) (void) (let-values () (error (quote set=?) "expected a set" st2))) (values)))) (if (subset? st st2) (subset? st2 st) #f))))
(define-values (set-map) (lambda (proc st) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set-map) "expected a set" st))) (values)))) (map proc (set->list st)))))
(define-values (set-for-each) (lambda (proc st) (letrec-values ((() (let-values () (if (set? st) (void) (let-values () (error (quote set-for-each) "expected a set" st))) (values)))) (for-each proc (set->list st)))))
(define-values (set-union) (lambda ss (letrec-values ((() (let-values () (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-union) "expected a set" s)))) ss) (values)))) (if (null? ss) (make-set) (if (null? (cdr ss)) (let-values () (letrec-values (((s) (car ss)) ((c) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! c x)) (set->list s)) (values)))) c)) (let-values () (letrec-values (((u) (make-set)) (() (let-values () (for-each (lambda (s) (letrec-values ((() (let-values () (if (set? s) (void) (let-values () (error (quote set-union) "expected a set" s))) (values)))) (for-each (lambda (x) (set-add! u x)) (set->list s)))) ss) (values)))) u)))))))
(define-values (set-intersect) (lambda ss (letrec-values ((() (let-values () (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-intersect) "expected a set" s)))) ss) (values)))) (if (null? ss) (make-set) (if (null? (cdr ss)) (let-values () (letrec-values (((s) (car ss)) ((c) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! c x)) (set->list s)) (values)))) c)) (let-values () (letrec-values (((s) (car ss)) ((i) (make-set)) (() (let-values () (for-each (lambda (x) (set-add! i x)) (set->list s)) (values)))) (letrec-values (((loop) (lambda (ss i) (if (null? ss) i (if (= (set-count i) 0) i (let-values () (letrec-values (((s) (car ss)) ((i*) (make-set)) (() (let-values () (for-each (lambda (x) (if (set-member? s x) (let-values () (set-add! i* x)) (void))) (set->list i)) (values)))) (loop (cdr ss) i*)))))))) (loop (cdr ss) i)))))))))
(define-values (set-subtract) (lambda (st0 . sts) (letrec-values ((() (let-values () (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-subtract) "expected a set" s)))) (cons st0 sts)) (values))) ((diff) (set-copy st0))) (letrec-values (((loop) (lambda (sts) (if (null? sts) diff (let-values () (letrec-values (((st) (car sts)) (() (let-values () (set-for-each (lambda (x) (if (set-member? st x) (let-values () (set-remove! diff x)) (void))) diff) (values)))) (loop (cdr sts)))))))) (loop sts)))))
(define-values (set-symmetric-difference) (lambda (st0 . sts) (letrec-values ((() (let-values () (for-each (lambda (s) (if (set? s) (void) (let-values () (error (quote set-symmetric-difference) "expected a set" s)))) (cons st0 sts)) (values))) ((diff) (set-copy st0))) (letrec-values (((loop) (lambda (sts) (if (null? sts) diff (let-values () (letrec-values (((st) (car sts)) (() (let-values () (set-for-each (lambda (x) (if (set-member? diff x) (set-remove! diff x) (set-add! diff x))) st) (values)))) (loop (cdr sts)))))))) (loop sts)))))
(define-values (substring) (lambda (str start end) (letrec-values (((len) (string-length str))) (if (not (string? str)) (error (quote substring) "expected string? for" str) (if (not (number? start)) (error (quote substring) "expected number? for" start) (if (not (number? end)) (error (quote substring) "expected number? for" end) (if (> end len) (error (quote substring) "index out of bounds" end) (if (> start end) (error (quote substring) "invalid bounds" start end) (if (= start end) "" (let-values () (letrec-values (((sstr) (make-string (- end start)))) (letrec-values (((loop) (lambda (i n) (if (= n end) sstr (let-values () (letrec-values ((() (let-values () (string-set! sstr i (string-ref str n)) (values)))) (loop (+ i 1) (+ n 1)))))))) (loop 0 start)))))))))))))
(define-values (identifier?) (lambda (t) (if (syntax? t) (symbol? (syntax-e t)) #f)))
(define-values (free-identifier=?) (lambda (a b) (if (not (identifier? a)) (error (quote free-identifier=?) "expected identifier?" a) (if (not (identifier? b)) (error (quote free-identifier=?) "expected identifier?" b) (eq? (syntax-e a) (syntax-e b))))))
(define-values (stx-null?) (lambda (t) (if (null? t) #t (if (syntax? t) (null? (syntax-e t)) #f))))
(define-values (stx-pair?) (lambda (t) (if (pair? t) #t (if (syntax? t) (pair? (syntax-e t)) #f))))
(define-values (stx-list?) (lambda (t) (if (list? t) #t (if (syntax? t) (list? (syntax-e t)) #f))))
(define-values (stx-vector?) (lambda (t) (if (vector? t) #t (if (syntax? t) (vector? (syntax-e t)) #f))))
(define-values (stx-car) (lambda (t) (if (pair? t) (car t) (car (syntax-e t)))))
(define-values (stx-cdr) (lambda (t) (if (pair? t) (cdr t) (cdr (syntax-e t)))))
(define-values (stx-vector-ref) (lambda (s i) (vector-ref (syntax-e s) i)))
(define-values (stx-null/#f) (lambda (t) (if (null? t) null (if (syntax? t) (if (null? (syntax-e t)) null #f) #f))))
(define-values (cons/#f) (lambda (x1 x2) (if x2 (cons x1 x2) #f)))
(define-values (append/#f) (lambda (l1 l2) (if l1 (if l2 (if (null? l2) l1 (append l1 l2)) #f) #f)))
(define-values (map/#f) (lambda (fn x . xs) (let-values (((lsts) (cons x xs))) (if (andmap (lambda (x) x) lsts) (apply map fn lsts) #f))))
(define-values (stx->list) (lambda (t) (if (syntax? t) (if (stx-list? t) (syntax-e t) #f) (if (list? t) (if (andmap (lambda (x) (syntax? x)) t) t #f) #f))))
(define-values (split-stx-list) (lambda (s n prop?) (let-values (((pre post m) (letrec-values (((loop) (lambda (s) (if (stx-pair? s) (let-values (((pre post m) (loop (stx-cdr s)))) (if (< m n) (values null s (+ m 1)) (values (cons (stx-car s) pre) post m))) (values null s (if prop? (if (stx-null? s) 0 -inf.0) 1)))))) (loop s)))) (values pre post (= m n)))))
(define-values (lookup-xform) (lambda (maybe-id xforms) (if (identifier? maybe-id) (let-values (((entry) (assoc (syntax-e maybe-id) xforms))) (if entry (cdr entry) #f)) #f)))
(define-values (merge-xforms) (lambda (new-xforms xforms) (letrec-values (((loop) (lambda (new-xforms xforms) (if (null? new-xforms) xforms (if (assoc (caar new-xforms) xforms) (loop (cdr new-xforms) xforms) (loop (cdr new-xforms) (cons (car new-xforms) xforms))))))) (loop new-xforms xforms))))
(define-values (_-form?) (lambda (form-name) (lambda (expr) (if (stx-pair? expr) (let-values (((head) (stx-car expr))) (if (identifier? head) (eq? (syntax-e head) form-name) #f)) #f))))
(define-values (define-values-form?) (_-form? (quote define-values)))
(define-values (define-syntaxes-form?) (_-form? (quote define-syntaxes)))
(define-values (let-values-form?) (_-form? (quote let-values)))
(define-values (letrec-values-form?) (_-form? (quote letrec-values)))
(define-values (let-syntaxes-form?) (_-form? (quote let-syntaxes)))
(define-values (quote-form?) (_-form? (quote quote)))
(define-values (quote-syntax-form?) (_-form? (quote quote-syntax)))
(define-values (lambda-form?) (_-form? (quote lambda)))
(define-values (begin-form?) (_-form? (quote begin)))
(define-values (if-form?) (_-form? (quote if)))
(define-values (stx-self-evaluating?) (lambda (stx) (letrec-values (((datum) (syntax-e stx))) (let-values (((or-t) (boolean? datum))) (if or-t or-t (let-values (((or-t) (number? datum))) (if or-t or-t (let-values (((or-t) (string? datum))) (if or-t or-t (let-values (((or-t) (vector? datum))) (if or-t or-t (let-values (((or-t) (box? datum))) (if or-t or-t (char? datum))))))))))))))
(define-values (duplicate-identifier) (lambda (ids new-ids) (letrec-values (((loop) (lambda (ids new-ids) (if (null? new-ids) #f (let-values () (letrec-values (((dup) (member (car new-ids) ids))) (let-values (((or-t) dup)) (if or-t or-t (loop (cons (car new-ids) ids) (cdr new-ids)))))))))) (loop ids new-ids))))
(define-values (check-define-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error name "bad syntax" form)) (void)) (values))) ((ids) (syntax->list (stx-car rib0))) ((rib1) (stx-cdr rib0)) (() (let-values () (if (if (list? ids) (andmap identifier? ids) #f) (void) (let-values () (syntax-error name "not identifiers" form ids))) (values))) (() (let-values () (if (stx-null? rib1) (let-values () (syntax-error name "expected an expression after identifiers" form)) (void)) (values))) ((rib2) (stx-cdr rib1))) (if (stx-null? rib2) (void) (let-values () (syntax-error name "too many expressions" form))))))
(define-values (check-let-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib) (stx-cdr form)) (() (let-values () (if (stx-null? rib) (let-values () (syntax-error name "bad syntax" form)) (void)) (values))) ((bindings) (syntax->list (stx-car rib))) ((bind-rib) (stx-cdr rib)) (() (let-values () (if (null? bind-rib) (let-values () (syntax-error name "missing body" form)) (void)) (values))) (() (let-values () (if (let-values (((or-t) (list? bind-rib))) (if or-t or-t (if (syntax? bind-rib) (list? (syntax->list bind-rib)) #f))) (void) (let-values () (syntax-error name "not a sequence of bindings" form bindings))) (values))) (() (let-values () (if (list? bindings) (void) (let-values () (syntax-error #f "expected a sequence of expressions after the bindings" form))) (values)))) (letrec-values (((loop) (lambda (bindings) (if (null? bindings) (void) (let-values () (letrec-values (((bind) (syntax->list (car bindings))) (() (let-values () (if (if (list? bind) (= (length bind) 2) #f) (void) (let-values () (syntax-error #f "expected a sequence of expressions after the bindings" form))) (values))) ((ids) (syntax->list (car bind))) (() (let-values () (if (if (list? ids) (andmap identifier? ids) #f) (void) (let-values () (syntax-error name "not identifiers" form ids))) (values)))) (loop (cdr bindings)))))))) (loop bindings)))))
(define-values (check-lambda-form!) (lambda (form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error #f "missing formals" form)) (void)) (values))) ((formals) (stx-car rib0)) ((rib1) (stx-cdr rib0)) (() (let-values () (if (null? rib1) (let-values () (syntax-error #f "missing expression after formals" form)) (void)) (values))) ((rib2) (stx-cdr rib1))) (if (let-values (((or-t) (list? rib2))) (if or-t or-t (if (syntax? rib2) (list? (syntax->list rib2)) #f))) (void) (let-values () (syntax-error #f "expected a sequence of expressions after formals" form))))))
(define-values (check-begin-form!) (lambda (form) (if (syntax->list form) (void) (let-values () (syntax-error (quote begin) "bad syntax" form)))))
(define-values (check-1ary-form!) (lambda (name form) (letrec-values (((rib0) (stx-cdr form)) (() (let-values () (if (stx-null? rib0) (let-values () (syntax-error name "expected an expression" form)) (void)) (values))) ((rib1) (stx-cdr rib0))) (if (stx-null? rib1) (void) (let-values () (syntax-error name "too many expressions" form))))))
(define-values (check-if-form!) (lambda (form) (letrec-values (((rib) (stx-cdr form)) (() (let-values () (if (stx-null? rib) (let-values () (syntax-error (quote if) "bad syntax" form)) (void)) (values))) ((cond-rib) (stx-cdr rib)) (() (let-values () (if (stx-null? cond-rib) (let-values () (syntax-error (quote if) "bad syntax" form)) (void)) (values))) ((ift-rib) (stx-cdr cond-rib)) (() (let-values () (if (stx-null? ift-rib) (let-values () (syntax-error (quote if) "missing an "else" statement" form)) (void)) (values))) ((iff-rib) (stx-cdr ift-rib))) (if (stx-null? iff-rib) (void) (let-values () (syntax-error name "too many expressions" form))))))
(define-values (check-duplicate-identifier!) (lambda (form name ids new-ids) (letrec-values (((dup) (duplicate-identifier ids new-ids))) (if dup (let-values () (syntax-error name "duplicate identifier" form dup)) (void)))))
(define-values ($expander-pattern-vars) null)
(define-values ($base-stx-env) (lambda (env) (let-values (((env) (extend-environment env))) (letrec-values ((() (let-values () (environment-set-variable-value! env (quote get-pattern-variable) (lambda (k) (if (symbol? k) (letrec-values (((loop) (lambda (assoc) (if (null? assoc) #f (if (eq? (caar assoc) k) (cadar assoc) (loop (cdr assoc))))))) (loop $expander-pattern-vars)) (error (quote get-pattern-variable) "expected symbol?" k)))) (values)))) env))))
(define-values (expand/module) (lambda (exprs xforms env) (letrec-values (((define-syntaxes/values-identifiers) (lambda (form) (map syntax-e (syntax->list (stx-car (stx-cdr form)))))) ((define-syntaxes/values-expr) (lambda (form) (stx-car (stx-cdr (stx-cdr form))))) ((eval/values) (lambda (expr env) (call-with-values (lambda () (eval expr env)) (lambda results results)))) ((eval/xform) (lambda (xform expr name) (letrec-values (((fn) (car xform))) (call-with-values (lambda () (fn expr)) (lambda results (if (not (= (length results) 1)) (error #f "result arity mismatch" "expected 1" "received" 2) (if (syntax? (car results)) (car results) (error name "transformer produced something other than syntax" (car results))))))))) ((expand/body) (lambda (exprs xforms) (if (null? exprs) (list) (letrec-values (((loop) (lambda (exprs defines) (letrec-values (((expr*) (expand/expr (car exprs) xforms))) (if (null? (cdr exprs)) (if (let-values (((or-t) (define-values-form? expr*))) (if or-t or-t (define-syntaxes-form? expr*))) (error (quote begin) "last form is not an expression" (car exprs)) (if (null? defines) (list expr*) (list (datum->syntax (list (quote-syntax letrec-values) (reverse defines) expr*))))) (if (begin-form? expr*) (loop (append (cdr (syntax->list expr*)) (cdr exprs)) defines) (if (define-syntaxes-form? expr*) (let-values () (letrec-values (((form) (syntax->list expr*)) ((ids) (cadr form)) ((value) (caddr form))) (list (expand/expr (datum->syntax (list (quote-syntax letrec-values) (reverse defines) (cons (quote-syntax let-syntaxes) (cons (list (list ids value)) (cdr exprs))))) xforms)))) (if (define-values-form? expr*) (let-values () (letrec-values (((form) (syntax->list expr*)) ((ids) (cadr form)) ((value) (caddr form))) (loop (cdr exprs) (cons (list ids value) defines)))) (let-values () (letrec-values (((value) (datum->syntax (list (quote-syntax let-values) (quote ()) expr* (list (quote-syntax values)))))) (loop (cdr exprs) (cons (list (quote ()) value) defines)))))))))))) (loop exprs (quote ())))))) ((expand/expr) (lambda (expr xforms) (letrec-values ((() (let-values () (set! $expander-pattern-vars (filter (lambda (e) (pattern-variable? (cadr e))) xforms)) (values)))) (letrec-values (((loop) (lambda (expr) (if (define-values-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-values) expr) (values)))) (let-values (((ids) (define-syntaxes/values-identifiers expr))) (letrec-values ((() (let-values () (check-duplicate-identifier! expr (quote define-values) null ids) (values)))) (let-values (((form) (syntax->list expr))) (datum->syntax (list (car form) (cadr form) (loop (caddr form))))))))) (if (let-syntaxes-form? expr) (let-values () (letrec-values ((() (let-values () (check-let-syntaxes/values-form! (quote let-syntaxes) expr) (values))) ((form) (syntax->list expr))) (letrec-values (((rec) (lambda (bindings let-ids xforms) (if (null? bindings) (expand/expr (datum->syntax (cons (quote-syntax let-values) (cons (list) (cddr form)))) xforms) (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((binding-ids) (syntax->datum (car binding))) (() (let-values () (check-duplicate-identifier! expr (quote let-syntaxes) let-ids binding-ids) (values))) ((results) (let-values (((rhs) (loop (cadr binding)))) (eval/values (syntax->datum rhs) env)))) (if (= (length binding-ids) (length results)) (letrec-values (((bind-xforms) (lambda (ids results xforms) (if (null? ids) (rec (cdr bindings) (append binding-ids let-ids) xforms) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results))) (if (let-values (((or-t) (procedure? xform))) (if or-t or-t (pattern-variable? xform))) (let-values () (letrec-values (((xform-entry) (cons id (list xform xforms)))) (bind-xforms (cdr ids) (cdr results) (cons xform-entry xforms)))) (error (quote let-syntaxes) "expected a procedure? received" xform)))))))) (bind-xforms binding-ids results xforms)) (error (quote let-syntaxes) "result arity mismatch" "expected" (length ids) "received" (length results))))))))) (rec (syntax->list (cadr form)) null xforms)))) (if (let-values (((or-t) (let-values-form? expr))) (if or-t or-t (letrec-values-form? expr))) (let-values () (letrec-values (((name) (if (let-values-form? expr) (quote let-values) (quote letrec-values))) (() (let-values () (check-let-syntaxes/values-form! name expr) (values))) ((form) (syntax->list expr)) ((body) (cddr form))) (datum->syntax (cons (car form) (cons (letrec-values (((rec) (lambda (bindings let-ids) (if (null? bindings) null (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((ids) (syntax->datum (car binding))) (() (let-values () (check-duplicate-identifier! expr name let-ids ids) (values)))) (cons (list (car binding) (loop (cadr binding))) (rec (cdr bindings) (append ids let-ids))))))))) (rec (syntax->list (cadr form)) null)) (expand/body body xforms)))))) (if (lambda-form? expr) (let-values () (letrec-values ((() (let-values () (check-lambda-form! expr) (values))) ((head) (stx-car expr)) ((formals) (stx-car (stx-cdr expr))) ((body) (stx-cdr (stx-cdr expr)))) (datum->syntax (cons head (cons formals (expand/body body xforms)))))) (if (if-form? expr) (let-values () (letrec-values ((() (let-values () (check-if-form! expr) (values))) ((form) (syntax->list expr))) (datum->syntax (list (car form) (loop (cadr form)) (loop (caddr form)) (loop (cadddr form)))))) (if (begin-form? expr) (let-values () (letrec-values ((() (let-values () (check-begin-form! expr) (values))) ((body) (stx-cdr expr))) (datum->syntax (cons (stx-car expr) (map loop (cdr (syntax->list expr))))))) (if (quote-form? expr) (let-values () (letrec-values ((() (let-values () (check-1ary-form! (quote quote) expr) (values)))) expr)) (if (quote-syntax-form? expr) (let-values () (letrec-values ((() (let-values () (check-1ary-form! (quote quote-syntax) expr) (values)))) expr)) (if (stx-pair? expr) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/expr (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms (cadr maybe-xform) xforms)) (datum->syntax (map loop (syntax->list expr)))))) (if (identifier? expr) (let-values () (letrec-values (((maybe-xform) (lookup-xform expr xforms))) (if maybe-xform (loop (eval/xform maybe-xform expr (syntax-e expr) $module-boot-expander?)) expr))) (if (stx-self-evaluating? expr) expr (syntax-error (quote expand/expr) "bad syntax" expr))))))))))))))) (loop expr))))) ((expand/module) (lambda (exprs xforms) (letrec-values (((expand/top-level) (lambda (expr xforms) (if (define-syntaxes-form? expr) (values expr xforms) (if (define-values-form? expr) (values expr xforms) (if (begin-form? expr) (values expr xforms) (if (if (stx-pair? expr) (identifier? (stx-car expr)) #f) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/top-level (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms (cadr maybe-xform) xforms)) (values expr xforms)))) (values expr xforms))))))) ((expand/non-define-values) (lambda (exprs xforms) (letrec-values (((xforms) xforms) ((define-ids) null) ((xform-ids) null) ((exprs*) (letrec-values (((loop) (lambda (exprs) (if (null? exprs) null (letrec-values (((with-scope) (lambda (exprs in-scope) (letrec-values (((expr in-scope) (expand/top-level (car exprs) in-scope))) (if (define-syntaxes-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-syntaxes) expr) (values))) ((ids rhs) (let-values (((ids) (define-syntaxes/values-identifiers expr))) (letrec-values ((() (let-values () (check-duplicate-identifier! expr (quote define-syntaxes) xform-ids ids) (values)))) (values ids (define-syntaxes/values-expr expr))))) ((results) (let-values (((rhs*) (expand/expr rhs in-scope))) (eval/values (syntax->datum rhs*) env)))) (if (= (length ids) (length results)) (letrec-values (((rec) (lambda (ids results) (if (null? ids) (loop (cdr exprs)) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results))) (if (procedure? xform) (let-values () (letrec-values (((binding) (cons id (list xform null))) (() (let-values () (set! xform-ids (cons id xform-ids)) (values))) (() (let-values () (set! xforms (let-values (((xforms-in-scope) (cons binding xforms))) (letrec-values (((loop) (lambda (xforms) (if (null? xforms) null (cons (if (member (caar xforms) xform-ids) (cons (caar xforms) (list (cadar xforms) xforms-in-scope)) (car xforms)) (loop (cdr xforms))))))) (loop xforms-in-scope)))) (values)))) (rec (cdr ids) (cdr results)))) (error (quote define-syntaxes) "expected a procedure? received" xform)))))))) (rec ids results)) (error (quote define-syntaxes) "result arity mismatch" "expected" (length ids) "received" (length results))))) (if (define-values-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-values) expr) (values))) ((ids) (define-syntaxes/values-identifiers expr)) (() (let-values () (check-duplicate-identifier! expr (quote define-values) define-ids ids) (values))) (() (let-values () (set! define-ids (append ids define-ids)) (values)))) (cons expr (loop (cdr exprs))))) (if (begin-form? expr) (let-values () (letrec-values ((() (let-values () (check-begin-form! expr) (values))) ((forms) (cdr (syntax->list expr)))) (if (null? forms) (loop (cdr exprs)) (append (with-scope forms in-scope) (loop (cdr exprs)))))) (cons (expand/expr expr in-scope) (loop (cdr exprs)))))))))) (with-scope exprs xforms)))))) (loop exprs)))) (values exprs* xforms)))) ((expand/define-values) (lambda (exprs xforms) (letrec-values (((loop) (lambda (exprs exprs*) (if (null? exprs) (reverse exprs*) (if (define-values-form? (car exprs)) (let-values () (letrec-values (((form) (syntax->list (car exprs)))) (loop (cdr exprs) (cons (datum->syntax (list (car form) (cadr form) (expand/expr (caddr form) xforms))) exprs*)))) (loop (cdr exprs) (cons (car exprs) exprs*))))))) (loop exprs null)))) ((exprs* xforms*) (expand/non-define-values exprs xforms)) ((exprs**) (expand/define-values exprs* xforms*))) (values exprs** xforms*))))) (expand/module exprs xforms))))
(define-values (expand) (lambda (expr xforms env) (letrec-values (((exprs* xforms*) (expand/module (list expr) xforms env))) (if (null? exprs*) (values (quote-syntax (void)) xforms*) (values (car exprs*) xforms*)))))
(define-values (writeln) (lambda (o) (lambda args (let-values (((l) (length args))) (if (= l (length (quote (o)))) (apply (lambda (o) (writeln o (current-output-port))) args) (if (= l (length (quote (o p)))) (apply (lambda (o p) (letrec-values ((() (let-values () (write o p) (values)))) (newline p))) args) (error "arity mismatch: given ~a" l)))))))
(define-values ($base-env) (environment))
(define-values ($module-table) (quote ()))
(define-values ($module-envs) (quote ()))
(define-values ($module-internals) (quote ()))
(define-values ($load-module) (lambda (path print-handler result-handler) (letrec-values (((new-cwd) (car (split-path path))) ((exported) (quote ())) ((imported) (quote ())) ((imported-xforms) (quote ())) ((imported-modules) (quote ())) ((stx-env) #f) ((module-xforms) (quote ())) (($read) (lambda () (letrec-values (((p) (open-input-file path))) (letrec-values (((loop) (lambda (exprs) (letrec-values (((datum) (read p))) (if (eof-object? datum) (let-values () (letrec-values ((() (let-values () (close-input-port p) (values)))) (reverse exprs))) (loop (cons datum exprs))))))) (loop (quote ())))))) (($import) (lambda (exprs) (letrec-values (((loop) (lambda (exprs evalable) (if (null? exprs) (reverse evalable) (let-values () (letrec-values (((expr) (syntax-e (car exprs)))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote import)) #f) (letrec-values (((loop2) (lambda (imports) (if (null? imports) (loop (cdr exprs) evalable) (if (pair? imports) (let-values () (letrec-values (((maybe-import) (syntax-e (car imports)))) (if (string? maybe-import) (let-values () (letrec-values (((path) (build-path new-cwd maybe-import)) (() (let-values () ($load-or-import path print-handler result-handler) (values))) ((from-module) (cdr (assoc path $module-table))) (() (let-values () (set! imported-modules (cons path imported-modules)) (values))) (() (let-values () (set! imported-xforms (merge-xforms (car from-module) imported-xforms)) (values))) (() (let-values () (set! imported (append (cdr from-module) imported)) (values)))) (loop2 (cdr imports)))) (error (quote import) "bad import syntax")))) (error (quote import) "bad import syntax")))))) (loop2 (cdr expr))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote export)) #f) (letrec-values (((loop2) (lambda (exports) (if (null? exports) (loop (cdr exprs) evalable) (if (pair? exports) (let-values () (letrec-values (((maybe-export) (syntax-e (car exports)))) (if (symbol? maybe-export) (let-values () (letrec-values ((() (let-values () (set! exported (cons maybe-export exported)) (values)))) (loop2 (cdr exports)))) (if (pair? maybe-export) (if (eq? (syntax-e (car maybe-export)) (quote all)) (let-values () (letrec-values (((module-name) (syntax-e (cadr maybe-export))) ((path) (build-path new-cwd module-name))) (if (if (string? module-name) (if (null? (cddr maybe-export)) (member path imported-modules) #f) #f) (let-values () (letrec-values (((from-module) (cdr (assoc path $module-table))) (() (let-values () (set! exported (append (map car (car from-module)) (map car (cdr from-module)) exported)) (values)))) (loop2 (cdr exports)))) (error (quote export) "bad export syntax")))) (error (quote export) "bad export syntax")) (error (quote export) "bad export syntax"))))) (error (quote export) "bad export syntax")))))) (loop2 (cdr expr))) (loop (cdr exprs) (cons (car exprs) evalable)))))))))) (loop exprs (quote ()))))) (($expand) (lambda (exprs) (letrec-values ((() (let-values () (set! stx-env ($base-stx-env ($eval-environment $base-env imported))) (values))) ((exprs* xforms*) (expand/module exprs imported-xforms stx-env)) (() (let-values () (set! module-xforms xforms*) (values)))) exprs*))) ((raw-exprs) ($read)) ((non-import-exprs) ($import raw-exprs)) ((expanded-exprs) ($expand non-import-exprs))) (values expanded-exprs module-xforms imported exported stx-env))))
(define-values ($eval-environment) (lambda (env imports) (letrec-values (((env*) (extend-environment env))) (letrec-values (((loop) (lambda (imports) (if (null? imports) env* (let-values () (letrec-values (((name) (caar imports)) ((value) (cdar imports)) (() (let-values () (environment-set-variable-value! env* name value) (values)))) (loop (cdr imports)))))))) (loop imports)))))
(define-values ($eval-exprs) (lambda (exprs env print-handler) (letrec-values (((loop) (lambda (exprs result) (if (null? exprs) result (let-values () (letrec-values (((expr) (syntax->datum (car exprs)))) (call-with-values (lambda () (eval expr env)) (lambda results (letrec-values (((loop2) (lambda (results prev) (if (null? results) (loop (cdr exprs) prev) (let-values () (letrec-values ((() (let-values () (if (not (void? (car results))) (writeln (car results)) (void)) (values)))) (loop2 (cdr results) (car results)))))))) (loop2 results (void))))))))))) (loop exprs (void)))))
(define-values ($load-or-import-no-check) (lambda (path print-handler result-handler) (letrec-values (((exprs module-xforms imports exports stx-env) ($load-module path print-handler result-handler)) ((env) ($eval-environment $base-env imports)) ((last) ($eval-exprs exprs env print-handler)) ((export-values) (quote ())) ((export-xforms) (quote ())) (() (let-values () (letrec-values (((loop) (lambda (exports) (if (null? exports) (void) (let-values () (letrec-values (((export) (car exports)) ((maybe-xform) (assoc export module-xforms)) (() (let-values () (if maybe-xform (let-values () (letrec-values (((xform) (cdr maybe-xform))) (set! export-xforms (cons (cons export xform) export-xforms)))) (let-values () (letrec-values (((value) (environment-variable-value env export (lambda () (error (quote export) "undefined export" export))))) (set! export-values (cons (cons export value) export-values))))) (values)))) (loop (cdr exports)))))))) (loop exports)) (values))) (() (let-values () (set! $module-table (cons (cons path (cons export-xforms export-values)) $module-table)) (values))) (() (let-values () (set! $module-envs (cons (cons path (cons module-xforms (cons stx-env env))) $module-envs)) (values))) (() (let-values () (set! $module-internals (cons (cons path (list exprs module-xforms imports exports stx-env)) $module-internals)) (values)))) (if result-handler (result-handler last) (void)))))
(define-values ($repl) (lambda (xforms stx-env env) (letrec-values (((loop) (lambda (xforms) (letrec-values ((() (let-values () (display "> ") (values))) ((expr) (read)) (() (let-values () (if (eof-object? expr) (exit) (void)) (values)))) (let-values (((expr* xforms*) (expand expr xforms stx-env))) (letrec-values ((() (let-values () (call-with-values (lambda () (eval expr env)) (lambda results (letrec-values (((loop) (lambda (results) (if (null? results) (void) (if (void? (car results)) (loop (cdr results)) (let-values () (letrec-values ((() (let-values () (writeln (car results)) (values)))) (loop (cdr results))))))))) (loop results)))) (values)))) (loop xforms*))))))) (loop xforms))))
(define-values ($load-or-import) (lambda (name print-handler result-handler) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) (if (assoc path $module-table) (void) (let-values () ($load-or-import-no-check path print-handler result-handler))))))
(define-values (read/module) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) ($load-module path #f #f))))
(define-values (import) (lambda (name) ($load-or-import name (lambda (o) (writeln o)) #f)))
(define-values (load) (lambda (name) (letrec-values (((result) ($load-or-import name #f (lambda (o) o))) (() (let-values () (if (not (void? result)) (writeln result) (void)) (values)))) (enter! name))))
(define-values (enter!) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name))) ((maybe-env) (assoc path $module-envs)) (() (let-values () (if (not maybe-env) (void) (let-values () (error (quote enter!) "unknown module" name))) (values))) ((env) (cdr maybe-env))) ($repl (car env) (extend-environment (cadr env)) (extend-environment (cddr env))))))
(define-values (read) (lambda args (letrec-values (((p) (if (null? args) (current-input-port) (if (null? (cdr args)) (car args) (error (quote read) "arity mismatch\n expected 0 or 1 arguments," "received" (length args))))) (() (let-values () (if (not (input-port? p)) (error (quote read) "expected an input port, received " p) (void)) (values))) ((oparen) (integer->char 40)) ((cparen) (integer->char 41)) ((obrack) (integer->char 91)) ((cbrack) (integer->char 93)) ((obrace) (integer->char 123)) ((cbrace) (integer->char 125)) ((space?) (lambda (c) (let-values (((or-t) (eq? c #\space))) (if or-t or-t (eq? c #\newline))))) ((delimeter?) (lambda (c) (let-values (((or-t) (eof-object? c))) (if or-t or-t (let-values (((or-t) (space? c))) (if or-t or-t (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (let-values (((or-t) (eq? c obrace))) (if or-t or-t (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (let-values (((or-t) (eq? c cbrace))) (if or-t or-t (let-values (((or-t) (eq? c #\"))) (if or-t or-t (eq? c #\;))))))))))))))))))))) ((symbol-char?) (lambda (c) (not (delimeter? c)))) ((digit?) (lambda (c) (letrec-values (((0-char) (char->integer #\0)) ((9-char) (char->integer #\9)) ((i) (char->integer c))) (<= 0-char i 9-char)))) ((hex-digit?) (lambda (c) (letrec-values (((i) (char->integer c))) (let-values (((or-t) (<= (char->integer #\0) i (char->integer #\9)))) (if or-t or-t (let-values (((or-t) (<= (char->integer #\a) i (char->integer #\f)))) (if or-t or-t (<= (char->integer #\A) i (char->integer #\F))))))))) ((digit-prefix?) (lambda (c) (let-values (((or-t) (digit? c))) (if or-t or-t (if (let-values (((or-t) (eq? c #\-))) (if or-t or-t (eq? c #\+))) (digit? (peek-char p)) #f))))) ((assert-not-eof!) (lambda (c) (if (eof-object? c) (error (quote read) "unexpected end of input") (void)))) ((assert-matching-parens!) (lambda (open close) (if (let-values (((or-t) (if (eq? open oparen) (eq? close cparen) #f))) (if or-t or-t (let-values (((or-t) (if (eq? open obrack) (eq? close cbrack) #f))) (if or-t or-t (if (eq? open obrace) (eq? close cbrace) #f))))) (void) (error (quote read) "parenthesis mismatch " open " " close)))) ((assert-delimeter!) (lambda (c) (if (not (delimeter? c)) (error (quote read) "expected a delimeter") (void)))) ((skip-comment!) (lambda () (letrec-values (((c) (peek-char p))) (if (eof-object? c) (void) (if (eq? c #\newline) (void) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (skip-comment!)))))))) ((skip-block-comment!) (lambda () (letrec-values (((loop) (lambda (block-level) (if (= block-level 0) (void) (let-values () (letrec-values (((c) (read-char p))) (if (eq? c #\#) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\|) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (+ block-level 1)))) (loop block-level)))) (if (eq? c #\|) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\#) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (- block-level 1)))) (loop block-level)))) (loop block-level))))))))) (loop 1)))) ((skip-until-token!) (lambda () (letrec-values (((c) (peek-char p))) (if (space? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (skip-until-token!))) (if (eq? c #\;) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-comment!) (values)))) (skip-until-token!))) (void)))))) ((check-expected-string!) (lambda (s) (letrec-values (((len) (string-length s))) (letrec-values (((loop) (lambda (i) (if (< i len) (let-values () (letrec-values (((c) (read-char p))) (if (eof-object? c) (error (quote read) "unexpected end of input") (if (eq? c (string-ref s i)) (loop (+ i 1)) (error (quote read) "unexpected character" c))))) (void))))) (loop 0))))) ((read-pair) (lambda (open) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (letrec-values ((() (let-values () (assert-matching-parens! open c) (values))) (() (let-values () (read-char p) (values)))) (quote ()))) (let-values () (letrec-values (((car) (read-loop))) (letrec-values (((loop) (lambda (car) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\.) (let-values () (letrec-values (((maybe-dot) (read-loop))) (if (eq? (syntax-e maybe-dot) (quote .)) (let-values () (letrec-values (((cdr) (read-loop)) (() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (letrec-values ((() (let-values () (assert-matching-parens! open c) (values))) (() (let-values () (read-char p) (values)))) (cons car cdr))) (error (quote read) "missing closing parenthesis")))) (cons car (loop maybe-dot))))) (let-values () (letrec-values (((cdr) (read-pair open))) (cons car cdr)))))))) (loop car)))))))) ((read-vector) (lambda () (letrec-values (((loop) (lambda (elems) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p))) (if (eq? c cparen) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (list->vector (reverse elems)))) (loop (cons (read-loop) elems))))))) (loop (quote ()))))) ((read-character) (lambda () (letrec-values (((c) (read-char p)) (() (let-values () (if (eof-object? c) (error (quote read) "incomplete character literal") (void)) (values)))) (if (eq? c #\s) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\p) (let-values () (letrec-values ((() (let-values () (check-expected-string! "pace") (values)))) #\space)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))) (if (eq? c #\n) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\e) (let-values () (letrec-values ((() (let-values () (check-expected-string! "ewline") (values)))) #\newline)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))))) ((read-number) (lambda (c) (letrec-values (((chars) (quote ())) ((sign) (if (eq? c #\-) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) -1)) (if (eq? c #\+) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) 1)) 1))) ((0-char) (char->integer #\0)) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (digit? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! num (+ (* 10 num) (- (char->integer c) 0-char))) (values)))) (read-digit!))) (if (symbol-char? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (read-symbol chars))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (* num sign))))))))) (read-digit!))))) ((read-hex-number) (lambda (c) (letrec-values (((chars) (quote ())) ((sign) (if (eq? c #\-) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) -1)) (if (eq? c #\+) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) 1)) 1))) ((0-char) (char->integer #\0)) ((a-char) (char->integer #\a)) ((A-char) (char->integer #\A)) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (hex-digit? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((i) (char->integer c)) (() (let-values () (if (digit? c) (set! num (+ (* 16 num) (- i 0-char))) (if (>= i a-char) (set! num (+ (* 16 num) (+ 10 (- i a-char)))) (set! num (+ (* 16 num) (+ 10 (- i A-char)))))) (values)))) (read-digit!))) (if (symbol-char? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (read-symbol chars))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (* num sign))))))))) (read-digit!))))) ((read-string) (lambda () (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (eof-object? c) (let-values () (letrec-values ((() (let-values () (error (quote read) "non-terminated string literal") (values)))) (void))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((c) (peek-char p))) (if (eq? c #\n) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\newline acc)))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\\ acc)))) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\" acc)))) (error (quote read) "unknown escape character" c)))))) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (reverse acc))) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons c acc))))))))))) (loop (quote ()))))) ((read-symbol) (lambda (acc) (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (symbol-char? c) (loop (cons (read-char p) acc)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (string->symbol (apply string (reverse acc)))))))))) (loop acc)))) ((read-loop) (lambda () (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p))) (if (eof-object? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) c)) (if (eq? c #\#) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((c) (peek-char p))) (if (eq? c #\t) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax #t))) (if (eq? c #\f) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax #f))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-character)))) (if (eq? c #\') (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (list (quote syntax) (read-loop))))) (if (eq? c oparen) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-vector)))) (if (eq? c #\&) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (box (read-loop))))) (if (eq? c #\x) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-hex-number (peek-char p))))) (if (eq? c #\;) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values))) (() (let-values () (read-loop) (values)))) (read-loop))) (if (eq? c #\|) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-block-comment!) (values)))) (datum->syntax (read-loop)))) (error (quote read) "unknown special character" c)))))))))))) (if (digit-prefix? c) (datum->syntax (read-number c)) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((str-chars) (read-string)) (() (let-values () (assert-delimeter! (peek-char p)) (values)))) (datum->syntax (apply string str-chars)))) (if (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (eq? c obrace))))) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-pair c)))) (if (eq? c #\') (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (list (quote quote) (read-loop))))) (if (symbol-char? c) (datum->syntax (read-symbol (quote ()))) (error (quote read) "unexpected input:" c)))))))))))) (read-loop))))

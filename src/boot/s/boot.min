(define-values (member) (lambda (k xs) (letrec-values (((loop) (lambda (xs) (if (null? xs) #f (if (pair? xs) (if (equal? (car xs) k) (car xs) (loop (cdr xs))) (error (quote member) "expected a list" xs)))))) (loop xs))))
(define-values (filter) (lambda (f lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) (reverse acc) (if (pair? xs) (if (f (car xs)) (loop (cdr xs) (cons (car xs) acc)) (loop (cdr xs) acc)) (error (quote filter) "expected a list" lst)))))) (loop lst (quote ())))))
(define-values (foldl) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs acc) (if (null? xs) acc (if (pair? xs) (loop (cdr xs) (f acc (car xs))) (error (quote foldl) "expected a list" lst)))))) (loop lst acc))))
(define-values (foldr) (lambda (f acc lst) (letrec-values (((loop) (lambda (xs) (if (null? xs) acc (if (pair? xs) (f (loop (cdr xs)) (car xs)) (error (quote foldr) "expected a list" lst)))))) (loop lst))))
(define-values (assoc) (lambda (k lst) (if (null? lst) #f (if (if (pair? lst) (pair? (car lst)) #f) (if (equal? k (caar lst)) (cdar lst) (assoc k (cdr lst))) (error (quote assoc) "expected a list of pairs" lst)))))
(define-values (is-absolute-path?) (lambda (path) (if (> (string-length path) 0) (eq? (string-ref path 0) #\/) #f)))
(define-values (build-path) (lambda (base . subpaths) (letrec-values (((string-terminates-with-/?) (lambda (str) (letrec-values (((len) (string-length str))) (eq? (string-ref str (- len 1)) #\/)))) ((paths) (letrec-values (((loop) (lambda (paths accum) (if (null? paths) (reverse accum) (if (= (string-length (car paths)) 0) (loop (cdr paths) accum) (if (string-terminates-with-/? (car accum)) (loop (cdr paths) (cons (car paths) accum)) (loop (cdr paths) (cons (car paths) (cons "/" accum))))))))) (loop subpaths (list base))))) (apply string-append paths))))
(define-values (path->list) (lambda (path) (letrec-values ((() (let-values () (if (string? path) (void) (let-values () (error (quote path->list) "expected string?" path))) (values)))) (letrec-values (((loop) (lambda (path accum) (if (= (string-length path) 0) (reverse accum) (let-values () (letrec-values (((len) (string-length path))) (letrec-values (((loop2) (lambda (i) (if (= i len) (loop "" (cons path accum)) (if (eq? (string-ref path i) #\/) (if (= i 0) (loop (substring path 1 len) (cons "/" accum)) (let-values () (letrec-values (((elem) (substring path 0 i)) ((rest) (substring path (+ i 1) len))) (loop rest (cons elem accum))))) (loop2 (+ i 1))))))) (loop2 0)))))))) (loop path (quote ()))))))
(define-values (split-path) (lambda (path) (letrec-values ((() (let-values () (if (string? path) (void) (let-values () (error (quote split-path) "expected string?" path))) (values))) ((path-elems) (reverse (path->list path)))) (if (pair? (cdr path-elems)) (let-values () (letrec-values (((end) (car path-elems)) ((rest) (cdr path-elems))) (cons (apply build-path (reverse rest)) end))) (cons #f (car path-elems))))))
(define-values (substring) (lambda (str start end) (letrec-values (((len) (string-length str))) (if (not (string? str)) (error (quote substring) "expected string? for" str) (if (not (number? start)) (error (quote substring) "expected number? for" start) (if (not (number? end)) (error (quote substring) "expected number? for" end) (if (> end len) (error (quote substring) "index out of bounds" end) (if (> start end) (error (quote substring) "invalid bounds" start end) (if (= start end) "" (let-values () (letrec-values (((sstr) (make-string (- end start)))) (letrec-values (((loop) (lambda (i n) (if (= n end) sstr (let-values () (letrec-values ((() (let-values () (string-set! sstr i (string-ref str n)) (values)))) (loop (+ i 1) (+ n 1)))))))) (loop 0 start)))))))))))))
(define-values (stx-pair?) (lambda (t) (if (pair? t) #t (if (syntax? t) (pair? (syntax-e t)) #f))))
(define-values (stx-null?) (lambda (t) (if (null? t) #t (if (syntax? t) (null? (syntax-e t)) #f))))
(define-values (stx-car) (lambda (t) (if (pair? t) (car t) (car (syntax-e t)))))
(define-values (stx-cdr) (lambda (t) (if (pair? t) (cdr t) (cdr (syntax-e t)))))
(define-values (identifier?) (lambda (t) (if (syntax? t) (symbol? (syntax-e t)) #f)))
(define-values ($expander-pattern-vars) null)
(define-values ($base-stx-env) (lambda (env) (let-values (((env) (extend-environment env))) (letrec-values ((() (let-values () (environment-set-variable-value! env (quote get-pattern-variable) (lambda (k) (if (symbol? k) (letrec-values (((loop) (lambda (assoc) (if (null? assoc) #f (if (eq? (caar assoc) k) (cadar assoc) (loop (cdr assoc))))))) (loop $expander-pattern-vars)) (error (quote get-pattern-variable) "expected symbol?" k)))) (values)))) env))))
(define-values (lookup-xform) (lambda (maybe-id xforms) (if (identifier? maybe-id) (assoc (syntax-e maybe-id) xforms) #f)))
(define-values (merge-xforms) (lambda (new-xforms xforms) (letrec-values (((loop) (lambda (new-xforms xforms) (if (null? new-xforms) xforms (if (assoc (caar new-xforms) xforms) (loop (cdr new-xforms) xforms) (loop (cdr new-xforms) (cons (car new-xforms) xforms))))))) (loop new-xforms xforms))))
(define-values (expand/module) (lambda (exprs xforms env) (letrec-values (((_-form?) (lambda (form-name) (lambda (expr) (if (stx-pair? expr) (let-values (((head) (stx-car expr))) (if (identifier? head) (eq? (syntax-e head) form-name) #f)) #f)))) ((define-values-form?) (_-form? (quote define-values))) ((define-syntaxes-form?) (_-form? (quote define-syntaxes))) ((let-values-form?) (_-form? (quote let-values))) ((letrec-values-form?) (_-form? (quote letrec-values))) ((let-syntaxes-form?) (_-form? (quote let-syntaxes))) ((quote-form?) (_-form? (quote quote))) ((quote-syntax-form?) (_-form? (quote quote-syntax))) ((lambda-form?) (_-form? (quote lambda))) ((begin-form?) (_-form? (quote begin))) ((if-form?) (_-form? (quote if))) ((stx-self-evaluating?) (lambda (stx) (letrec-values (((datum) (syntax-e stx))) (let-values (((or-t) (boolean? datum))) (if or-t or-t (let-values (((or-t) (number? datum))) (if or-t or-t (let-values (((or-t) (string? datum))) (if or-t or-t (let-values (((or-t) (vector? datum))) (if or-t or-t (let-values (((or-t) (box? datum))) (if or-t or-t (char? datum)))))))))))))) ((duplicate-identifier) (lambda (ids new-ids) (letrec-values (((loop) (lambda (ids new-ids) (if (null? new-ids) #f (let-values () (letrec-values (((dup) (member (car new-ids) ids))) (let-values (((or-t) dup)) (if or-t or-t (loop (cons (car new-ids) ids) (cdr new-ids)))))))))) (loop ids new-ids)))) ((check-define-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib) (stx-cdr form))) (if (stx-null? rib) (syntax-error name "bad syntax" form) (let-values (((ids) (syntax->list (stx-car rib))) ((rib) (stx-cdr rib))) (if (if (list? ids) (andmap identifier? ids) #f) (if (stx-null? rib) (syntax-error name "expected an expression after identifiers" form) (let-values (((rib) (stx-cdr rib))) (if (stx-null? rib) (void) (syntax-error name "too many expressions" form)))) (syntax-error name "not identifiers" form ids))))))) ((check-let-syntaxes/values-form!) (lambda (name form) (letrec-values (((rib) (stx-cdr form))) (if (stx-null? rib) (syntax-error name "bad syntax" form) (let-values (((bindings) (syntax->list (stx-car rib))) ((rib) (stx-cdr rib))) (if (null? rib) (syntax-error name "missing body" form) (if (let-values (((or-t) (list? rib))) (if or-t or-t (if (syntax? rib) (list? (syntax->list rib)) #f))) (if (list? bindings) (letrec-values (((loop) (lambda (bindings) (if (null? bindings) (void) (let-values (((bind) (syntax->list (car bindings)))) (if (not (if (list? bind) (= (length bind) 2) #f)) (syntax-error name "not identifiers and expression" form bind) (let-values (((ids) (syntax->list (car bind)))) (if (if (list? ids) (andmap identifier? ids) #f) (loop (cdr bindings)) (syntax-error name "not identifiers" form ids))))))))) (loop bindings)) (syntax-error #f "expected a sequence of expressions after the bindings" form)) (syntax-error name "not a sequence of bindings" form bindings)))))))) ((check-lambda-form!) (lambda (form) (letrec-values (((rib) (stx-cdr form))) (if (stx-null? rib) (syntax-error #f "missing formals" form) (let-values (((formals) (stx-car rib)) ((rib) (stx-cdr rib))) (if (null? rib) (syntax-error #f "missing expression after formals" form) (let-values (((rib) (stx-cdr rib))) (if (let-values (((or-t) (list? rib))) (if or-t or-t (if (syntax? rib) (list? (syntax->list rib)) #f))) (void) (syntax-error #f "expected a sequence of expressions after formals" form))))))))) ((check-begin-form!) (lambda (form) (if (syntax->list form) (void) (syntax-error (quote begin) "bad syntax" form)))) ((check-1ary-form!) (lambda (name form) (letrec-values (((rib) (stx-cdr form))) (if (stx-null? rib) (syntax-error name "expected an expression" form) (let-values (((rib) (stx-cdr rib))) (if (stx-null? rib) (void) (syntax-error name "too many expressions" form))))))) ((check-if-form!) (lambda (form) (letrec-values (((rib) (stx-cdr form))) (if (stx-null? rib) (syntax-error (quote if) "bad syntax" form) (let-values (((rib) (stx-cdr rib))) (if (stx-null? rib) (syntax-error (quote if) "bad syntax" form) (let-values (((rib) (stx-cdr rib))) (if (stx-null? rib) (syntax-error (quote if) "missing an "else" statement" form) (let-values (((rib) (stx-cdr rib))) (if (stx-null? rib) (void) (syntax-error name "too many expressions" form))))))))))) ((check-duplicate-identifier!) (lambda (form name ids new-ids) (let-values (((dup) (duplicate-identifier ids new-ids))) (if dup (syntax-error name "duplicate identifier" form dup) (void))))) ((define-syntaxes/values-identifiers) (lambda (form) (map syntax-e (syntax->list (stx-car (stx-cdr form)))))) ((define-syntaxes/values-expr) (lambda (form) (stx-car (stx-cdr (stx-cdr form))))) ((eval/values) (lambda (expr env) (call-with-values (lambda () (eval expr env)) (lambda results results)))) ((eval/xform) (lambda (xform expr name) (letrec-values (((fn) (car xform))) (call-with-values (lambda () (fn expr)) (lambda results (if (not (= (length results) 1)) (error #f "result arity mismatch" "expected 1" "received" 2) (if (syntax? (car results)) (car results) (error name "transformer produced something other than syntax" (car results))))))))) ((expand/body) (lambda (exprs xforms) (if (null? exprs) (list) (letrec-values (((loop) (lambda (exprs defines) (letrec-values (((expr*) (expand/expr (car exprs) xforms))) (if (null? (cdr exprs)) (if (let-values (((or-t) (define-values-form? expr*))) (if or-t or-t (define-syntaxes-form? expr*))) (error (quote begin) "last form is not an expression" (car exprs)) (if (null? defines) (list expr*) (list (datum->syntax (list (quote-syntax letrec-values) (reverse defines) expr*))))) (if (begin-form? expr*) (loop (append (cdr (syntax->list expr*)) (cdr exprs)) defines) (if (define-syntaxes-form? expr*) (let-values () (letrec-values (((form) (syntax->list expr*)) ((ids) (cadr form)) ((value) (caddr form))) (list (expand/expr (datum->syntax (list (quote-syntax letrec-values) (reverse defines) (cons (quote-syntax let-syntaxes) (cons (list (list ids value)) (cdr exprs))))) xforms)))) (if (define-values-form? expr*) (let-values () (letrec-values (((form) (syntax->list expr*)) ((ids) (cadr form)) ((value) (caddr form))) (loop (cdr exprs) (cons (list ids value) defines)))) (let-values () (letrec-values (((value) (datum->syntax (list (quote-syntax let-values) (quote ()) expr* (list (quote-syntax values)))))) (loop (cdr exprs) (cons (list (quote ()) value) defines)))))))))))) (loop exprs (quote ())))))) ((expand/expr) (lambda (expr xforms) (letrec-values ((() (let-values () (set! $expander-pattern-vars (filter (lambda (e) (pattern-variable? (cadr e))) xforms)) (values)))) (letrec-values (((loop) (lambda (expr) (if (define-values-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-values) expr) (values)))) (let-values (((ids) (define-syntaxes/values-identifiers expr))) (letrec-values ((() (let-values () (check-duplicate-identifier! expr (quote define-values) null ids) (values)))) (let-values (((form) (syntax->list expr))) (datum->syntax (list (car form) (cadr form) (loop (caddr form))))))))) (if (let-syntaxes-form? expr) (let-values () (letrec-values ((() (let-values () (check-let-syntaxes/values-form! (quote let-syntaxes) expr) (values))) ((form) (syntax->list expr))) (letrec-values (((rec) (lambda (bindings let-ids xforms) (if (null? bindings) (expand/expr (datum->syntax (cons (quote-syntax let-values) (cons (list) (cddr form)))) xforms) (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((binding-ids) (syntax->datum (car binding))) (() (let-values () (check-duplicate-identifier! expr (quote let-syntaxes) let-ids binding-ids) (values))) ((results) (let-values (((rhs) (loop (cadr binding)))) (eval/values (syntax->datum rhs) env)))) (if (= (length binding-ids) (length results)) (letrec-values (((bind-xforms) (lambda (ids results xforms) (if (null? ids) (rec (cdr bindings) (append binding-ids let-ids) xforms) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results))) (if (let-values (((or-t) (procedure? xform))) (if or-t or-t (pattern-variable? xform))) (let-values () (letrec-values (((xform-entry) (cons id (list xform xforms)))) (bind-xforms (cdr ids) (cdr results) (cons xform-entry xforms)))) (error (quote let-syntaxes) "expected a procedure? received" xform)))))))) (bind-xforms binding-ids results xforms)) (error (quote let-syntaxes) "result arity mismatch" "expected" (length ids) "received" (length results))))))))) (rec (syntax->list (cadr form)) null xforms)))) (if (let-values (((or-t) (let-values-form? expr))) (if or-t or-t (letrec-values-form? expr))) (let-values () (letrec-values (((name) (if (let-values-form? expr) (quote let-values) (quote letrec-values))) (() (let-values () (check-let-syntaxes/values-form! name expr) (values))) ((form) (syntax->list expr)) ((body) (cddr form))) (datum->syntax (cons (car form) (cons (letrec-values (((rec) (lambda (bindings let-ids) (if (null? bindings) null (let-values () (letrec-values (((binding) (syntax->list (car bindings))) ((ids) (syntax->datum (car binding))) (() (let-values () (check-duplicate-identifier! expr name let-ids ids) (values)))) (cons (list (car binding) (loop (cadr binding))) (rec (cdr bindings) (append ids let-ids))))))))) (rec (syntax->list (cadr form)) null)) (expand/body body xforms)))))) (if (lambda-form? expr) (let-values () (letrec-values ((() (let-values () (check-lambda-form! expr) (values))) ((head) (stx-car expr)) ((formals) (stx-car (stx-cdr expr))) ((body) (stx-cdr (stx-cdr expr)))) (datum->syntax (cons head (cons formals (expand/body body xforms)))))) (if (if-form? expr) (let-values () (letrec-values ((() (let-values () (check-if-form! expr) (values))) ((form) (syntax->list expr))) (datum->syntax (list (car form) (loop (cadr form)) (loop (caddr form)) (loop (cadddr form)))))) (if (begin-form? expr) (let-values () (letrec-values ((() (let-values () (check-begin-form! expr) (values))) ((body) (stx-cdr expr))) (datum->syntax (cons (stx-car expr) (map loop (cdr (syntax->list expr))))))) (if (quote-form? expr) (let-values () (letrec-values ((() (let-values () (check-1ary-form! (quote quote) expr) (values)))) expr)) (if (quote-syntax-form? expr) (let-values () (letrec-values ((() (let-values () (check-1ary-form! (quote quote-syntax) expr) (values)))) expr)) (if (stx-pair? expr) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/expr (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms (cadr maybe-xform) xforms)) (datum->syntax (map loop (syntax->list expr)))))) (if (identifier? expr) (let-values () (letrec-values (((maybe-xform) (lookup-xform expr xforms))) (if maybe-xform (loop (eval/xform maybe-xform expr (syntax-e expr) $module-boot-expander?)) expr))) (if (stx-self-evaluating? expr) expr (syntax-error (quote expand/expr) "bad syntax" expr))))))))))))))) (loop expr))))) ((expand/module) (lambda (exprs xforms) (letrec-values (((expand/top-level) (lambda (expr xforms) (if (define-syntaxes-form? expr) (values expr xforms) (if (define-values-form? expr) (values expr xforms) (if (begin-form? expr) (values expr xforms) (if (if (stx-pair? expr) (identifier? (stx-car expr)) #f) (let-values () (letrec-values (((head) (stx-car expr)) ((maybe-xform) (lookup-xform head xforms))) (if maybe-xform (expand/top-level (eval/xform maybe-xform expr (syntax-e head)) (merge-xforms (cadr maybe-xform) xforms)) (values expr xforms)))) (values expr xforms))))))) ((expand/non-define-values) (lambda (exprs xforms) (letrec-values (((xforms) xforms) ((define-ids) null) ((xform-ids) null) ((exprs*) (letrec-values (((loop) (lambda (exprs) (if (null? exprs) null (letrec-values (((with-scope) (lambda (exprs in-scope) (letrec-values (((expr in-scope) (expand/top-level (car exprs) in-scope))) (if (define-syntaxes-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-syntaxes) expr) (values))) ((ids rhs) (let-values (((ids) (define-syntaxes/values-identifiers expr))) (letrec-values ((() (let-values () (check-duplicate-identifier! expr (quote define-syntaxes) xform-ids ids) (values)))) (values ids (define-syntaxes/values-expr expr))))) ((results) (let-values (((rhs*) (expand/expr rhs in-scope))) (eval/values (syntax->datum rhs*) env)))) (if (= (length ids) (length results)) (letrec-values (((rec) (lambda (ids results) (if (null? ids) (loop (cdr exprs)) (let-values () (letrec-values (((id) (car ids)) ((xform) (car results))) (if (procedure? xform) (let-values () (letrec-values (((binding) (cons id (list xform null))) (() (let-values () (set! xform-ids (cons id xform-ids)) (values))) (() (let-values () (set! xforms (let-values (((xforms-in-scope) (cons binding xforms))) (letrec-values (((loop) (lambda (xforms) (if (null? xforms) null (cons (if (member (caar xforms) xform-ids) (cons (caar xforms) (list (cadar xforms) xforms-in-scope)) (car xforms)) (loop (cdr xforms))))))) (loop xforms-in-scope)))) (values)))) (rec (cdr ids) (cdr results)))) (error (quote define-syntaxes) "expected a procedure? received" xform)))))))) (rec ids results)) (error (quote define-syntaxes) "result arity mismatch" "expected" (length ids) "received" (length results))))) (if (define-values-form? expr) (let-values () (letrec-values ((() (let-values () (check-define-syntaxes/values-form! (quote define-values) expr) (values))) ((ids) (define-syntaxes/values-identifiers expr)) (() (let-values () (check-duplicate-identifier! expr (quote define-values) define-ids ids) (values))) (() (let-values () (set! define-ids (append ids define-ids)) (values)))) (cons expr (loop (cdr exprs))))) (if (begin-form? expr) (let-values () (letrec-values ((() (let-values () (check-begin-form! expr) (values))) ((forms) (cdr (syntax->list expr)))) (if (null? forms) (loop (cdr exprs)) (append (with-scope forms in-scope) (loop (cdr exprs)))))) (cons (expand/expr expr in-scope) (loop (cdr exprs)))))))))) (with-scope exprs xforms)))))) (loop exprs)))) (values exprs* xforms)))) ((expand/define-values) (lambda (exprs xforms) (letrec-values (((loop) (lambda (exprs exprs*) (if (null? exprs) (reverse exprs*) (if (define-values-form? (car exprs)) (let-values () (letrec-values (((form) (syntax->list (car exprs)))) (loop (cdr exprs) (cons (datum->syntax (list (car form) (cadr form) (expand/expr (caddr form) xforms))) exprs*)))) (loop (cdr exprs) (cons (car exprs) exprs*))))))) (loop exprs null)))) ((exprs* xforms*) (expand/non-define-values exprs xforms)) ((exprs**) (expand/define-values exprs* xforms*))) (values exprs** xforms*))))) (expand/module exprs xforms))))
(define-values (expand) (lambda (expr xforms env) (letrec-values (((exprs* xforms*) (expand/module (list expr) xforms env))) (if (null? exprs*) (values (quote-syntax (void)) xforms*) (values (car exprs*) xforms*)))))
(define-values ($base-env) (environment))
(define-values ($module-table) (quote ()))
(define-values ($module-envs) (quote ()))
(define-values ($module-internals) (quote ()))
(define-values (writeln) (lambda (o) (lambda args (let-values (((l) (length args))) (if (= l (length (quote (o)))) (apply (lambda (o) (writeln o (current-output-port))) args) (if (= l (length (quote (o p)))) (apply (lambda (o p) (letrec-values ((() (let-values () (write o p) (values)))) (newline p))) args) (error "arity mismatch: given ~a" l)))))))
(define-values ($load-module) (lambda (path print-handler result-handler) (letrec-values (((new-cwd) (car (split-path path))) ((exported) (quote ())) ((imported) (quote ())) ((imported-xforms) (quote ())) ((imported-modules) (quote ())) ((stx-env) #f) ((module-xforms) (quote ())) (($read) (lambda () (letrec-values (((p) (open-input-file path))) (letrec-values (((loop) (lambda (exprs) (letrec-values (((datum) (read p))) (if (eof-object? datum) (let-values () (letrec-values ((() (let-values () (close-input-port p) (values)))) (reverse exprs))) (loop (cons datum exprs))))))) (loop (quote ())))))) (($import) (lambda (exprs) (letrec-values (((loop) (lambda (exprs evalable) (if (null? exprs) (reverse evalable) (let-values () (letrec-values (((expr) (syntax-e (car exprs)))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote import)) #f) (letrec-values (((loop2) (lambda (imports) (if (null? imports) (loop (cdr exprs) evalable) (if (pair? imports) (let-values () (letrec-values (((maybe-import) (syntax-e (car imports)))) (if (string? maybe-import) (let-values () (letrec-values (((path) (build-path new-cwd maybe-import)) (() (let-values () ($load-or-import path print-handler result-handler) (values))) ((from-module) (assoc path $module-table)) (() (let-values () (set! imported-modules (cons path imported-modules)) (values))) (() (let-values () (set! imported-xforms (merge-xforms (car from-module) imported-xforms)) (values))) (() (let-values () (set! imported (append (cdr from-module) imported)) (values)))) (loop2 (cdr imports)))) (error (quote import) "bad import syntax")))) (error (quote import) "bad import syntax")))))) (loop2 (cdr expr))) (if (if (pair? expr) (eq? (syntax-e (car expr)) (quote export)) #f) (letrec-values (((loop2) (lambda (exports) (if (null? exports) (loop (cdr exprs) evalable) (if (pair? exports) (let-values () (letrec-values (((maybe-export) (syntax-e (car exports)))) (if (symbol? maybe-export) (let-values () (letrec-values ((() (let-values () (set! exported (cons maybe-export exported)) (values)))) (loop2 (cdr exports)))) (if (pair? maybe-export) (if (eq? (syntax-e (car maybe-export)) (quote all)) (let-values () (letrec-values (((module-name) (syntax-e (cadr maybe-export))) ((path) (build-path new-cwd module-name))) (if (if (string? module-name) (if (null? (cddr maybe-export)) (member path imported-modules) #f) #f) (let-values () (letrec-values (((from-module) (assoc path $module-table)) (() (let-values () (set! exported (append (map car (car from-module)) (map car (cdr from-module)) exported)) (values)))) (loop2 (cdr exports)))) (error (quote export) "bad export syntax")))) (error (quote export) "bad export syntax")) (error (quote export) "bad export syntax"))))) (error (quote export) "bad export syntax")))))) (loop2 (cdr expr))) (loop (cdr exprs) (cons (car exprs) evalable)))))))))) (loop exprs (quote ()))))) (($expand) (lambda (exprs) (letrec-values ((() (let-values () (set! stx-env ($base-stx-env ($eval-environment $base-env imported))) (values))) ((exprs* xforms*) (expand/module exprs imported-xforms stx-env)) (() (let-values () (set! module-xforms xforms*) (values)))) exprs*))) ((raw-exprs) ($read)) ((non-import-exprs) ($import raw-exprs)) ((expanded-exprs) ($expand non-import-exprs))) (values expanded-exprs module-xforms imported exported stx-env))))
(define-values ($eval-environment) (lambda (env imports) (letrec-values (((env*) (extend-environment env))) (letrec-values (((loop) (lambda (imports) (if (null? imports) env* (let-values () (letrec-values (((name) (caar imports)) ((value) (cdar imports)) (() (let-values () (environment-set-variable-value! env* name value) (values)))) (loop (cdr imports)))))))) (loop imports)))))
(define-values ($eval-exprs) (lambda (exprs env print-handler) (letrec-values (((loop) (lambda (exprs result) (if (null? exprs) result (let-values () (letrec-values (((expr) (syntax->datum (car exprs)))) (call-with-values (lambda () (eval expr env)) (lambda results (letrec-values (((loop2) (lambda (results prev) (if (null? results) (loop (cdr exprs) prev) (let-values () (letrec-values ((() (let-values () (if (not (void? (car results))) (writeln (car results)) (void)) (values)))) (loop2 (cdr results) (car results)))))))) (loop2 results (void))))))))))) (loop exprs (void)))))
(define-values ($load-or-import-no-check) (lambda (path print-handler result-handler) (letrec-values (((exprs module-xforms imports exports stx-env) ($load-module path print-handler result-handler)) ((env) ($eval-environment $base-env imports)) ((last) ($eval-exprs exprs env print-handler)) ((export-values) (quote ())) ((export-xforms) (quote ())) (() (let-values () (letrec-values (((loop) (lambda (exports) (if (null? exports) (void) (let-values () (letrec-values (((export) (car exports)) ((maybe-xform) (assoc export module-xforms)) (() (let-values () (if maybe-xform (set! export-xforms (cons (cons export maybe-xform) export-xforms)) (let-values () (letrec-values (((value) (environment-variable-value env export (lambda () (error (quote export) "undefined export" export))))) (set! export-values (cons (cons export value) export-values))))) (values)))) (loop (cdr exports)))))))) (loop exports)) (values))) (() (let-values () (set! $module-table (cons (cons path (cons export-xforms export-values)) $module-table)) (values))) (() (let-values () (set! $module-envs (cons (cons path (cons module-xforms (cons stx-env env))) $module-envs)) (values))) (() (let-values () (set! $module-internals (cons (cons path (list exprs module-xforms imports exports stx-env)) $module-internals)) (values)))) (if result-handler (result-handler last) (void)))))
(define-values ($repl) (lambda (xforms stx-env env) (letrec-values (((loop) (lambda (xforms) (letrec-values ((() (let-values () (display "> ") (values))) ((expr) (read)) (() (let-values () (if (eof-object? expr) (exit) (void)) (values)))) (let-values (((expr* xforms*) (expand expr xforms stx-env))) (letrec-values ((() (let-values () (call-with-values (lambda () (eval expr env)) (lambda results (letrec-values (((loop) (lambda (results) (if (null? results) (void) (if (void? (car results)) (loop (cdr results)) (let-values () (letrec-values ((() (let-values () (writeln (car results)) (values)))) (loop (cdr results))))))))) (loop results)))) (values)))) (loop xforms*))))))) (loop xforms))))
(define-values ($load-or-import) (lambda (name print-handler result-handler) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) (if (not (assoc path $module-table)) ($load-or-import-no-check path print-handler result-handler) (void)))))
(define-values (read/module) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name)))) ($load-module path #f #f))))
(define-values (load) (lambda (name) (letrec-values (((result) ($load-or-import name #f (lambda (o) o))) (() (let-values () (if (not (void? result)) (writeln result) (void)) (values)))) (enter! name))))
(define-values (import) (lambda (name) ($load-or-import name (lambda (o) (writeln o)) #f)))
(define-values (enter!) (lambda (name) (letrec-values (((path) (if (is-absolute-path? name) name (build-path (current-directory) name))) ((maybe-env) (assoc path $module-envs)) (() (let-values () (if (not maybe-env) (error (quote enter!) "unknown module" name) (void)) (values)))) ($repl (car maybe-env) (extend-environment (cadr maybe-env)) (extend-environment (cddr maybe-env))))))
(define-values (read) (lambda args (letrec-values (((p) (if (null? args) (current-input-port) (if (null? (cdr args)) (car args) (error (quote read) "arity mismatch\n expected 0 or 1 arguments," "received" (length args))))) (() (let-values () (if (not (input-port? p)) (error (quote read) "expected an input port, received " p) (void)) (values))) ((oparen) (integer->char 40)) ((cparen) (integer->char 41)) ((obrack) (integer->char 91)) ((cbrack) (integer->char 93)) ((obrace) (integer->char 123)) ((cbrace) (integer->char 125)) ((space?) (lambda (c) (let-values (((or-t) (eq? c #\space))) (if or-t or-t (eq? c #\newline))))) ((delimeter?) (lambda (c) (let-values (((or-t) (eof-object? c))) (if or-t or-t (let-values (((or-t) (space? c))) (if or-t or-t (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (let-values (((or-t) (eq? c obrace))) (if or-t or-t (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (let-values (((or-t) (eq? c cbrace))) (if or-t or-t (let-values (((or-t) (eq? c #\"))) (if or-t or-t (eq? c #\;))))))))))))))))))))) ((symbol-char?) (lambda (c) (not (delimeter? c)))) ((digit?) (lambda (c) (letrec-values (((0-char) (char->integer #\0)) ((9-char) (char->integer #\9)) ((i) (char->integer c))) (<= 0-char i 9-char)))) ((hex-digit?) (lambda (c) (letrec-values (((i) (char->integer c))) (let-values (((or-t) (<= (char->integer #\0) i (char->integer #\9)))) (if or-t or-t (let-values (((or-t) (<= (char->integer #\a) i (char->integer #\f)))) (if or-t or-t (<= (char->integer #\A) i (char->integer #\F))))))))) ((digit-prefix?) (lambda (c) (let-values (((or-t) (digit? c))) (if or-t or-t (if (let-values (((or-t) (eq? c #\-))) (if or-t or-t (eq? c #\+))) (digit? (peek-char p)) #f))))) ((assert-not-eof!) (lambda (c) (if (eof-object? c) (error (quote read) "unexpected end of input") (void)))) ((assert-matching-parens!) (lambda (open close) (if (let-values (((or-t) (if (eq? open oparen) (eq? close cparen) #f))) (if or-t or-t (let-values (((or-t) (if (eq? open obrack) (eq? close cbrack) #f))) (if or-t or-t (if (eq? open obrace) (eq? close cbrace) #f))))) (void) (error (quote read) "parenthesis mismatch " open " " close)))) ((assert-delimeter!) (lambda (c) (if (not (delimeter? c)) (error (quote read) "expected a delimeter") (void)))) ((skip-comment!) (lambda () (letrec-values (((c) (peek-char p))) (if (eof-object? c) (void) (if (eq? c #\newline) (void) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (skip-comment!)))))))) ((skip-block-comment!) (lambda () (letrec-values (((loop) (lambda (block-level) (if (= block-level 0) (void) (let-values () (letrec-values (((c) (read-char p))) (if (eq? c #\#) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\|) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (+ block-level 1)))) (loop block-level)))) (if (eq? c #\|) (let-values () (letrec-values (((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\#) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (- block-level 1)))) (loop block-level)))) (loop block-level))))))))) (loop 1)))) ((skip-until-token!) (lambda () (letrec-values (((c) (peek-char p))) (if (space? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (skip-until-token!))) (if (eq? c #\;) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-comment!) (values)))) (skip-until-token!))) (void)))))) ((check-expected-string!) (lambda (s) (letrec-values (((len) (string-length s))) (letrec-values (((loop) (lambda (i) (if (< i len) (let-values () (letrec-values (((c) (read-char p))) (if (eof-object? c) (error (quote read) "unexpected end of input") (if (eq? c (string-ref s i)) (loop (+ i 1)) (error (quote read) "unexpected character" c))))) (void))))) (loop 0))))) ((read-pair) (lambda (open) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (letrec-values ((() (let-values () (assert-matching-parens! open c) (values))) (() (let-values () (read-char p) (values)))) (quote ()))) (let-values () (letrec-values (((car) (read-loop))) (letrec-values (((loop) (lambda (car) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (eq? c #\.) (let-values () (letrec-values (((maybe-dot) (read-loop))) (if (eq? (syntax-e maybe-dot) (quote .)) (let-values () (letrec-values (((cdr) (read-loop)) (() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values)))) (if (let-values (((or-t) (eq? c cparen))) (if or-t or-t (let-values (((or-t) (eq? c cbrack))) (if or-t or-t (eq? c cbrace))))) (let-values () (letrec-values ((() (let-values () (assert-matching-parens! open c) (values))) (() (let-values () (read-char p) (values)))) (cons car cdr))) (error (quote read) "missing closing parenthesis")))) (cons car (loop maybe-dot))))) (let-values () (letrec-values (((cdr) (read-pair open))) (cons car cdr)))))))) (loop car)))))))) ((read-vector) (lambda () (letrec-values (((loop) (lambda (elems) (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p))) (if (eq? c cparen) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (list->vector (reverse elems)))) (loop (cons (read-loop) elems))))))) (loop (quote ()))))) ((read-character) (lambda () (letrec-values (((c) (read-char p)) (() (let-values () (if (eof-object? c) (error (quote read) "incomplete character literal") (void)) (values)))) (if (eq? c #\s) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\p) (let-values () (letrec-values ((() (let-values () (check-expected-string! "pace") (values)))) #\space)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))) (if (eq? c #\n) (let-values () (letrec-values (((cn) (peek-char p))) (if (eq? cn #\e) (let-values () (letrec-values ((() (let-values () (check-expected-string! "ewline") (values)))) #\newline)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) c))))))) ((read-number) (lambda (c) (letrec-values (((chars) (quote ())) ((sign) (if (eq? c #\-) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) -1)) (if (eq? c #\+) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) 1)) 1))) ((0-char) (char->integer #\0)) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (digit? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! num (+ (* 10 num) (- (char->integer c) 0-char))) (values)))) (read-digit!))) (if (symbol-char? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (read-symbol chars))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (* num sign))))))))) (read-digit!))))) ((read-hex-number) (lambda (c) (letrec-values (((chars) (quote ())) ((sign) (if (eq? c #\-) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) -1)) (if (eq? c #\+) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (set! chars (cons c chars)) (values)))) 1)) 1))) ((0-char) (char->integer #\0)) ((a-char) (char->integer #\a)) ((A-char) (char->integer #\A)) ((num) 0)) (letrec-values (((read-digit!) (lambda () (letrec-values (((c) (peek-char p)) (() (let-values () (set! chars (cons c chars)) (values)))) (if (hex-digit? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((i) (char->integer c)) (() (let-values () (if (digit? c) (set! num (+ (* 16 num) (- i 0-char))) (if (>= i a-char) (set! num (+ (* 16 num) (+ 10 (- i a-char)))) (set! num (+ (* 16 num) (+ 10 (- i A-char)))))) (values)))) (read-digit!))) (if (symbol-char? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (read-symbol chars))) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (* num sign))))))))) (read-digit!))))) ((read-string) (lambda () (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (eof-object? c) (let-values () (letrec-values ((() (let-values () (error (quote read) "non-terminated string literal") (values)))) (void))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((c) (peek-char p))) (if (eq? c #\n) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\newline acc)))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\\ acc)))) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons #\" acc)))) (error (quote read) "unknown escape character" c)))))) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (reverse acc))) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (loop (cons c acc))))))))))) (loop (quote ()))))) ((read-symbol) (lambda (acc) (letrec-values (((loop) (lambda (acc) (letrec-values (((c) (peek-char p))) (if (symbol-char? c) (loop (cons (read-char p) acc)) (let-values () (letrec-values ((() (let-values () (assert-delimeter! (peek-char p)) (values)))) (string->symbol (apply string (reverse acc)))))))))) (loop acc)))) ((read-loop) (lambda () (letrec-values ((() (let-values () (skip-until-token!) (values))) ((c) (peek-char p))) (if (eof-object? c) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) c)) (if (eq? c #\#) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((c) (peek-char p))) (if (eq? c #\t) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax #t))) (if (eq? c #\f) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax #f))) (if (eq? c #\\) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-character)))) (if (eq? c #\') (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (list (quote syntax) (read-loop))))) (if (eq? c oparen) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-vector)))) (if (eq? c #\&) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (box (read-loop))))) (if (eq? c #\x) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-hex-number (peek-char p))))) (if (eq? c #\;) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-until-token!) (values))) ((c) (peek-char p)) (() (let-values () (assert-not-eof! c) (values))) (() (let-values () (read-loop) (values)))) (read-loop))) (if (eq? c #\|) (let-values () (letrec-values ((() (let-values () (read-char p) (values))) (() (let-values () (skip-block-comment!) (values)))) (datum->syntax (read-loop)))) (error (quote read) "unknown special character" c)))))))))))) (if (digit-prefix? c) (datum->syntax (read-number c)) (if (eq? c #\") (let-values () (letrec-values ((() (let-values () (read-char p) (values))) ((str-chars) (read-string)) (() (let-values () (assert-delimeter! (peek-char p)) (values)))) (datum->syntax (apply string str-chars)))) (if (let-values (((or-t) (eq? c oparen))) (if or-t or-t (let-values (((or-t) (eq? c obrack))) (if or-t or-t (eq? c obrace))))) (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (read-pair c)))) (if (eq? c #\') (let-values () (letrec-values ((() (let-values () (read-char p) (values)))) (datum->syntax (list (quote quote) (read-loop))))) (if (symbol-char? c) (datum->syntax (read-symbol (quote ()))) (error (quote read) "unexpected input:" c)))))))))))) (read-loop))))

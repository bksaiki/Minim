;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Some bare essentials to load
;;;   Minature standard library
;;;

;; type predicates

(define number? integer?)

;; lists

(define (list? xs)
  (cond [(null? xs) #t]
        [(pair? xs) (list? (cdr xs))]
        [else #f]))

(define (caar xs) (car (car xs)))
(define (cdar xs) (cdr (car xs)))
(define (cadr xs) (car (cdr xs)))
(define (cddr xs) (cdr (cdr xs)))

(define (caaar xs) (car (car (car xs))))
(define (cadar xs) (car (cdr (car xs))))
(define (caadr xs) (car (car (cdr xs))))
(define (caddr xs) (car (cdr (cdr xs))))
(define (cdaar xs) (cdr (car (car xs))))
(define (cddar xs) (cdr (cdr (car xs))))
(define (cdadr xs) (cdr (car (cdr xs))))
(define (cdddr xs) (cdr (cdr (cdr xs))))

(define (caaaar xs) (car (car (car (car xs)))))
(define (caadar xs) (car (car (cdr (car xs)))))
(define (caaadr xs) (car (car (car (cdr xs)))))
(define (caaddr xs) (car (car (cdr (cdr xs)))))
(define (cadaar xs) (car (cdr (car (car xs)))))
(define (caddar xs) (car (cdr (cdr (car xs)))))
(define (cadadr xs) (car (cdr (car (cdr xs)))))
(define (cadddr xs) (car (cdr (cdr (cdr xs)))))
(define (cdaaar xs) (cdr (car (car (car xs)))))
(define (cdadar xs) (cdr (car (cdr (car xs)))))
(define (cdaadr xs) (cdr (car (car (cdr xs)))))
(define (cdaddr xs) (cdr (car (cdr (cdr xs)))))
(define (cddaar xs) (cdr (cdr (car (car xs)))))
(define (cdddar xs) (cdr (cdr (cdr (car xs)))))
(define (cddadr xs) (cdr (cdr (car (cdr xs)))))
(define (cddddr xs) (cdr (cdr (cdr (cdr xs)))))

(define (length lst)
  (let loop ([xs lst] [acc 0])
    (cond [(null? xs) acc]
          [(pair? xs) (loop (cdr xs) (+ acc 1))]
          [else       (error 'length "expected a list" lst)])))

(define (reverse lst)
  (let loop ([xs lst] [acc '()])
        (cond [(null? xs) acc]
              [(pair? xs) (loop (cdr xs) (cons (car xs) acc))]
              [else       (error 'reverse "expected a list" lst)])))

(define (append . lsts)
  (let loop ([lsts lsts])
    (if (null? lsts)
        '()
        (let loop2 ([lst (car lsts)])
          (if (null? lst)
              (loop (cdr lsts))
              (cons (car lst) (loop2 (cdr lst))))))))

(define (map f lst)
  (let loop ([xs lst] [acc '()])
    (cond [(null? xs) (reverse acc)]
          [(pair? xs) (loop (cdr xs) (cons (f (car xs)) acc))]
          [else       (error 'map "expected a list" lst)])))

(define (foldl f acc lst)
  (let loop ([xs lst] [acc acc])
    (cond [(null? xs) acc]
          [(pair? xs) (loop (cdr xs) (f acc (car xs)))]
          [else       (error 'foldl "expected a list" lst)])))

(define (foldr f acc lst)
  (let loop ([xs lst])
    (cond [(null? xs) acc]
          [(pair? xs) (f (loop (cdr xs)) (car xs))]
          [else       (error 'foldr "expected a list" lst)])))

;; strings

(define (string-append . strs)
  (define len (apply + (map string-length strs)))
  (define s (make-string len))
  (let loop ([strs strs] [i 0])
    (cond
      [(null? strs) s]
      [else
       (define str (car strs))
       (define len (string-length str))
       (let loop2 ([i i] [n 0])
         (cond
           [(= n len) (loop (cdr strs) i)]
           [else
            (string-set! s i (string-ref str n))
            (loop2 (+ i 1) (+ n 1))]))])))
 
(define (is-absolute-path? path)
  (and (> (string-length path) 0)
       (eq? (string-ref path 0) "/")))

;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Some bare essentials to load
;;;   Minature standard library
;;;

;; type predicates

(define number? integer?)

;; lists

(define (caar xs) (car (car xs)))
(define (cdar xs) (cdr (car xs)))
(define (cadr xs) (car (cdr xs)))
(define (cddr xs) (cdr (cdr xs)))

(define (caaar xs) (car (car (car xs))))
(define (cadar xs) (car (cdr (car xs))))
(define (caadr xs) (car (car (cdr xs))))
(define (caddr xs) (car (cdr (cdr xs))))
(define (cdaar xs) (cdr (car (car xs))))
(define (cddar xs) (cdr (cdr (car xs))))
(define (cdadr xs) (cdr (car (cdr xs))))
(define (cdddr xs) (cdr (cdr (cdr xs))))

(define (caaaar xs) (car (car (car (car xs)))))
(define (caadar xs) (car (car (cdr (car xs)))))
(define (caaadr xs) (car (car (car (cdr xs)))))
(define (caaddr xs) (car (car (cdr (cdr xs)))))
(define (cadaar xs) (car (cdr (car (car xs)))))
(define (caddar xs) (car (cdr (cdr (car xs)))))
(define (cadadr xs) (car (cdr (car (cdr xs)))))
(define (cadddr xs) (car (cdr (cdr (cdr xs)))))
(define (cdaaar xs) (cdr (car (car (car xs)))))
(define (cdadar xs) (cdr (car (cdr (car xs)))))
(define (cdaadr xs) (cdr (car (car (cdr xs)))))
(define (cdaddr xs) (cdr (car (cdr (cdr xs)))))
(define (cddaar xs) (cdr (cdr (car (car xs)))))
(define (cdddar xs) (cdr (cdr (cdr (car xs)))))
(define (cddadr xs) (cdr (cdr (car (cdr xs)))))
(define (cddddr xs) (cdr (cdr (cdr (cdr xs)))))

(define (length lst)
  (let loop ([xs lst] [acc 0])
    (cond [(null? xs) acc]
          [(pair? xs) (loop (cdr xs) (+ acc 1))]
          [else       (error 'length "expected a list" lst)])))

(define (reverse lst)
  (let loop ([xs lst] [acc '()])
        (cond [(null? xs) acc]
              [(pair? xs) (loop (cdr xs) (cons (car xs) acc))]
              [else       (error 'reverse "expected a list" lst)])))

(define (append . lsts)
  (let loop ([lsts lsts])
    (cond
      [(null? lsts) '()]
      [(null? (cdr lsts)) (car lsts)]
      [else
       (let loop2 ([lst (car lsts)])
         (if (null? lst)
             (loop (cdr lsts))
             (cons (car lst) (loop2 (cdr lst)))))])))

(define (map f lst)
  (let loop ([xs lst] [acc '()])
    (cond [(null? xs) (reverse acc)]
          [(pair? xs) (loop (cdr xs) (cons (f (car xs)) acc))]
          [else       (error 'map "expected a list" lst)])))

(define (foldl f acc lst)
  (let loop ([xs lst] [acc acc])
    (cond [(null? xs) acc]
          [(pair? xs) (loop (cdr xs) (f acc (car xs)))]
          [else       (error 'foldl "expected a list" lst)])))

(define (foldr f acc lst)
  (let loop ([xs lst])
    (cond [(null? xs) acc]
          [(pair? xs) (f (loop (cdr xs)) (car xs))]
          [else       (error 'foldr "expected a list" lst)])))

(define (assoc k lst)
  (cond
    [(null? lst) #f]
    [(and (pair? lst) (pair? (car lst)))
     (if (equal? k (caar lst))
         (cdar lst)
         (assoc k (cdr lst)))]
    [else (error 'assoc "expected a list of pairs" lst)]))

;; strings

(define (string-empty? str)
  (if (string? str)
      (= (string-length str) 0)
      (error 'string "expected string?" str)))

(define (string-append . strs)
  (define len (apply + (map string-length strs)))
  (define s (make-string len))
  (let loop ([strs strs] [i 0])
    (cond
      [(null? strs) s]
      [else
       (define str (car strs))
       (define len (string-length str))
       (let loop2 ([i i] [n 0])
         (cond
           [(= n len) (loop (cdr strs) i)]
           [else
            (string-set! s i (string-ref str n))
            (loop2 (+ i 1) (+ n 1))]))])))
 
(define (substring str start end)
  (define len (string-length str))
  (cond
    [(not (string? str)) (error 'substring "expected string? for" str)]
    [(not (number? start)) (error 'substring "expected number? for" start)]
    [(not (number? end)) (error 'substring "expected number? for" end)]
    [(> end len) (error 'substring "index out of bounds" end)]
    [(> start end) (error 'substring "invalid bounds" start end)]
    [(= start end) ""]
    [else
     (define sstr (make-string (- end start)))
     (let loop ([i 0] [n start])
       (cond
         [(= n end) sstr]
         [else
          (string-set! sstr i (string-ref str n))
          (loop (+ i 1) (+ n 1))]))]))

;; paths

(define (is-absolute-path? path)
  (and (> (string-length path) 0)
       (eq? (string-ref path 0) #\/)))

;; paths are unverified
(define (build-path base . subpaths)
  (define (string-terminates-with-/? str)
    (define len (string-length str))
    (eq? (string-ref str (- len 1)) #\/))
  (define paths
    (let loop ([paths subpaths] [accum (list base)])
      (cond
        [(null? paths) (reverse accum)]
        [(string-empty? (car paths)) (loop (cdr paths) accum)]
        [(string-terminates-with-/? (car accum)) (loop (cdr paths) (cons (car paths) accum))]
        [else (loop (cdr paths) (cons (car paths) (cons "/" accum)))])))
  (apply string-append paths))

(define (path->list path)
  (if (string? path)
      (void)
      (error 'path->list "expected string?" path))
  (let loop ([path path] [accum '()])
    (cond
      [(string-empty? path)
       (reverse accum)]
      [else
       (define len (string-length path))
       (let loop2 ([i 0])
         (cond
           [(= i len)
            (loop "" (cons path accum))]
           [(eq? (string-ref path i) #\/)
            (cond
              [(= i 0)
               ; corner case for unix paths
               (loop (substring path 1 len) (cons "/" accum))]
              [else
               (define elem (substring path 0 i))
               (define rest (substring path (+ i 1) len))
               (loop rest (cons elem accum))])]
           [else
            (loop2 (+ i 1))]))])))

(define (split-path path)
  (if (string? path)
      (void)
      (error 'split-path "expected string?" path))
  (define path-elems (reverse (path->list path)))
  (cond
    [(pair? (cdr path-elems))
     (define end (car path-elems))
     (define rest (cdr path-elems))
     (cons (apply build-path (reverse rest)) end)]
    [else
     (cons #f (car path-elems))]))

;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Expander for syntax macros
;;;   

(define xforms '())

(define (expand expr xforms)
  ;; looks up a transform returning #f if none is found
  (define (lookup-or-false key)
    (let loop ([xforms xforms])
      (cond [(null? xforms) #f]
            [(eq? (caar xforms) key) (cdar xforms)]
            [else (loop (cdr xforms))])))

  ;; expression-level expander
  (define (expand-expr expr)
    (cond
      [(pair? expr)
       (define first (car expr))
       (define maybe-args (cdr expr))
       (cond
         [(symbol? first)
          (define maybe-xform (lookup-or-false first))
          (if maybe-xform
              (expand-expr (apply maybe-xform maybe-args))
              (cons first (map expand-expr maybe-args)))]
         [else
          (map expand-expr expr)])]
      [else
       expr]))

  (define (panic!) (error "bad define-syntax form"))

  ;; top-level expander
  (define (expand-top expr)
    (cond
      [(pair? expr)
       (define first (car expr))
       (cond
         [(eq? first 'define-syntax)
          (define rib (cdr expr))
          (cond
            [(and (pair? rib) (symbol? (car rib)))
             (define xform-name (car rib))
             (define rib (cdr rib))
             (cond
               [(and (pair? rib) (null? (cdr rib)))
                (define xform (eval (expand-expr (car rib))))
                (set! xforms (cons (cons xform-name xform) xforms))
                '(void)]
               [else
                (panic!)])]
            [else
             (panic!)])]
         [else expr])]
      [else
       expr]))

  (cons (expand-top expr) xforms))

(define (syntax->datum stx)
  (define e (syntax-e stx))
  (if (pair? e)
      (cons (syntax->datum (car e))
            (syntax->datum (cdr e)))
      e))

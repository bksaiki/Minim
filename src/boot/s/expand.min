;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Expander for syntax macros
;;;   

;; Should the expander use the boot expander for evaluation?
(define $expander-boot-expander? #f)

(define (expand expr xforms)
  ;; looks up a transform returning #f if none is found
  (define (lookup-or-false key)
    (let loop ([xforms xforms])
      (cond [(null? xforms) #f]
            [(eq? (caar xforms) key) (cdar xforms)]
            [else (loop (cdr xforms))])))

  ;; expression-level expander
  (define (expand-expr expr)
    (define expr* (syntax-e expr))
    (cond
      [(null? expr*)
        expr]
      [(list? expr*)
       (define first (syntax-e (car expr*)))
       (cond
         [(symbol? first)
          (define maybe-xform (lookup-or-false first))
          (define maybe-args (cdr expr*))
          (datum->syntax
            (cond
              [maybe-xform
               (define old-expander? (boot-expander?))
               (define expanded
                 (call-with-values
                   (lambda ()
                     (boot-expander? $expander-boot-expander?)
                     (maybe-xform expr))
                   (lambda results
                     (boot-expander? old-expander?)
                     (if (and (= (length results) 1) (syntax? (car results)))
                         (car results)
                         (error "transformer produced something other than syntax" (car results))))))
               (expand-expr expanded)]
              [else
               (cons (datum->syntax first) (map expand-expr maybe-args))]))]
         [else
          (datum->syntax (map expand-expr expr*))])]
      [(pair? expr*)
       (datum->syntax (cons (expand-expr (car expr*)) (expand-expr (cdr expr*))))]
      [(symbol? expr*)
       (define maybe-xform (lookup-or-false expr*))
       (datum->syntax
         (if maybe-xform
             (expand-expr (maybe-xform expr))
             expr))]
      [else
       expr]))

  (expand-expr expr))

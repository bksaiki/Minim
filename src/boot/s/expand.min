;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Expander for syntax macros
;;;   
;;; 

(define expander-env
  (lambda ()
    (define stmts
      '(begin

        ;; transformer generated as described in 
        ;; the appendix of the R4RS standard
        (define syntax-rules
          (lambda exprs
            (cond
              [(not (null? (car exprs)))
               (error "syntax-rules: expected a list of literals")]
              [else
               (lambda (stx)
                 (define literals (car exprs))
                 (define rules (cdr exprs))

                 (define literal?
                   (lambda (stx)
                     (define loop
                       (lambda (ls)
                         (cond 
                           [(null? ls) #f]
                           [(eq? (car ls) stx) #t]
                           [else (loop (cdr ls))])))
                     (loop literals)))

                 (define loop
                   (lambda (rules)
                     (cond
                       [(null? rules) (error "transformer: bad syntax")]
                       [else
                        (define rule (car rules))
                        (define pattern (car rule))
                        (define template (car (cdr rule)))
                        (cond
                          [(and (pair? rule) (pair? stx))
                           (define bindings '())

                           (define lookup
                             (lambda (key)
                               (define loop
                                 (lambda (bindings)
                                   (cond
                                     [(null? bindings)
                                      key]
                                     [(eq? (car (car bindings)) key)
                                      (cdr (car bindings))]
                                     [else
                                      (loop (cdr bindings))])))
                                (loop bindings)))
                            
                           (define match
                             (lambda (rule stx)
                               (write rule) (write-char #\space)
                               (write stx) (write-char #\space)
                               (write bindings) (write-char #\newline)
                               (cond
                                 [(and (null? rule) (null? stx))
                                  #t]
                                 [(and (pair? rule) (pair? stx))
                                  (if (match (car rule) (car stx))
                                      (match (cdr rule) (cdr stx))
                                      #f)]
                                 [(literal? rule)
                                  #t]
                                 [(symbol? rule)
                                  (set! bindings (cons (cons rule stx) bindings))
                                  #t]
                                 [else
                                  #f])))

                           (define replace
                             (lambda (tpl)
                               (cond
                                 [(null? tpl) '()]
                                 [(pair? tpl) (cons (replace (car tpl)) (replace (cdr tpl)))]
                                 [(literal? tpl) tpl]
                                 [(symbol? tpl) (lookup tpl)]
                                 [else tpl])))

                           (cond
                             [(match pattern stx)
                              (replace template)]
                             [else
                              (set! bindings '())
                              (loop (cdr rules))])]
                           
                          [else (loop (cdr rules))])])))

                 (loop rules))])))

      ))

    (define env (environment))
    (eval stmts env)
    env))
    

(define expand
  (lambda (expr env)
    expr))

;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Expander for syntax macros
;;;   

;; Transforms "xforms" are procedures of one argument that
;; take a syntax object as input and returns a syntax object.
;; Transforms are introduced into scope via `define-syntaxes`
;; in a top-level context and `let-syntaxes` in an
;; expression-level context.
;;
;; This expander stores xforms as an association list mapping
;;  <name> -> (<proc>, <xforms-in-scope>, <eval-env>)
;;

;; Should the expander use the boot expander for evaluation?
(define $expander-boot-expander? #f)
(define $expander-pattern-vars null)

;; Expand top-level form
(define (expand expr xforms env)
  ;; looks up a transform returning #f if none is found
  (define (lookup-or-false key)
    (let loop ([xforms xforms])
      (cond [(null? xforms) #f]
            [(eq? (caar xforms) key) (cdar xforms)]
            [else (loop (cdr xforms))])))

  ;; expression-level expander
  (define (expand-expr expr xforms)
    (define expr* (syntax-e expr))
    (set! $expander-pattern-vars
          (filter (lambda (e) (pattern-variable? (cdr e))) xforms))
    (cond
      [(null? expr*)
        expr]
      [(pair? expr*)
       (define first (syntax-e (car expr*)))
       (cond
         [(symbol? first)
          (define maybe-xform (lookup-or-false first))
          (define maybe-args (cdr expr*))
          (datum->syntax
            (cond
              [(and maybe-xform (procedure? maybe-xform))
               (define old-expander? (boot-expander?))
               (define expanded
                 (call-with-values
                   (lambda ()
                    ;  (display "< ") (writeln expr)
                     (boot-expander? $expander-boot-expander?)
                     (maybe-xform expr))
                   (lambda results
                     (boot-expander? old-expander?)
                     (if (and (= (length results) 1) (syntax? (car results)))
                         (car results)
                         (error 'expander
                                "transformer produced something other than syntax"
                                (car results))))))
              ;  (display "> ") (writeln expanded)
               (define expanded* (expand-expr expanded xforms))
              ;  (display "> ") (writeln expanded*)
               expanded*]
              [(eq? first 'let-syntaxes)
               (define (panic!) (syntax-error 'let-syntaxes "bad syntax" expr))
               (define rib maybe-args)
               (define maybe-bindings (syntax-e (car rib)))
               (cond
                 [(list? maybe-bindings)
                  (let loop ([bindings maybe-bindings])
                    (cond
                      [(null? bindings)
                       (define exprs (cdr rib))
                       (if (list? exprs)
                           (cons (quote-syntax let-values)
                             (cons (quote-syntax ())
                               (map (lambda (e) (expand-expr e xforms)) exprs)))
                           (syntax-error 'let-syntaxes "bad syntax" expr))]
                      [else
                       (define maybe-binding (syntax-e (car bindings)))
                       (cond
                         [(and (list? maybe-binding) (= (length maybe-binding) 2))
                          (define ids (syntax-e (car maybe-binding)))
                          (define val (cadr maybe-binding))
                          (cond
                            [(list? ids)
                             (define xform-names
                               (let loop ([names ids] [acc '()])
                               (if (null? names)
                                   (reverse acc)
                                   (loop (cdr names)
                                         (cons (syntax-e (car names)) acc)))))
                             (define expr (syntax->datum val))
                             (define old-expander? (boot-expander?))
                             (call-with-values
                               (lambda ()
                                 (boot-expander? $expander-boot-expander?)
                                 (eval expr env))
                               (lambda results
                                 (boot-expander? old-expander?)
                                 (if (not (= (length xform-names) (length results)))
                                     (error 'let-syntaxes "result arity mismatch" "expected"
                                            (length xform-names) "received" (length results))
                                     (let loop ([xform-names xform-names] [results results])
                                       (cond
                                         [(null? xform-names)
                                          (void)]
                                         [else
                                          (let ([xform-name (car xform-names)]
                                                [xform (car results)])
                                            (cond
                                              [(or (procedure? xform) (pattern-variable? xform))
                                               (define binding (cons xform-name xform))
                                               (set! xforms (cons binding xforms))
                                               (loop (cdr xform-names) (cdr results))]
                                              [else
                                               (error 'let-syntaxes
                                                      "expected a procedure, received"
                                                      xform)]))])))))
                             (loop (cdr bindings))]
                            [else
                             (panic!)])]
                         [else (panic!)])]))]
                 [else (panic!)])]
              [(or (eq? first 'quote-syntax)
                   (eq? first 'quote))
               expr*]
              [else
               (cons
                 (car expr*)
                 (let loop ([args maybe-args])
                   (cond
                     [(null? args) '()]
                     [(pair? args) (cons (expand-expr (car args) xforms) (loop (cdr args)))]
                     [else (expand-expr args xforms)])))]))]
         [else
          (datum->syntax
            (let loop ([args expr*])
              (cond
                [(null? args) '()]
                [(pair? args) (cons (expand-expr (car args) xforms) (loop (cdr args)))]
                [else (expand-expr args xforms)])))])]
      [(symbol? expr*)
       (define maybe-xform (lookup-or-false expr*))
       (datum->syntax
         (if maybe-xform
             (expand-expr (maybe-xform expr) xforms)
             expr))]
      [else
       expr]))

  (define expanded (expand-expr expr xforms))
  (set! $expander-pattern-vars null)
  expanded) 

(define (expand/module exprs xforms env)
  ; checks if an expression is a syntactic form:
  ;  <expr> = (<name> . <rest>)
  (define ((_-form? form-name) expr)
    (and (stx-pair? expr)
         (let ([head (stx-car expr)])
           (and (identifier? head)
                (eq? (syntax-e head) form-name)))))

  (define define-values-form? (_-form? 'define-values))
  (define define-syntaxes-form? (_-form? 'define-syntaxes))
  (define let-values-form? (_-form? 'let-values))
  (define letrec-values-form? (_-form? 'letrec-values))
  (define let-syntaxes-form? (_-form? 'let-syntaxes))
  (define quote-form? (_-form? 'quote))
  (define quote-syntax-form? (_-form? 'quote-syntax))
  (define lambda-form? (_-form? 'lambda))
  (define begin-form? (_-form? 'begin))
  (define if-form? (_-form? 'if))

  (define (lookup-xform maybe-id xforms)
    (and (identifier? maybe-id)
         (assoc (syntax-e maybe-id) xforms)))

  ; returns an symbol if it is a duplicate, else false
  (define (duplicate-identifier ids new-ids)
    (let loop ([ids ids] [new-ids new-ids])
      (cond [(null? new-ids) #f]
            [else
             (define dup (member (car new-ids) ids))
             (if dup
                 dup
                 (loop (cons (car new-ids) ids) (cdr new-ids)))])))

  ; checks if a `define-syntaxes` / `define-values` form is valid
  ; assumes form is `(<name> . <rest>)
  (define (check-define-syntaxes/values-form! name form)
    (define rib (stx-cdr form))
    (if (stx-null? rib)
        (syntax-error name "bad syntax" form)
        (let ([ids (syntax->list (stx-car rib))]
              [rib (stx-cdr rib)])
          (if (and (list? ids) (andmap identifier? ids))
              (if (stx-null? rib)
                  (syntax-error name "expected an expression after identifiers" form)
                  (let ([rib (stx-cdr rib)])
                    (if (stx-null? rib)
                        (void)
                        (syntax-error name "too many expressions" form))))
              (syntax-error name "not identifiers" form ids)))))

  ; checks if a `let-syntaxes` / `let-values` form is valid
  ; assumes form is `(<name> . <rest>)
  (define (check-let-syntaxes/values-form! name form)
    (define rib (stx-cdr form))
    (if (stx-null? rib)
        (syntax-error name "bad syntax" form)
        (let ([bindings (syntax->list (stx-car rib))]
              [rib (stx-cdr rib)])
          (if (null? rib)
              (syntax-error name "missing body" form)
              (if (or (list? rib) (and (syntax? rib) (list? (syntax->list rib))))
                  (if (list? bindings)
                      (let loop ([bindings bindings])
                        (cond [(null? bindings) (void)]
                              [else
                              (let ([bind (syntax->list (car bindings))])
                                (if (not (and (list? bind) (= (length bind) 2)))
                                    (syntax-error name "not identifiers and expression" form bind)
                                    (let ([ids (syntax->list (car bind))])
                                      (if (and (list? ids) (andmap identifier? ids))
                                          (loop (cdr bindings))
                                          (syntax-error name "not identifiers" form ids)))))]))
                      (syntax-error #f "expected a sequence of expressions after the bindings" form))
                  (syntax-error name "not a sequence of bindings" form bindings))))))

  ; checks if a `lambda` form is valid
  ; assues form is `(lambda . <rest>)`
  (define (check-lambda-form! form)
    (define rib (stx-cdr form))
    (if (stx-null? rib)
        (syntax-error #f "missing formals" form)
        (let ([formals (stx-car rib)]
              [rib (stx-cdr rib)])
          (if (null? rib)
              (syntax-error #f "missing expression after formals" form)
              (let ([rib (stx-cdr rib)])
                (if (or (list? rib) (and (syntax? rib) (list? (syntax->list rib))))
                    (void)
                    (syntax-error #f "expected a sequence of expressions after formals" form)))))))

  ; checks if a `begin` form is valid
  ; assues form is `(<name> . <rest>)`
  (define (check-begin-form! form)
    (if (syntax->list form)
        (void)
        (syntax-error 'begin "bad syntax" form)))

  ; checks if a unary form is valid, i.e. `(<name> <expr>)`.
  (define (check-1ary-form! name form)
    (define rib (stx-cdr form))
    (if (stx-null? rib)
        (syntax-error name "expected an expression" form)
        (let ([rib (stx-cdr rib)])
          (if (stx-null? rib)
              (void)
              (syntax-error name "too many expressions" form)))))

  ; checks if an `if` form is valid, i.e. `(if <cond> <if-true> <if-false>)`.
  (define (check-if-form! form)
    (define rib (stx-cdr form))
    (if (stx-null? rib)
        (syntax-error 'if "bad syntax" form)
        (let ([rib (stx-cdr rib)])
          (if (stx-null? rib)
              (syntax-error 'if "bad syntax" form)
              (let ([rib (stx-cdr rib)])
                (if (stx-null? rib)
                    (syntax-error 'if "missing an \"else\" statement" form)
                    (let ([rib (stx-cdr rib)])
                      (if (stx-null? rib)
                          (void)
                          (syntax-error name "too many expressions" form)))))))))

  ; checks for a duplicate identifier, raising an exception if one is encountered
  (define (check-duplicate-identifier! form name ids new-ids)
    (let ([dup (duplicate-identifier ids new-ids)])
      (if dup
          (syntax-error name "duplicate identifier" form dup)
          (void))))

  ; returns the identifiers of a `define-syntaxes` / `define-values` form
  (define (define-syntaxes/values-identifiers form)
    (map syntax-e (syntax->list (stx-car (stx-cdr form)))))

  ; returns the expr of a `define-syntaxes` / `define-values` form
  (define (define-syntaxes/values-expr form)
    (stx-car (stx-cdr (stx-cdr form))))

  ; evaluates an expression in a given environment returning potentially
  ; multiple values the `boot-expander?` parameter is set with `expander?`
  (define (eval/values expr env expander?)
    (define old-expander? (boot-expander?))
    (call-with-values
      (lambda ()
        (boot-expander? expander?)
        (eval expr env))
      (lambda results
        (boot-expander? old-expander?)
        results)))
  
  ; evaluates an expression in a given environment returning potentially
  ; multiple values the `boot-expander?` parameter is set with `expander?`
  (define (eval/xform xform expr name expander?)
    (define old-expander? (boot-expander?))
    (call-with-values
      (lambda ()
        (boot-expander? expander?)
        (xform expr))
      (lambda results
        (boot-expander? old-expander?)
        (cond
          [(not (= (length results) 1)) 
           (error #f "result arity mismatch" "expected 1" "received" 2)]
          [(syntax? (car results))
           (car results)]
          [else
           (error name "transformer produced something other than syntax" (car results))]))))

  ; expression context
  ; Expr, List of Xform -> Expr
  (define (expand/expr expr xforms)
    (set! $expander-pattern-vars (filter (lambda (e) (pattern-variable? (cdr e))) xforms))
    (let loop ([expr expr])
      (cond
        [(define-values-form? expr)
         (check-define-syntaxes/values-form! 'define-values expr)
         (let ([ids (define-syntaxes/values-identifiers expr)])
           (check-duplicate-identifier! expr 'define-values null ids)
           (let ([form (syntax->list expr)])
             (datum->syntax
               (list
                 (car form)
                 (cadr form)
                 (loop (caddr form))))))]
        [(let-syntaxes-form? expr)
         (check-let-syntaxes/values-form! 'let-syntaxes expr)
         (define form (syntax->list expr))
         (let rec ([bindings (syntax->list (cadr form))] [let-ids null] [xforms xforms])
           (cond
             [(null? bindings)
              (expand/expr  
                (datum->syntax
                  (cons (quote-syntax let-values)
                    (cons (list)
                      (cddr form))))
                xforms)]
             [else
              (define binding (syntax->list (car bindings)))
              (define binding-ids (syntax->datum (car binding)))
              (check-duplicate-identifier! expr 'let-syntaxes let-ids binding-ids)
              (define results
                (let ([rhs (loop (cadr binding))])
                  (eval/values (syntax->datum rhs) env $module-boot-expander?)))
              (if (= (length binding-ids) (length results))
                  (let bind-xforms ([ids binding-ids] [results results] [xforms xforms])
                    (cond
                      [(null? ids)
                       (rec (cdr bindings) (append binding-ids let-ids) xforms)]
                      [else
                       (define id (car ids))
                       (define xform (car results))
                       (cond
                         [(or (procedure? xform) (pattern-variable? xform))
                          (define binding (cons id xform))
                          (bind-xforms (cdr ids) (cdr results) (cons binding xforms))]
                         [else
                          (error 'let-syntaxes "expected a procedure? received" xform)])]))
                  (error 'let-syntaxes "result arity mismatch"
                         "expected" (length ids)
                         "received" (length results)))]))]
        [(or (let-values-form? expr) (letrec-values-form? expr))
         (define name (if (let-values-form? expr) 'let-values 'letrec-values))
         (check-let-syntaxes/values-form! name expr)
         (define form (syntax->list expr))
         (datum->syntax
           (cons (car form)
             (cons
               (let rec ([bindings (syntax->list (cadr form))] [let-ids null])
                 (cond
                   [(null? bindings) null]
                   [else
                    (define binding (syntax->list (car bindings)))
                    (define ids (syntax->datum (car binding)))
                    (check-duplicate-identifier! expr name let-ids ids)
                    (cons (list (car binding) (loop (cadr binding)))
                          (rec (cdr bindings) (append ids let-ids)))]))
               (map loop (cddr form)))))]
        [(lambda-form? expr)
         (check-lambda-form! expr)
         (define head (stx-car expr))
         (define formals (stx-car (stx-cdr expr)))
         (define body (stx-cdr (stx-cdr expr)))
         (datum->syntax
           (cons head
             (cons formals
               (map loop body))))]
        [(if-form? expr)
         (check-if-form! expr)
         (define form (syntax->list expr))
         (datum->syntax
           (list
            (car form)
            (loop (cadr form))
            (loop (caddr form))
            (loop (cadddr form))))]
        [(begin-form? expr)
         (check-begin-form! expr)
         (datum->syntax
           (cons (stx-car expr)
                 (map loop (cdr (syntax->list expr)))))]
        [(quote-form? expr)
         (check-1ary-form! 'quote expr)
         expr]
        [(quote-syntax-form? expr)
         (check-1ary-form! 'quote-syntax expr)
         expr]
        [(stx-pair? expr)
         (define head (stx-car expr))
         (define maybe-xform (lookup-xform head xforms))
         (if maybe-xform
            (loop (eval/xform maybe-xform expr (syntax-e head) $module-boot-expander?))
            (datum->syntax (map loop (syntax->list expr))))]
        [(identifier? expr)
         (define maybe-xform (lookup-xform expr xforms))
         (if maybe-xform
             (loop (eval/xform maybe-xform expr (syntax-e head) $module-boot-expander?))
             expr)]
        [(let ([datum (syntax-e expr)])
           (or (boolean? datum)
               (number? datum)
               (string? datum)))
         expr]
        [else
         (syntax-error #f "bad syntax" expr)])))

  ; module context
  ;  `define-values` => defers expansion until all expressions have been processed
  ;  `define-syntaxes` => expands and evaluates RHS and updates `xforms`
  ;  `begin` => splices sequence of expressions
  ;  <expr> => invokes top-level expander
  ; List of Expr, List of Xform -> List of Expr, List of Xform
  (define (expand/module exprs xforms)
    ; List of Expr, List of Xform -> List of Expr, List of Xform
    (define (expand/non-define-values exprs xforms)
      (let loop ([exprs exprs] [xforms xforms] [value-ids null] [xform-ids null])
        (cond
          [(null? exprs)
           (values null xforms)]
          [(define-syntaxes-form? (car exprs))
           (define-values (ids rhs)
             (let ([expr (car exprs)])
               (check-define-syntaxes/values-form! 'define-syntaxes expr)
               (let ([ids (define-syntaxes/values-identifiers expr)])
                 (check-duplicate-identifier! expr 'define-syntaxes xform-ids ids)
                 (values ids (define-syntaxes/values-expr expr)))))
           (define results
             (let ([rhs* (expand/expr rhs xforms)])
               (eval/values (syntax->datum rhs*) env $module-boot-expander?)))
           (if (= (length ids) (length results))
               (let bind-xforms ([ids ids] [results results] [xforms xforms] [xform-ids xform-ids])
                 (cond
                   [(null? ids)
                    (loop (cdr exprs) xforms value-ids xform-ids)]
                   [else
                    (define id (car ids))
                    (define xform (car results))
                    (cond
                      [(procedure? xform)
                       (define binding (cons id xform))
                       (bind-xforms (cdr ids) (cdr results) (cons binding xforms) (cons id xform-ids))]
                      [else
                       (error 'define-syntaxes "expected a procedure? received" xform)])]))
               (error 'define-syntaxes "result arity mismatch" "expected"
                      (length ids) "received" (length results)))]
          [(define-values-form? (car exprs))
           (define ids
             (let ([expr (car exprs)])
               (check-define-syntaxes/values-form! 'define-values expr)
               (define-syntaxes/values-identifiers expr)))
           (define-values (exprs* xforms*) (loop (cdr exprs) xforms (append ids value-ids) xform-ids))
           (values (cons (car exprs) exprs*) xforms*)]
          [(begin-form? (car exprs))
           (check-begin-form! (car exprs))
           (loop (append (cdr (syntax->list (car exprs))) (cdr exprs)) xforms value-ids xform-ids)]
          [(and (stx-pair? (car exprs)) (identifier? (stx-car (car exprs))))
           (define head (stx-car (car exprs)))
           (define maybe-xform (lookup-xform head xforms))
           (cond
             [maybe-xform
              (define result (eval/xform maybe-xform (car exprs) (syntax-e head) $expander-boot-expander?))
              (loop (cons result (cdr exprs)) xforms value-ids xform-ids)]
             [else
              (define expr* (expand/expr (car exprs) xforms))
              (define-values (exprs* xforms*) (loop (cdr exprs) xforms value-ids xform-ids))
              (values (cons expr* exprs*) xforms*)])]
          [else
           (define expr* (expand/expr (car exprs) xforms))
           (define-values (exprs* xforms*) (loop (cdr exprs) xforms value-ids xform-ids))
           (values (cons expr* exprs*) xforms*)])))
    
    ; Any `define-values` form is deferred
    ; List of Expr, List of Xform -> List of Expr
    (define (expand/define-values exprs xforms)
      (let loop ([exprs exprs] [exprs* null])
        (cond
          [(null? exprs) (reverse exprs*)]
          [(define-values-form? (car exprs))
           (define form (syntax->list (car exprs)))
           (loop (cdr exprs)
                 (cons
                   (datum->syntax
                     (list
                       (car form)
                       (cadr form)
                       (expand/expr (caddr form) xforms)))
                   exprs*))]
          [else (loop (cdr exprs) (cons (car exprs) exprs*))])))

    (define-values (exprs* xforms*) (expand/non-define-values exprs xforms))
    (values (expand/define-values exprs* xforms*) xforms*))

  ; invoke the module-level expander
  (expand/module exprs xforms))

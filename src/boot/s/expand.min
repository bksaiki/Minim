;;;
;;;   Minim boot library for the bootstrap interpreter
;;;   Brett Saiki
;;;

;;;
;;;   Expander for syntax macros
;;;   

;; Should the expander use the boot expander for evaluation?
(define $expander-boot-expander? #f)

(define (expand expr xforms)
  ;; looks up a transform returning #f if none is found
  (define (lookup-or-false key)
    (let loop ([xforms xforms])
      (cond [(null? xforms) #f]
            [(eq? (caar xforms) key) (cdar xforms)]
            [else (loop (cdr xforms))])))

  ;; expression-level expander
  (define (expand-expr expr)
    (define expr* (syntax-e expr))
    (cond
      [(null? expr*)
        expr]
      [(pair? expr*)
       (define first (syntax-e (car expr*)))
       (cond
         [(symbol? first)
          (define maybe-xform (lookup-or-false first))
          (define maybe-args (cdr expr*))
          (datum->syntax
            (cond
              [maybe-xform
               (define old-expander? (boot-expander?))
               (define expanded
                 (call-with-values
                   (lambda ()
                     (boot-expander? $expander-boot-expander?)
                     (maybe-xform expr))
                   (lambda results
                     (boot-expander? old-expander?)
                     (if (and (= (length results) 1) (syntax? (car results)))
                         (car results)
                         (error 'expander
                                "transformer produced something other than syntax"
                                (car results))))))
               (define expanded* (expand-expr expanded))
               (write expr) (write-char #\space) (writeln expanded*)
               expanded*]
              [(eq? first 'quote-syntax)
               expr*]
              [else
               (cons
                 (car expr*)
                 (let loop ([args maybe-args])
                   (cond
                     [(null? args) '()]
                     [(pair? args) (cons (expand-expr (car args)) (loop (cdr args)))]
                     [else (expand-expr args)])))]))]
         [else
          (datum->syntax
            (let loop ([args expr*])
              (cond
                [(null? args) '()]
                [(pair? args) (cons (expand-expr (car args)) (loop (cdr args)))]
                [else (expand-expr args)])))])]
      [(symbol? expr*)
       (define maybe-xform (lookup-or-false expr*))
       (datum->syntax
         (if maybe-xform
             (expand-expr (maybe-xform expr))
             expr))]
      [else
       expr]))

  (expand-expr expr))
